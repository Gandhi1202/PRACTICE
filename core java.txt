Post by Ravishankar Singh
Ravishankar Singh
Created 22 Jan22 Jan
Notes(22-JAN-24)
Displaying 22-Jan-11AM.png
22-Jan-11AM.png

Batch_25_notes.txt
Text

Add class commentâ€¦

javaravishanker@gmail.com
29-August-23
-------------
A language is a communication media.

Any language contains two important things

1) Syntax (Rules)
2) Semantics (Structure OR Meaning)

English langugae translation :
--------------------------------
Subject + verb + Object (Syntax)

He is a boy. (Valid)

He is a box. (Invalid)

Example of Progamming Language :
----------------------------------------
int a = 10;
int b = 0;
int c = a/b;   

Note :- 
Syntax of the programming language is taken care by compiler.
compiler generates errors if a user does not follow the syntax of the programming language.

Semantics is taken care by our runtime Environment. It generates Exception if a user does not follow the semantics.
----------------------------------------------------------------
30-Aug-23
---------
What is the difference between statically typed(Strongly typed)
and Dynamically typed (loosly typed) language?


Statically(Strongly) typed language :-
---------------------------------------
The languages where data type is compulsory before initialization of a variable are called statically typed language.
In these languages we can hold same kind of value during the execution of the program.

Ex:- C,C++,Core Java, C#

Dynamically(Loosly) typed language :-
-------------------------------------------
The languages where data type is not compulsory and it is optional before initialization of a variable then it is called dynamically typed language.

In these languages we can hold different kind of value during the execution of the program.
Ex:- Visual Basic, Javascript, Python
----------------------------------------------------------------
Flavors Of JAVA language :
------------------------------
1) JSE (Java Standard Edition) ->J2SE -> Core Java

2) JEE (Java Enterprise Edition) -> J2EE -> Advanced Java

3) JME (Java Micro Edition) -> J2ME -> Android Application

-------------------------------------------------------------------
What is the difference between stand-alone programs and web-related 
programs?

Standalone Application
--------------------------
If the creation(development), compilation and execution of the program, everthing is done in a single system then it is called stand-alone program.
Eg:- C, C++, Java, C# and so on.

Stand alone programs are also known as Software OR Desktop application.

As a developer we should always suggest stand alone application to our client, if the client data is private or if we want to upload the data in the website then we need to provide a separate username and password to each and every client.

Web - related Application :-
--------------------------------
If creation of the program, compilation of the program and execution of the program, Everything is done on different places then it is called web related program.
Eg:- Advanced Java, PHP, ASP.NET, Python

Web related programs are also known as websites or web application.

As a developer we should suggest website to our client if the client information is public.
-------------------------------------------------------------------
What is a function :-
-----------------------
A function is a self defined block for any general purpose, calculation or printing some data.

The major benefits with function are :-
-------------------------------------------
1) Modularity :- Dividing the bigger modules into number of smaller modules where each module will perform its independent task.

2) Easy understanding :- Once we divide the bigger task into number of smaller tasks then it is easy to understand the entire code.

3) Reusability :- We can reuse a particular module so many number of times so It enhances the reusability nature.

Note :- In java we always reuse our classes.

4) Easy Debugging :- Debugging means finding the errors, With function It is easy to find out the errors because each module is independent with another module. 
------------------------------------------------------------------
31-Aug-23
---------

Why we pass parameter to a function :-
--------------------------------------------
We pass parameter to a function for providing more information regrading the function.

Eg:-

userdefined function      predefined function
public void start(int a)  start(3);//The fan is running in mode 3
{
  //start the fan
}

--------------------------------------------------------------------------------------
Why functions are called method in java?
----------------------------------------------
In C++ there is a facility to write a function inside the class as well as outside of the class by using :: (Scope resolution Operator), But in java all the functions must be declared inside the class only.

That is the reason member functions are called method in java.

Variable -->  Field
function ---> Method
-------------------------------------------------------------------
History of java :
----------------
First Name of Java : OAK (In the year 1991 which is a tree name)

Project Name :- Green Project 

Inventor of Java : - James Gosling and his friends

Official Symbol :- Coffee CUP

Java :- Island (Indonesia)
-----------------------------------------------------------------
01-Sep-23
---------
Role of Java Compiler :
-----------------------
1) It will check the syntax.
2) It also checks compatibility issues(LHS = RHS
3) It converts the source code into machine code.
Why java become so popular in the IT Industry ?
-----------------------------------------------------
C and C++ programs are platform dependent programs that means the .exe file created on one machine will not be executed on the another machine if the system configuration is different.

That is the reason C and C++ programs are not suitable for website development.


Where as on the other hand java is a platform independent language. Whenever we write a java program, the extension of java program must be .java. Now this .java file we submit to java compiler (javac) for compilation process. After successful compilation the compiler will generate a very special machine code file i.e .class file (also known as bytecode). Now this .class file we submit to JVM for execution purpose.

The role of JVM is to load and execute the .class file. Here JVM plays a major role because It converts the .class file into appropriate machine code instruction (Operating System format) so java becomes platform independent language and it is highly suitable for website development.

Note :- We have different JVM for different Operating System that means JVM is platform dependent technology where as Java is platform Independent technology.
-------------------------------------------------------------------
What is the difference between bit code and bytecode?
-----------------------------------------------------
Bit code is directly understood by Operating System but on the other hand byte code is understood by JVM, JVM is going to convert this byte code into machine understandable format.
-------------------------------------------------------------------
Comments in JAVA :-
------------------------
Comments are used to increase the readability of the program. It is ignored by the compiler.
In java we have 3 types of comments 

1) Single line Comment (//)

2) Multiline Comment (/* ------------------------------- */)

3) Documentation Comment (/** -------------------------- */)

/**
Name of the Project : Online Shopping
Date created :- 12-12-2021
Last Modified - 16-01-2022
Author :- Ravishankar
Modules : -  10 Modules
*/
------------------------------------------------------------------
Note :- 
1) In java whenever we write a program we need at least a main method which takes String array as an argument.

2) In java the execution of the program always starts and ends with main method.

Write a program in Java to display Welcome message 
--------------------------------------------------
public class Welcome 
{
	public static void main(String[] args) 
	{
		System.out.println("Welcome to Java language !!!");
	}
}
-----------------------------------------------------------------
Description of main() method :
-----------------------------------

public :-
--------
public is an access modifier in java. The main method must be declared as public otherwise JVM cannot execute our main method or in other words JVM can't enter inside the main method for execution of the program.

If main method is not declared as public then program will compile but it will not be executed by JVM.

Note :- From java compiler point of view there is no rule to declare our methods as public.
-----------------------------------------------------------------
static :-
--------
In java our main method is static so JVM need not to create an object to call the main method.

If a method is declared as a static then we need not to create an object to call that method. 

We can directly call the static methods, if it is defined in the same class on the other hand if is defined in another class then we can call with the help of class name.

If we don't declare the main method as static method then our program will compile but it will not be executed by JVM.
-----------------------------------------------------------------
void :-
-------
It is a keyword. It means no return type. Whenever we define any method in java and if we don't want to return any kind of value from that particular method then we should write void before the name of the method.
Eg:

public void input()                       public int accept()
{                                                 {
}                                                    return 15;
						   }

Note :- In the main method if we don't write void or any other kind of return type then it will generate a compilation error.

In java whenever we define a method then compulsory we should define return type of method.(Syntax rule)
-----------------------------------------------------------------
main() :-
----------
It is a userdefined function/method because a user is responsible to define some logic inside the main method.

main() method is very important method because every program execution will start from main() method only, as well as the execution of the program ends with main() method only. 

Internally JVM is calling this main method with the help of class name.
-----------------------------------------------------------------
Command Line Argument (Introduction):-
-------------------------------------
Whenever we pass an argument/parameter to the main method then it is called Command Line Argument.

The argument inside the main method is String because String is a alpha-numeric collection of character so, It can accept numbers,decimals, characters, combination of number and character.

That is the reason java software people has provided String as a parameter inside the main method.(More Wider scope to accept the value)
-----------------------------------------------------------------
04-Sep-23
---------
String [] args :-
------------------
Here String is a predefined class available in java.lang package(Header files in C and C++) and args is an array variable of type String.

Note :- args is an array variable, we can take square bracket before the variable as well as after the variable.
--------------------------------------------------------------------
System.out.println() :-
-------------------------
It is an output statement in java, By using System.out.println() statement we can print anything on the console.

In System.out.println(), System is a predefined class available in java.lang package, out is a reference variable of PrintStream class available in java.io package and println() is a predfined method available in PrintStream class.

In System.out, .(dot) is a member access operator. It is called as period. It is used to access the member of the class.
-------------------------------------------------------------------
//Write a program in java to add two number
public class Add 
{
	public static void main(String[] args) 
	{
		int x = 12;
		int y = 24;
		int z = x + y;
		System.out.println(z);
	}
}

Note :- We are getting the output as 36 but it is not user-friendly
        message 
--------------------------------------------------------------------
How to provide user-friendly message :
---------------------------------------
//Write a program in java to add two number
public class Add 
{
	public static void main(String[] args) 
	{
		int x = 12;
		int y = 89;
		int z = x + y;
		System.out.println("Sum is :"+z);
	}
}
--------------------------------------------------------------------
//Add two numbers without 3rd variable
public class Addition 
{
	public static void main(String[] args) 
	{
		int x = 12;
		int y = 12;
		System.out.println("Sum is :"+x+y);
		System.out.println(+x+y);
		System.out.println(""+x+y);
		System.out.println("Sum is :"+(x+y));
	}
}
-------------------------------------------------------------------
How to write our first program Eclipse IDE :
--------------------------------------------------
-> It stands for Integrated Development Environment.

-> By using Eclipse IDE , In a single window we can develop, compile and execute our programs

-> Eclipse IDE provides an environment to execute our program with very less time. Once the time will be reduced then automatically the cost of the project will be reduced.

What is a packge :
------------------
-> A package is nothing but folder in widows.

-> The main purpose of package to arrange our programs so fast searching will become easy.

The following command will create a folder having same name with package :

Program :
---------

package com.nit.basic;

public class Hello 
{
    public void m1()
    {
    }
}

javac  -d  .  Hello.java (Compilation style of the programs which
                           contains package statement in cmd)
----------------------------------------------------------------------
Command Line Argument :
------------------------------
Whenever we pass any argument to the main method then it is called Command Line Argument.

By using Command Line Argument we can pass some value at runtime.

The advantage of command line argument is "Single time compilation and number of times execution".
------------------------------------------------------------------
//Write a program to pass some value at runtime using Command Line Argument

public class Command
{
	public static void main(String[] x) 
	{
		System.out.println(x[0]);
	}
}

Note :- javac Command.java [Compilation]
        java Command "Virat Kohli" [Executing and passing Virat kohli at runtime]
        Here It will print Virat Kohli
--------------------------------------------------------------------
05-Sep-23
---------
//WAP in java to add two numbers by using command Line Argument
public class CommandAdd 
{
	public static void main(String x[]) 
	{
		System.out.println(x[0] + x[1]);
	}
}

Note :- In the above program both the values are appended to each other and here '+' operator behaves like String concatenation operator
----------------------------------------------------------------------
How to convert a String value into integer :
--------------------------------------------
If we want to convert any String value into integer then java software people has provided a predefined class called Integer available in java.lang package, this class contains a predefined static method parseInt(String x) through which we can convert any String value into integer.
This parseInt(String str) method throws an exception
java.lang.NumberFormatException

//This Integer class is a prdefined class given by java software 
public class Integer
{
   public static int parseInt(String x)
   {
      //Logic to convert String into integer and returns integer

      return integer value;
   }
}
---------------------------------------------------------------------
package com.nit.basic;

public class CommandAdd 
{
	public static void main(String x[]) 
	{			
		//Converting String to integer
		  int i = Integer.parseInt(x[0]);
		  int j = Integer.parseInt(x[1]);        
		
		  System.out.println("Sum is :"+(i+j));	
	}
}

How to execute Command line program in Eclipse IDE :
-------------------------------------------------------------
Right click on the Program -> Run as -> Run configuration -> Arguments -> Program Argument (Pass some value accroding to your use ) -> Click on Run
----------------------------------------------------------------------
06-Sep-23
---------
Naming convention in java language :
--------------------------------------------
1) How to write a class in java 
----------------------------------
While writing a class in java we should follow pascal naming conventation.

ThisIsExampleOfClass (Each word first letter is capital)
Example :
-----------
String 
System
Integer
BufferedReader
DataInputStream
ClassNotFoundException
ArithmeticException

2) How to write a method in java :
---------------------------------------
In order to write methods in java we need to follow camel case naming conventation.

thisIsExampleOfMethod()

Example:
----------
read()
readLine()
toUpperCase()
charAt()


3) How to write variable(Fields) in java 
--------------------------------------------
In order to write variables in java we need to follow camel case naming convention.

rollNumber;
employeeName;
customerNumber;
customerBill;

4) How to final variabl(Field)
-------------------------------
final double PI = 3.14;
final int A = 90;

5) How to write final and static variable 

   MAX_VALUE;
   MIN_VALUE;
Each character must be capital and in between every word _ symbol should be there.
-----------------------------------------------------------------------
Token :
--------
A token is the smallest unit of the program that is identified by the compiler.

Every Java statements and expressions are created using tokens.

A token can be divided into 5 types 

1) Keywords
2) Identifiers
3) Literals
4) Punctuators
5) Operators

Keyword :- 
----------
A keyword is a predefined word whose meaning is already defined by the compiler.

In java all the keywords must be in lowercase only.

A keyword we can't use as a name of the variable, name of the class or name of the method.

true, false and null look like keywords but actually they are literals.


Identifiers :
--------------
A name in java program  by default considered as identifiers.

Assigned to variable, method, classes to uniquely identify them.

We can't use keyword as an identifier.

Ex:-

class Fan 
{
   int coil  ;
   
   void start()
   {
   }
}

Here Fan(Name of the class), coil (Name of the variable) and start(Name of the function) are identifiers.
------------------------------------------------------------------------------------
Rules for defining an identifier :
------------------------------------
1) Can consist of uppercase(A-Z), lowercase(a-z),  digits(0-9), $ sign, and   underscore (_)
2) Begins with letter, $, and _
3) It is case sensitive
4) Cannot be a keyword
5) No limitation of length 
------------------------------------------------------------------------------------
Literals :-
-----------
Assigning some constant value to variable is called Literal.

Java supports 5 types of Literals :

1) Integral Literal  Ex:-  int x = 15;

2) Floating Point Literal  Ex:- float x = 3.5f;

3) Character Literal Ex:- char ch = 'A';

4) Boolean Literal Ex:- boolean b = true;

5) String Literal Ex:- String x = "Naresh i Technology";

Note :- null is also a literal.
-----------------------------------------------------------------------
Integral Literal :
------------------
If a Numeric literal does not contain any decimal or fraction then it is called Integral Literal.

Ex:- 15, 45, 890 

In integral Literal we have 4 data types 
a) byte (8 bits )
b) short (16 bits)
c) int (32 bits)
d) long (64 bits)


An integral literal we can specify or represent in different ways

a) Decimal literal (Base 10)
b) Octal literal (Base 8)
c) Hexadecimal literal (Base 16)
d) Binary Literal (Base 2) (Available from JDK 1.7 onwards)

Note :- As a developer we can represent an integral literal in different forms(decimal, octal, hexadecimal and binary) but JVM always produces the output in decimal form only

Decimal Literal :- 
-------------------
The base of decimal literal is 10. we can accept any digit from 0-9

Octal Literal :-
----------------
The base is 8. Here we can accept digits from 0-7 only. In java if any integral literal prefeix with '0' (Zero) then it becomes octal lietral.

Example:-

int x = 015; //Valid
int y = 018;//Invalid

Hexadecimal Literal :-
-------------------------
The base is 16. Here we can accept digits from 0-15 (0-9 and A-F). In java if any integral literal prefix with 0X or 0x (zero with capital X OR zero with small x) then it becomes hexadecimal literal.

Example :-

int x = 0X15; //Valid
int y = 0x14;//Valid
int z = 0Xadd; //Valid
int a = 0Xage; //Invalid ['g' is out of range]

Binary Literal :-
-----------------
It is introduced from jdk 1.7 onwards. The base or radix is 2. Here we can accept digits 0 and 1 only. In java if any integral Literal prefix with 0B or 0b (zero capital B or 0 small b) then it becomes binary literal.

Example :-

int x = 0B111; //Valid
int y = 0b101010; //Valid
int z = 0B12; //Invalid [digit 2 is out of range]

Note :-
------
Being a user we can represent integral literal in decimal, octal, hexadecimal and binary form but JVM always produces the result in decimal only.
-----------------------------------------------------------------------
07-Sep-23
----------
//Octal literal
public class Test1
{
	public static void main(String[] args) 
	{
		int one=01;  
		int six=06;
		int seven=07;
		int eight=010;
		int nine=011;
        System.out.println("Octal 01 = "+one);
        System.out.println("Octal 06 = "+six);
		System.out.println("Octal 07 = "+seven);
		System.out.println("Octal 010 = "+eight);
		System.out.println("Octal 011   = "+nine);
	}
}
----------------------------------------------------------------------
//Hexadecimal
public class Test2
{
public static void main(String[] args)
	{
		int i = 0x10;     //16
		int j = 0Xadd;   //2781
		System.out.println(i); 
		System.out.println(j); 
	}
}
----------------------------------------------------------------------
//Binary Literal
public class Test3
{
public static void main(String[] args)
	{
		int i = 0b101; 
		int j = 0B111;
		System.out.println(i); //5
		System.out.println(j); //7		
	}
}
---------------------------------------------------------------------
By default every integral literal is of type int only but we can specify explicitly as long type by suffixing with l (small l) OR L (Capital L).

According to industry standard L is more preferable because l (small l) looks like 1(digit 1).

There is no direct way to specify byte and short literals explicitly. If we assign any integral literal to byte variable and if the value is within the range (-128 to 127) then it is automatically treated as byte literals.

If we assign integral literals to short and if the value is within the range (-32768 to 32767) then automatically it is treated as short literals.
-----------------------------------------------------------------------
/* By default every integral literal is of type int only*/
public class Test4
{
public static void main(String[] args)
	{
                byte b = 128; //error becoz 128 is int value
		System.out.println(b);
		
		short s = 32768; //error becoz 32768 is int value
		System.out.println(s);
    }
}
-----------------------------------------------------------------------
//Assigning smaller data type value to bigger data type
public class Test5
{
public static void main(String[] args)
	{
   	    byte b = 125;
		short s = b;    
		System.out.println(s);
	}
}
-----------------------------------------------------------------------
//Converting bigger type to smaller type
public class Test6
{
public static void main(String[] args)
	{
		short s = 136;
		byte b = (byte) s;
		System.out.println(b);
	}
}
---------------------------------------------------------------------
public class Test7
 {
 public static void main(String[] args)
 {
		byte x = (byte) 127L;
		System.out.println("x value  = "+x);

		long l = 29L;
		System.out.println("l value  = "+l);

        int y = (int) 18L; 
		System.out.println("y value  = "+y);
 
  }
 } 
---------------------------------------------------------------------
08-Sep-23
---------
Java is pure object oriented language or not ?
----------------------------------------------

No, Java is not a pure Object-Oriented language. In fact any language which accepts the primary data type like int, float, char is not a pure object oriented language hence java is also not a pure object oriented language.

If we remove all 8 primitive data types from java then Java will become pure object oriented language.

In java we have a concept called Wrapper classes through which we can convert the primary data types into corrosponding Wrapper Object.

Primary data types                Corrosponding Wrapper Object
byte				-		Byte
short				-		Short
int				-		Integer
long				-		Long
float				-		Float
double				-		Double
char				-		Character
boolean				-		Boolean

All these wrapper classes are available in java.lang package.
---------------------------------------------------------------------
//Autoboxing
public class Test8 
{
	public static void main(String[] args) 
	{
		Integer x = 24;  
		Integer y = 24;
		Integer z = x + y;
		System.out.println("The sum is :"+z);	
		
		Boolean b = true;
		System.out.println(b);

		Double d = 90.90;
		System.out.println(d);
	}
}
---------------------------------------------------------------------
How to know the minimum and maximum value as well as size of integral literal data types:
------------------------------------------------------------------------------------
Thses classes (Wrapper classes) are providing the static and final variables through which we can find out the minimum, maximum value as well as size of the data types

Example:- I want to find out the range and size of Byte class

Byte.MIN_VALUE = -128

Byte.MAX_VALUE = 127

Byte.SIZE = 8 (in bits format)

Here MIN_VALUE, MAX_VALUE and SIZE these are static and final variables available in these classes(Byte, Short, Integer and Long).
---------------------------------------------------------------------
 //Program to find out the range and size of Integeral Data type
public class Test9 
{
	public static void main(String[] args) 
	{
		System.out.println("\n Byte range:");
		System.out.println(" min: " + Byte.MIN_VALUE);
		System.out.println(" max: " + Byte.MAX_VALUE);
		System.out.println(" size :"+Byte.SIZE);
 
		System.out.println("\n Short range:");
		System.out.println(" min: " + Short.MIN_VALUE);
		System.out.println(" max: " + Short.MAX_VALUE);
		System.out.println(" size :"+Short.SIZE);

		System.out.println("\n Integer range:");
		System.out.println(" min: " + Integer.MIN_VALUE);
		System.out.println(" max: " + Integer.MAX_VALUE);
		System.out.println(" size :"+Integer.SIZE);

		System.out.println("\n Long range:");
		System.out.println(" min: " + Long.MIN_VALUE);
		System.out.println(" max: " + Long.MAX_VALUE);
		System.out.println(" size :"+Long.SIZE);
		
	}
}
---------------------------------------------------------------------
Underscore Facility in integeral literal :
--------------------------------------------
From java 7v onwards, now we can provide _ symbol while writing the 
integral literal just to enhance the readability of the number.

//We can provide _ in integral literal
public class Test10 
{
	public static void main(String[] args) 
	{
	    long mobile = 98_1234_5678L;
		System.out.println("Mobile Number is :"+mobile);
	}
}
--------------------------------------------------------------------
public class Test11 
{
	public static void main(String[] args) 
	{
		final int x = 12;  
		byte b = x;
		System.out.println(b);
	}
}
-------------------------------------------------------------------
// Converting from decimal to another number system
public class Test12 
{
      public static void main(String[] argv) 
      {
		   //decimal to Binary
           System.out.println(Integer.toBinaryString(7));

		   //decimal to Octal  
           System.out.println(Integer.toOctalString(15));

		   //decimal to Hexadecimal
           System.out.println(Integer.toHexString(2781));
      }
}
---------------------------------------------------------------------
// Converting from decimal to another number system
public class Test12 
{
      public static void main(String[] argv) 
      {
		   //decimal to Binary
           System.out.println(Integer.toBinaryString(47));

		   //decimal to Octal  
           System.out.println(Integer.toOctalString(15));

		   //decimal to Hexadecimal
           System.out.println(Integer.toHexString(2781));
      }
}
-------------------------------------------------------------------
//var keyword from java 10v
public class Test13 
{
	public static void main(String[] args) 
	{
		    var x = 12; //From java 10v
		    x = 15;
			System.out.println("x value is :"+x);
	}
}
---------------------------------------------------------------------
Floating point Literals :
---------------------------
1) The literals which contains decimal point or fraction are called Floating Point Literal.

Ex:- 23.89; //Floating Point Literal

2) In floating point literals we have 2 data types 
		a) float(32 bits)
		b) double (64 bits)

3) By default every floating point literal is of type double so the following expression will generate a compilation error.
   
      float f = 23.90; //error

      So now we can have 3 solutions 

      float f1 = 23.90f;

      float f2 = 23.90F;

      float f3 = (float) 23.90;



 4) As we know by default every floating point literal is of type double but still we have two flavors given by the java compiler to represent double value explicitly just to enhance the readability of the code.

		a) double d1 = 1.1d;
		b) double d2 = 1.1D;


5) *While working with Integral literal we had four flavors i.e decimal, octal, hexadecimal and binary.
    But while working with floating point literal only decimal form is allowed.

6) *Any integral literal we can assign on floating point literal but floating point literal we can't assign on integral literal. 


7) We can represent floating point literal in exponent form.
 
     Ex:-   double d1 = 15e2; (15 X 10 to the power 2)    
---------------------------------------------------------------------
09-Sep-23
---------
public class Test 
{
	public static void main(String[] args) 
	{
		float f = 2.0; //error
		System.out.println(f);				
	}
}
-----------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{
		//float a = 1.0; 
		float b = 15.29F;
		float c = 15.25f;
		float d = (float) 15.25;
		System.out.println(b +" : "+c+" : " +d);
       
	}
}
---------------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		double e = 15.15d;
		double f = 15.15D;
		System.out.println(d+" : "+e+" : "+f);
	}
}
----------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		 double x = 0129.89;  

		 double y = 0167;

		 double z = 0187; //error

		System.out.println(x+","+y+","+z);
	}
}
-----------------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		double x = 0X29;  

		double y = 0X9.15; 
		
		System.out.println(x+","+y);
	}
}
-----------------------------------------------------------------------
public class Test5 
{
	public static void main(String[] args) 
	{
		double d1 = 15e-3;
		System.out.println("d1 value is :"+d1);		

		double d2 = 15e3;
		System.out.println("d2 value is :"+d2);		
	}
}
----------------------------------------------------------------------
public class Test6 
{
	public static void main(String[] args) 
	{
		double a = 0791; //error

		double b = 0791.0; 

		double c = 0777;  

		double d = 0Xdead;  
		
		double e = 0Xdead.0; //error
	}
}
---------------------------------------------------------------------
public class Test7 
{
	public static void main(String[] args) 
	{
	   double a = 1.5e3;
	   float b = 1.5e3; //error
	   float c = 1.5e3F; 	   
	   double d = 10; 	   
	   int e = 10.0; //error
	   long f = 10D; //error
	   int g = 10F;  //error
	   long l = 12.78F; //error
	}
}
---------------------------------------------------------------------
//Range and size of floating point literal 
public class Test8 
{
	public static void main(String[] args)    
	{
		System.out.println("\n Float range:");
		System.out.println(" min: " + Float.MIN_VALUE);
		System.out.println(" max: " + Float.MAX_VALUE); 
		System.out.println(" size :"+Float.SIZE);

		System.out.println("\n Double range:");
		System.out.println(" min: " + Double.MIN_VALUE);
		System.out.println(" max: " + Double.MAX_VALUE);
		System.out.println(" size :"+Double.SIZE);
	}
} 
----------------------------------------------------------------------
Character Literal :
-------------------
1) It is also known as char literal.

2) In char literal we have one data type i.e char data type which accepts 2 bytes (16 bits) of memory.

3) There are multiple ways to represent char literal as shown below

    a) Single character enclosed with single quotes.

        Ex:- char c = 'a';
 
    b) We can assign integral literal to char data type to represent UNICODE values.
    The older languages like C and C++ support ASCII Value whose range is 0-255 only;
    The Java language supports UNICODE values where the range is 0- 65535.

    c) Char literals we can also assign to integral data types to get the UNICODE value of that particular character.


    d) Char literals we can also represent in UNICODE format where it must contain 4 digit hexadecimal number. 

    The format is '\uXXXX'   [\u0000  to  \uffff]  

    Note :- XXXX is hexadecimal number in digits

     e) A charcter starts with \ (Back slash) is called as escape sequence. Every Escape sequence is also char literal. Java supports the following escape sequences.
     In java we have 8 escape sequences
		a) \n		-> Inserting a new line
		b) \t		-> For providing tab space
		c) \r		-> carriage return(move the cursor to the first line)
		d) \b		-> Inserting a Backspace
		e) \f		->(Form feed) Inserts a form feed (For moving to next page)
		f) \'		-> single quotes
		g) \"		-> Double quotes   
		h) \\		-> Back slace
---------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{
		char ch1 = 'a';
		System.out.println("ch1 value is :"+ch1); 

		char ch2 = 97;   
		System.out.println("ch2 value is :"+ch2); 

		
	}
}
----------------------------------------------------------------------
class Test2 
{
	public static void main(String[] args) 
	{
		int ch = 'A';
		System.out.println("ch value is :"+ch);
	}
}
---------------------------------------------------------------------
//The UNICODE value for ? character is 63
public class Test3 
{
	public static void main(String[] args) 
	{
		char ch1 = 63;  
		System.out.println("ch1 value is :"+ch1);
		
		char ch2 = 64;  
		System.out.println("ch2 value is :"+ch2); 

		char ch3 = 1; 
		System.out.println("ch3 value is :"+ch3); 
	}
}
---------------------------------------------------------------------
public class Test4 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535;
        System.out.println("ch1 value is :"+ch1); 

		char ch2 = 0Xadd;  
		System.out.println("ch2 value is :"+ch2); 
	}
}

Note :- Here we will get the output as ? because the equivalent language translator for these particular characters are not available in my system.
----------------------------------------------------------------------
//Addition of two character in the form of Integer
public class Test5
{
public static void main(String txt[ ])
  {
	int x = 'A'; 
        int y = 'B';
        System.out.println(x+y); 
	System.out.println('A' + 'A');		
   } 
} 
--------------------------------------------------------------------
//Range of UNICODE Value (65535)
class Test6 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535; 
		System.out.println("ch value is :"+ch1);

		char ch2 = 65536; //error
		System.out.println("ch value is :"+ch2);
	}
}
---------------------------------------------------------------------
//WAP in java to describe unicode representation of char in hexadecimal format
class Test7 
{
	public static void main(String[] args) 
	{
		char ch1 = '\u0001'; 
		System.out.println(ch1);

		char ch2 = '\uffff';  
		System.out.println(ch2);

		char ch3 = '\u0041'; 
                System.out.println(ch3);  

		char ch4 = '\u0061';
		System.out.println(ch4); 
	}
}
----------------------------------------------------------------------
class Test8 
{
	public static void main(String[] args) 
	{
		char c1 = 'A';
		char c2 = 65;
		char c3 = '\u0041';

		System.out.println("c1 = "+c1+", c2 ="+c2+", c3 ="+c3);
	}
}
--------------------------------------------------------------------
class Test9 
{
	public static void main(String[] args) 
	{
		int x = 'A';
		int y = '\u0041';
		System.out.println("x = "+x+" y ="+y);
	}
}
----------------------------------------------------------------------
//Every escape sequence is char literal
class Test10 
{
	public static void main(String [] args) 
	{
		char ch ='\n';
		System.out.println(ch);
	}
}
----------------------------------------------------------------------
public class Test11  
{
	public static void main(String[] args) 
	{
		System.out.println(Character.MIN_VALUE); //white space
		System.out.println(Character.MAX_VALUE); //?
		System.out.println(Character.SIZE); //16 bits
	}
}
----------------------------------------------------------------------
//Java Unicodes
public class Test12 
{
	public static void main(String[] args) 
	{
		System.out.println(" Java Unicodes\n");

		for (int i = 31; i < 126; i++)
		{
			char ch = (char)i; // Convert unicode to character
			String str = i + "  "+ ch;
			System.out.print(str + "\t\t");
			if ((i % 5) == 0) // Set 5 numbers per row
			System.out.println( );
		}
	}
}
---------------------------------------------------------------------
11-Sep-23
---------
Boolean literal :
-----------------
1) boolean literal contains only one data type i.e boolean data type which accepts 1 bit of memory and it has two states i.e true and false.

2) It takes one bit of memory i.e true or false.
   
     Example:-
     boolean isValid = true;
     boolean isEmpty = false;

3) Unlike c and c++, In java it is not possible to assign integreal literal to boolean data type.

       boolean b = 0; (Invalid in java but valid in c and c++)
       boolean c = 1; (Invalid in java but valid in c and c++)

4) We can't assign String value to boolean data type.

    boolean d = "true"; //here true is String literal not boolean, not possible
    boolean e = "false";//here false is String literal not boolean, not possible

---------------------------------------------------------------------
public class Test1
{
    public static void main(String[] args)
    {
        boolean isValid = true;   
        boolean isEmpty = false;
		
        System.out.println(isValid);
        System.out.println(isEmpty);
     }
}
--------------------------------------------------------------------
public class Test2
{
    public static void main(String[] args)
    {
	boolean c = 0; //error
        boolean d = 1; //error
        System.out.println(c);
        System.out.println(d);       
    }
}
---------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		boolean x = "true";  //error
		boolean y = "false";  //error
		System.out.println(x);
                System.out.println(y); 
	}
}
---------------------------------------------------------------------
String Literal :-    
----------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is alpha-numeric collection of character.

How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};

---------------------------------------------------------------------
//Three Ways to create the String Object
public class StringTest1 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Ravi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);

	}
}
---------------------------------------------------------------------
//String is collection of alpha-numeric character
public class StringTest2 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123";  
		System.out.println(y);

		String z = "67.90"; 
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
----------------------------------------------------------------------
//IQ
class StringTest3
{
	public static void main(String args[])
	{		
		String s = 15+29+"Ravi"+40+40; 
		System.out.println(s);	
		
	}
}
----------------------------------------------------------------------
Punctuators :
---------------
It is  also called separators.

It is used to inform the compiler how things are grouped in the code.

()  {}   []   ;   ,   .   @   Å¯    
------------------------------------------------------------------------------------
Operators :
-------------
It is a symbol which describes that how a calculation will be performed on operands.

Types Of Operators :
------------------------
1) Arithmetic Operator (Binary Operator)

2) Unary Operators

3) Assignment Operator

4) Relational Operator

5) Logical Operators

6) Boolean Operators

7) Bitwise Operators

8) Ternary Operator

9) Member Operator

10) new Operator

11) instanceof Operator
---------------------------------------------------------------
Arithmetic Operator OR Binary Operator :
-----------------------------------------------
It is known as Arithmetic Operator OR Binary Operator because it works with minimum two operands.

Ex:-   +, - , *, / and % (Modula Or Modulus Operator)
----------------------------------------------------------------------
//Arithmetic Operator
// Addition operator to join two Strings working as String concatenation optr
public class Test1 
{
	public static void main(String[] args) 
	{
		String s1 = "Welcome to";
		String s2 = " Java ";
		String s3 = s1 + s2;
		System.out.println("String after concatenation :"+s3);
		
	}
}
----------------------------------------------------------------------
How to read the value from the user/keyboard (Accepting the data from client)
-------------------------------------------------------------------------------------------
In order to read the data from the client or keyboard, java software people has provided a predefined class called Scanner available in java.util package.

It is available from java 5v.

static variables of System class :
------------------------------------
System is a predefined class which contains 3 static variables.

System.out :- It is used to print normal message on the screen.

System.err :- It is used to print error message on the screen.

System.in :- It is used to take input from the user.(Attaching the keyboard with System resource)


How to create the Object for Scanner class :
--------------------------------------------------
Scanner sc = new Scanner(System.in);  //Taking the input from the user


Scanner class provides various methods :
-----------------------------------------------
String next() :- Used to read a single word.

String  nextLine() :- Used to read complete line or multiple Words.

byte nextByte() :- Used to read byte value

short nextShort() :- Used to read short value

int nextInt() :- Used to read integer value

float nextFloat() :- Used to read float value

double nextDouble() :- Used to read double value

boolean nextBoolean() :- Used to read boolean value.

char next().charAt(0) :- Used to read a character
--------------------------------------------------------------
//WAP to read your name from the keyboard
import java.util.*;
public class Test2
{
	public static void main(String [] args)
	{
      Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Name :");
	  String name = sc.nextLine();
	  System.out.println("Your Name is :"+name);
		
	}
}
----------------------------------------------------------------------
//BUFFER PROBLEM
import java.util.*;
public class ReadName 
{
	public static  void main(String[] args) 
	{
       Scanner sc = new Scanner(System.in);  

	   System.out.print("Enter your roll number :");
	   int roll = sc.nextInt();
	   
	   System.out.print("Enter your Name :");
	   String name = sc.nextLine();  //Buffer Problem
       name = sc.nextLine();

       System.out.println("Your roll number is :"+roll);
	   System.out.println("Your name is :"+name);

	}
}
---------------------------------------------------------------------
//Arithmetic Operator (+, -, *, / , %)
//Reverse of a 3 digit number
import java.util.*;
class Test3
{
	public static void main(String[] args) 
	{
		System.out.print("Enter a three digit number :");
		Scanner sc = new Scanner(System.in);
        
		int num =  sc.nextInt(); //num = 567

		int rem = num % 10;  //rem = 7
        System.out.print("The Reverse is :"+rem); //The reverse is :765

        num = num /10;    //num = 56
		rem = num % 10;  //rem = 6
        System.out.print(rem);

		num = num/10; //num = 5
		System.out.println(num);
	}
}

--------------------------------------------------------------
12-Sep-23
----------
Unary Operator :
--------------------
The operator which works upon single operand is called Unary Operator. Here in java we have 3 types of unary opertor.

1) Unary minus operator (-)       

2) Increment Operator (++)

3) Decrement Operator (--)
---------------------------------------------------------------
//*Unary Operators (Acts on only one operand)
//Unary minus Operator
class Test4 
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(-x); 
		System.out.println(-(-x));
	}
}
---------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test5 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++x;    //First increment then assignment
		System.out.println(x+":"+y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Post increment Operator
class Test6 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x++; //First assignment then increment
		System.out.println(x+":"+y);
	}
}
-------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test7 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++15;   //error
		System.out.println(y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test8
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++(++x); //error 
		System.out.println(y);
	}
}
--------------------------------------------------------------

//Unary Operators
//Unary post increment Operator
class Test9
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(++x + x++); 
		System.out.println(x);    
        System.out.println("..................");
 
		int y = 15;
		System.out.println(++y + ++y); 
		System.out.println(y);   
	}
}

--------------------------------------------------------------
Note :- Increment and decrement operator we can apply with any data type except boolean.
---------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test10
{
	public static void main(String[] args) 
	{
		char ch ='A';
		ch++;
		System.out.println(ch); 
	}
}
---------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test11
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		d++;
		System.out.println(d);
	}
		
}
 
---------------------------------------------------------------
//Unary Operators
//Unary Pre decrement Operator
class Test12 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = --x; //First decrement then assignment
		System.out.println(x+":"+y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Post decrement Operator
class Test13
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x--;
		System.out.println(x+":"+y); 
	}
}
---------------------------------------------------------------
Interview Question 
----------------------
Whenever we work with Arithmetic Operator or Unary minus operator, the minimum data type required is int, So after calculation of expression it is promoted to int type.

//IQ
class Test14
{
	public static void main(String args[])
	{
		byte i = 1;
		byte j = 1;
		byte k = i + j;  //error
		System.out.println(k);
	}
}
-------------------------------------------------------------
class Test15
{
	public static void main(String args[])
	{
		/*byte b = 6;
        b = b + 7;  //error      
		System.out.println(b); */

  byte b = 6;
  b += 7;//short hand operator  b += 7 is equal to (b = b + 7)
  System.out.println(b); 
	  
	}
}

Note :- In the above program it generates error while working with Arithmetic Operator but when we change the operator from 
Arithmetic to short hand operator then the expression result we can assign on byte data type.
--------------------------------------------------------------
class Test16
{
	 public static void main(String args[])
	{ 
		byte b = 1;
		byte b1 = -b; //error
             System.out.print(b1);  
	}
}
---------------------------------------------------------------
What is a local variable :
----------------------------
If a variable is declared inside a method  body(not as a method parameter) then it is called Local / Stack/ Temporary / Automatic variable.

Ex:-

public void input()
{
    int y = 12;
}

Here in the above example y is local variable.

Local variable we can't use outside of the function or method.

A local variable must be initialized before use otherwise we wiil get compilation error.

We can't use any access modifier on local variable except final.

Program
---------
public class Test17
{		 
	public static void main(String [] args)
	{
	  int x ; //must be initialized before use
	  System.out.println(x);

        public int y = 100;//only final is acceptable
        System.out.println(y);
	}	
}

Note :- In the above program we will get compilation error
-----------------------------------------------------------------------
//Program that shows local variable we cannot use outside of the method
(Diagram 12-SEP)
class StackMemory
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started..");
        m1();
		System.out.println("Main method ended..");
	}
	public static void m1()
	{
		System.out.println("m1 method started..");
        m2();
		System.out.println("m1 method ended.."+x);//error
	}
	public static void m2()
	{		
		int x = 100;
		System.out.println("I am m2 method!!!"+x);
	}	
}
Note :- In the above program we have declared x variable inside m2 method and we want to use x variable inside m1 method which is not
possible becoz x is a local variable.
--------------------------------------------------------------
//*Program on Assignment Operator
class Test18
{
	public static void main(String args[])
	 { 
        int x = 5, y = 3;  
        System.out.println("x = " + x);
        System.out.println("y = " + y); 
		
        x %= y;          //short hand operator  x = x % y
        System.out.println("x = " + x);     
		}
}
-----------------------------------------------------------------------
Description of System.out.println() with program
-------------------------------------------------
//BLC
class Welcome  //System
{
	static String msg = "Hyderabad";

	//static PrintStream out;
}

//ELC
class IQ 
{
	public static void main(String[] args) 
	{		
	  System.out.println(Welcome.msg.length()); //S.o.print()
	}

}
-----------------------------------------------------------------------
What is BLC class in java ?
---------------------------
BLC stands for Business Logic class. The class which does not contain main method and it is only meant for writing logic is called BLC class.

What is ELC class in java ?
---------------------------
ELC stands for Executable Logic class. The class which contains main method and it is meant executing of our program logic is known as ELC class.

--------------------------------------------------------------------
13-Sep-23
----------
Relational Operator :- 
------------------------
These operators are used to compare the values. The return type is boolean. We have total 6 Ralational Operators.

1) >   (Greater than)

2) <   (Less than)

3) >= (Greater than or equal to)

4) <= (Less than or equal to)

5) == (double equal to)

6) != (Not equal to )

//*Program on relational operator(6 Operators)
class Test19  
{
	public static void main(String args[])
	{
      int a = 10;
      int b = 20;
      System.out.println("a == b : " + (a == b) ); //false
      System.out.println("a != b : " + (a != b) );  //true
      System.out.println("a > b : " + (a > b) );   //false
      System.out.println("a < b : " + (a < b) );   //true
      System.out.println("b >= a : " + (b >= a) ); //true
      System.out.println("b <= a : " + (b <= a) ); //false
    }
}
--------------------------------------------------------------
If condition :
---------------
It is decision making statement. It is used to test a boolean expression. The expression must return boolean type.

//Program to check a number is 0 or +ve or -ve
import java.util.Scanner;
class Test20
{
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Please enter a Number :");

		int num = sc.nextInt();
		if(num == 0)
		System.out.println("It is zero");

		else if(num>0)
		System.out.println(num+" is positive");
		else
		System.out.println(num+" is negative");

		sc.close(); //To close Scanner resource
	}
}
--------------------------------------------------------------
/*program to calculate telephone bill
For 100 free call rental = 360
For 101 - 250, 1 Rs per call
For 251 - unlimited , 1.2 Rs per call
*/
import java.util.*;
class Test21
{
public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter current Reading :");
		int curr_read = sc.nextInt();

		System.out.print("Enter Previous Reading :");
		int prev_read = sc.nextInt();

		int nc = curr_read - prev_read;	
		System.out.println("Your Number of call for this month is :"+nc);		

		double bill = 0.0;
		if (nc <=100)
		{
			bill = 360;
		}
		else if(nc<=250)
		{
           bill = 360 + (nc-100)*1.0;
		}
        else if(nc >250)
		{
            bill = 360 + 150 + (nc-250)*1.2;
		}
         System.out.println("The bill is :"+bill);
	}
}
--------------------------------------------------------------
Nested if:
---------
If an 'if condition' is placed inside another if condition then it is called Nested if.
In nested if condition, we have one outer if and one inner if condition, the inner if condition will only execute when outer if condition returns true.

if(condition)  //Outer if condition
{
   if(condition) //inner if condition
   {
   }
   else //inner else
   {
   }
}
else //outer else
{
}
--------------------------------------------------------------
//Nested if
//big among three number
class Test22
{
public static void main(String args[])
	{
		int a =15;
		int b =12;
		int c =18;

		int big=0;   

		if(a>b)  //(Outer if condition)
		{			
			if(a>c)     //Nested If Block (inner if)        
				big=a;
			else
				big=c;
		}
		else    //already confirmed b is greater than a
		{
			if(b>c)   
				big=b;
			else
				big=c;
		}
	System.out.println("The big number is :"+big);
	}
}

Note :- In the above program to find out the biggest number among three number we need to take the help of nested if condition but the code becomes complex, to reduce the length of the code Logical Operator came into the picture.
--------------------------------------------------------------

Logical Operator :-
--------------------
It is used to combine or join the multiple conditions into a single statement. 

It is also known as short-Circuit logical operator.

In Java we have 3 logical Operators 

1) &&  (AND Logical Operator)

2) ||  (OR Logical Operator)

3) !   (NOT Logical Operator)

&&   :- All the conditions must be true. if the first expression is false it will not check right side expressions.

||    :- Among multiple conditions, at least one condition must be true. if the first expression is true it will not check right side expressions. 

!      :- It is an inverter, it makes true as a false and false as a true.

Note :- The && and || operator only works with boolean operand so the following code will not compile.

if(5 && 6)
{

}
---------------------------------------------------------------
//*Program on Logical Operator (AND, OR, Not Operator)
//Biggest number among 3 numbers

class Test23
{
public static void main(String args[])
	{
		java.util.Scanner sc = new java.util.Scanner(java.lang.System.in);
		System.out.print("Enter the value of a :");
		int a = sc.nextInt();
		System.out.print("Enter the value of b :");
		int b = sc.nextInt();
		System.out.print("Enter the value of c :");
		int c = sc.nextInt();
		
		int big =0;

		if(a>b && a>c)
			big = a;
		else if(b>a && b>c)
			big = b;
		else
			big = c;
		System.out.println("The big number is :"+big);
	}
}
---------------------------------------------------------------
//OR Operator (At least one condition must be true)
class Test24
{
public static void main(String args[])
	{		
		int a=10;
		int b=5;
		int c=20;
		System.out.println(a>b || a<c); //true
		System.out.println(b>c || a>c); //false
	}
}
-------------------------------------------------------------
// !Operator (not Operator works like an Inverter)
class Test25
{
   public static void main(String args[])
	{	
		System.out.println(!true);
	}
}
--------------------------------------------------------------
Boolean Operators :
-----------------------
Boolean Operators work with boolean values that is true and false. It is used to perform boolean logic upon two boolean expressions.

It is also known as non short circuit. There are two non short circuit logical operators.

&   boolean AND operator  (All  condions must be true but if first expression is false still it will check all right side expressions)

|    boolean OR operator    (At least one condition must be true but if the first condition is true still it will check all right side expression )
--------------------------------------------------------------
//* Boolean Operators
/*
& boolean AND operator 
| boolean OR operator

*/
//Works with boolean values

class Test26 
{
	public static void main(String[] args) 
	{
	      int z = 5;
		  if(++z > 5 || ++z > 6)   //Logical OR
		  {
			  z++;
		  }
		  System.out.println(z);  //7

          System.out.println("................");

		  z = 5;
		  if(++z > 5 | ++z > 6)   //Boolean OR
		  {
			  z++;
		  }
		  System.out.println(z); //8
    }
}
--------------------------------------------------------------
class Test27 
{
	public static void main(String[] args) 
	{
		int z = 5;
		if(++z > 6 & ++z> 6)
		{
			z++;			
		}
		System.out.println(z);
	}
}

---------------------------------------------------------------
Bitwise Operator :-
---------------------
In order to work with binary bits java software people has provided Bitwise operator. It also contains 3 operators

& (Bitwise AND) :- Returns true if both the inputs are true.

|  (Bitwise OR) :- Returns false if both the inputs are false
 
^ (Bitwise X-OR) :- Returns true if both the arguments are opposite to each other.

//Bitwise Operator
class Test28 
{
	public static void main(String[] args) 
	{
        System.out.println(true & true); //true
	System.out.println(false | true); //true
	System.out.println(true ^ true); //true
      

		System.out.println(6 & 7);  //6
		System.out.println(6 | 7);  //7
		System.out.println(6 ^ 7); //1
	}
}
---------------------------------------------------------------
//Bitwise Complement Operator
public class Test29
{
    public static void main(String args[]) 
	{
		//System.out.println(~ true); 
		System.out.println(~ -8);    
		
    }
}
---------------------------------------------------------------
14-Sep-23
---------
Ternary Operator OR Conditional Operator :
--------------------------------------------------
The ternary operator (? :) consists of three operands. It is used to evaluate boolean expressions. The operator decides which value will be assigned to the variable.It is used to reduced the size of if-else condition. 

//Ternary Operator OR Conditional Operator
public class Test30
{
    public static void main(String args[]) 
	{
		int a = 60;
		int b = 59;
		int max = 0;

		max=(a>b)?a:b;  //Type casting
		System.out.println("Max number is :"+max);

    }
}
--------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		 char a = 'A';
		 int i = 65 ;        
		 System.out.println(false ? i : a); //Type casting
		 System.out.println(true ? a : 65);
	}
}

---------------------------------------------------------------
Member access Operator Or Dot Operator :
--------------------------------------------------
It is used to access the member of the class so whenever we want to invoke the member of the class (fields + methods) then we should use dot(.) operator.

We can directly call any static method and static variable from the main method with the help of class name , here object is not required as shown in the program below.

If static variable or static method is present in the same class where main method is available then we can directly call but if the static variable and static method is available in another class then to call those static members of the class, class name is required.

class Welcome
{
	static int x = 100;

	public static void access()
	{
		System.out.println(x);
	}
}
public class Test 
{
	
	public static void main(String[] args) 
	{		
		//Outside of the class(In Welcome class)
		Welcome.access(); 
		Welcome.x = 10;
		System.out.println(Welcome.x);

		//Inside the class (Test class)
		show();
		System.out.println(y);
	}

	public static void show()
	{
		System.out.println(y);
	}

	static int y = 200;
}
--------------------------------------------------------------
//* new Operator

This Operator is used to create Object. If the member of the class (field + method) is static, object is not required. we can directly call with the help of class name.

On the other hand if the member of the class (variables + method) is not declared as static then it is called non-static member Or instance member , to call the non-static member object is required.

class Welcome
{
	int x = 100;  //non-static variable

	public void access() //non-static method
	{
		System.out.println(x);
	}
}
public class Test 
{	
	public static void main(String[] args) 
	{		
		Welcome w = new Welcome();
		System.out.println(w.x);
		w.access();
	}

	
}
-------------------------------------------------------------
instanceof operator :-

1)This Operator will return true/false

2) It is used to check a reference variable is holding the particular/corrosponding type of Object or not.   

3) It is also a keyword.

4) In between the object reference and class name , we must have some kind of relation (assignment relation) otherwise we will get compilation error.

//* instanceof operator 

public class Test 
{	
	public static void main(String[] args) 
	{		
		String str = "india";

		if(str instanceof String)
		{
			System.out.println("Holding the String object");
		}
		else
		{
			System.out.println("Not holding the String object");
		}

		Integer i = 45;
        if(i instanceof Number)
        {
			System.out.println("Holding the Integer object");
		}
		else
		{
			System.out.println("Not holding the Integer object");
		}

	}	
}
--------------------------------------------------------------
Types of variables in java 
---------------------------
-> Based on the data type we can define the variable into two 
   categories 

   a) Primitive type variables
   b) Non-primitive type(Reference type) variable

-> Example of primitive type variables
   int x = 15;

-> Example of Reference type variable 
   Customer c = new Customer();

   Here 'c' is reference variable 

   Note :- Any variable if we declare with the help of class then it is called reference variable.

-> Based on the declaration position we can define a varible
   into 4 categories 

   a) Instance variable OR Non-Static field
   b) Class variable OR Static field
   c) Parameter variable
   d) Local variable  [1 more flavour = block level variable]

Example :
---------
//Primitive Example

public class Test 
{	
	int a = 100; //Instance variable
	static int b = 200; //class variable

	public static void main(String[] args) 
	{	
	  Test t = new Test();
	  System.out.println(t.a);
      System.out.println(b);
	  access(300);
	}	

	public static void access(int c)  //here c is parameter variable
	{
        int d = 400;            // d is a local variable
		System.out.println(c);
		System.out.println(d);
	}
}

//Here a,b,c and d all are primitive variables.

---------------------------------------------------------------------
Reference variable Example :
----------------------------
import java.util.*;
class Student
{
	public void show()
	{
		System.out.println("Batch 24 student");
	}
}


public class Test 
{		
    Student st = new Student(); //Instance + Reference Variable

     //static + Reference Variable
     static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) 
	{	
	  Student s1 = new Student(); //s1 is local variable
	  getObjectData(s1);
	}	
    
	//here we are assigning s1 variable to st variable
        public static void getObjectData(Student st)  //st is parameter var
	{
       st.show();
	}	
}
----------------------------------------------------------------
What is Method Signature ?

-> Method Name along with method parameter is called Method 
   Signature.
---------------------------------------------------------------------
15-Sep-23
----------
Control Statements in java :
------------------------------
What is drawback of if condition :-
---------------------------------------
The major drawback with if condition is, it checks the condition again and again so It increases the burdon over CPU so we introduced switch-case statement to reduce the overhead of the CPU.

switch case :-
----------------
In switch case dpending upon the parameter the appropriate case would be executed otherwise default would be executed.

In this approch we need not to check each and every case, if the appropriate case is available then directly it would be executed.

break keyword is optional here but we can use as per requirement. It will move the control outside of the body of the switch.
----------------------------------------------------------------
import java.util.*;
public class SwitchDemo 
{
	public static void main(String[] args) 
	{	
		Scanner sc = new Scanner(System.in);
        System.out.print("Please Enter a Character :");
		//Method Chaining

		char colour = sc.next().toLowerCase().charAt(0);
		switch(colour)
		{
		case 'r' : System.out.println("Red") ; break;
		case 'g' : System.out.println("Green");break;
		case 'b' : System.out.println("Blue"); break;
		case 'w' : System.out.println("White"); break;
		default : System.out.println("No colour");
		}
		System.out.println("Completed") ;
	}
}
----------------------------------------------------------------------
import java.util.*;
public class SwitchDemo1
{
public static void main(String args[]) 
  {	
		System.out.println("\t\t**Main Menu**\n");	
		System.out.println("\t\t**100 Police**\n");
		System.out.println("\t\t**101 Fire**\n");
		System.out.println("\t\t**102 Ambulance**\n");
		System.out.println("\t\t**139 Railway**\n");
		System.out.println("\t\t**181 Women's Helpline**\n");		

		System.out.print("Enter your choice :");
		Scanner sc = new Scanner(System.in);
		int choice = sc.nextInt();	
		
		switch(choice)
		{
		case 100:
		System.out.println("Police Services");
		break;
		case 101:
		System.out.println("Fire Services");
		break;
		case 102:
		System.out.println("Ambulance Services");
		break;
		case 139:
		System.out.println("Railway Enquiry");
		break;
		case 181:
		System.out.println("Women's Helpline ");
		break;
		default:
		System.out.println("Your choice is wrong");		
		} 
    }
}
-----------------------------------------------------------------------
import java.util.*;
public class SwitchDemo2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the name of the season :");
		String season = sc.next().toLowerCase();

		switch(season)
		{
			case "summer" :
				 System.out.println("It is summer Season!!");
			 break;

			 case "rainy" :
				 System.out.println("It is Rainy Season!!");
			 break;
		}
	}
}
-----------------------------------------------------------------------

public class Test2 
{
	public static void main(String[] args) 
	{
		float val = 1;
		switch(val)      //Error, can't pass long, float and double
		{
			 case 1:
				 System.out.println("Hello");
			 break;
		} 
	}
}
-----------------------------------------------------------------------
Note :- In the switch statement we can't pass long, float and double value. Strings are allowed from JDK 1.7 version. enums are allowed from java 5 version.
----------------------------------------------------------------------
Loop in java :
---------------
A loop is nothing but repeatation of statement that means by using loop we can repeat a statement so many number of times based on specified condition.

In java we have 4 kinds of loop 

1) do-while loop
2) while loop 
3) for loop
4) for-each loop 

do-while loop :-
------------------
It will repeat the statment but in this loop first of all statement will be printed and then only the condition will verify so it is also called exit control loop.

do
{
   statement;
}
while();
----------------------------------------------------------------------
//program on do-while loop
public class Test3
{	
	public static void main(String [] args)
	{			 
       do
       {	
		   int x = 1; //error x is block level variable
		   System.out.print(x+"\t");
		   x++;
       }
       while (x<=10);
	}
}
----------------------------------------------------------------------
//Program on do-while loop to print 1-10
public class  Test4
{		
	public static void main(String[] args) 
	{    
		int x = 1; //Local variable
		do
		{	
			
			System.out.print(x+"\n");   
			x++;			
		}
		while (x<=10);
	}	
}
-----------------------------------------------------------------------
here basic drawback with do-while loop is, first of all it will print the value and then only it will check the condition.

To avoid this problem we introduced while loop 

while loop :- 
-------------
In while loop first of all we will verify the condition, if the condition is true then only the control will enter inside the body of the loop hence it is known as entry control loop.

while(condition)
{
   statement;
}
----------------------------------------------------------------------
//program on while loop
public class Test5 
{
	public static void main(String[] args) 
	{
		int x = -1;

		while(x>=-10)
		{
			System.out.println(x);
			x--;
		}
	}
}
-----------------------------------------------------------------------
//Program on for loop
public class Test6 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		}
		
	}
}
-----------------------------------------------------------------------
//Program to accept user input to initialize our loop
import java.util.Scanner;
public class Test7
{
	public static void main(String [] args)
	{
		System.out.print("Please enter a number from where you want to start the loop : ");
		Scanner sc = new Scanner(System.in);
		int i = sc.nextInt();
        do
        {
			System.out.print(i+"\t");      // \t for tab space	
			i = i + 1;
        }
        while (i<=100);
	}
}
----------------------------------------------------------------------
//WAP in java to print all even number from 1 -100

public class Test8
{
	public static void main(String [] args )
	{
	    for(int i=2; i<=100; i=i+2)
		{
			System.out.print(i+"\t");
		}
		
	}
}
----------------------------------------------------------------------
//WAP to print sum of first 100 natural number (1+2+3+4+.......100)
public class Test9 
{
	public static void main(String[] args) 
	{
		int sum = 0;    

		for(int i=1; i<=100; i++)
		{
			 sum = sum + i;		
		}	 

		System.out.println("The sum is :"+ sum);	
	}
}
----------------------------------------------------------------------
for-each loop :
----------------
It is introduced from JDK 1.5 onwards. 

It is also known as enhanced for loop.

It is used to retrieve the values from the collection.
-----------------------------------------------------------------
import java.util.Arrays;
public class Test10
{
	public static void main(String [] args)
	{
		int x[] = {89,56,34,12,9};

		Arrays.sort(x);

		for(int y : x)
			System.out.println(y);
	}

}
Note :
-------
1) In the above program each value of x is assigning to y variable.

2) x is an array variable but y is an ordinary variable

3) in java.util package there is a predefined class called Arrays which contains a static method sort(), by using this static method we can sort an array in ascending order. sort() method takes Object array as a parameter.
---------------------------------------------------------------
-----------------------------------------------------------------------
public class StringDemo 
{
	public static void main(String[] args) 
	{
		String []words = {"Java","is","programming","language"};

		for(String word : words)
		{
			System.out.println(word);
		}
	}
}
----------------------------------------------------------------------
//Nested loop
public class  Test11
{
	public static void main(String[] args) 
	{
		int weeks = 4;
		int days = 7;    

		for (int i = 1; i <= weeks; ++i) 
		{
		  System.out.println("Week: " + i);
		  for (int j = 1; j <= days; ++j) 
			 {
				  System.out.println("  Day: " + j);
			 }
		 }
	}
}


//break
class Test12 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{				
			if(i==5)
				break;
			System.out.println("i value is :"+i);
			
		}
	}
}
----------------------------------------------------------------
//continue (Will skip the current execution sequence)
class Test13 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{			
			if(i==5)
				continue;
			System.out.println("i value is :"+i);
		}
	}
}
----------------------------------------------------------------------
Working with static Method and return type :
----------------------------------------

/*
 * Finding the area of circle
 * if radius is 0 or negative then 
 * return -1 otherwise return area of circle
 * 
 */

This program contains 2 files :
-----------------------------
Circle.java(BLC)
----------------
package com.ravi.method_return;

//BLC
public class Circle 
{
  public static String getAreaOfCircle(int radius)
  {
	  if(radius <=0)
		  return "-1";
	  else
	  {
		  final double PI = 3.14;
		  double area = PI * radius * radius;
		  return ""+area;
	  }
  }
}


AreaOfCircle.java(ELC)
----------------------

package com.ravi.method_return;

import java.text.DecimalFormat;
import java.util.Scanner;


public class AreaOfCircle 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the radius of the Circle :");
		int rad = sc.nextInt();
		
		String areaOfCircle = Circle.getAreaOfCircle(rad);
		
		//converting String value to double
		double circleArea = Double.parseDouble(areaOfCircle);
		
		DecimalFormat df = new DecimalFormat("000.000");
		System.out.println("Area of circle is :"+df.format(circleArea));

	}
}

Note :- java.text package has provided a predefined class called
        DecimalFormat, by using this class we can provide the format for decimal values ("00.00")

	This class provides a predefined method format() which accepts double as a parameter as shown in the above program.
---------------------------------------------------------------------
16-Sep-23
---------
WAP in java to get the student details in String format.

2 files

Student.java
------------
package com.ravi.pack8;

//BLC
public class Student 
{
 public static String getStudentDetails(int roll, String name, double fees)
  {
	 //[Student name is : Ravi, roll is : 101, fees is :1200.90]
	 
	return "[Student name is : "+name+", roll is :"+roll+", fees is :"+fees +"]";                                                             
		
  }   
}



Test.java
---------
package com.ravi.pack8;

public class Test
{
	public static void main(String[] args)
	{
		String details = Student.getStudentDetails(101, "Ravi", 14000.90);
		System.out.println("Student Details are :"+details);
	}

}
--------------------------------------------------------------------
Program to print the table 
---------------------------
2 files 
-------
Table.java
-----------
package com.ravi.pack9;

//BLC
public class Table 
{
  public static void printTable(int num) //5
  {
	  for(int i=1; i<=10; i++)
	  {			
		 System.out.println(num + " X "+i+" = "+(num*i));             
	  }
  }
}

Test.java
---------

package com.ravi.pack9;

import java.util.Scanner;


//ELC
public class Test 
{
	public static void main(String[] args) 
	{		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the number whose table you want to print : ");
		
		Table.printTable(sc.nextInt());
		sc.close();
	}

}
---------------------------------------------------------------------
16-Sep-23
----------
Object Oriented Programming(OOPs) :
-----------------------------------
An Object is a physical entity which is existing in the real world.

Writing Java program on those Real World Object is known as Object Oriented Programming.

OOPs is a methdology to develop the programs using class and object. 

In object oriented programming we concentrate on Objects. 

Every Object contains properties(Data members or Variables) and behavior (Member function or Method).

Advantages of OOPs
----------------------
We have 3 advantages

1) Modularity (Dividing the bigger modules into smaller one)

2) Reusability (One module we can reuse so many times)

3) Flexibility (Easily add some new Features)

Features of OOPs
--------------------
We have 6 features 

1) Class 
2) Object
3) Abstraction
4) Encapsulation
5) Inheritance
6) Polymorphism
----------------------------------------------------------------
What is a class ?
------------------
A class is a model/blueprint/template/prototype for creating an object.

A class is userdefined data type which contains data members and member function.

Example :
---------
public classs Student
{
   Student Data (Student Variables or Student properties)
                            +
  Student behavior (Function / Method of the student)
}

A class is a logical representation of object.

*A class is a component which is used to define object properties and object behavior.

Object :
---------
An object is a physical entity.

Anything which is existing in the real world is called as object.

Example :
-----------
Mouse, Laptop, key, pen and so on.

An object has 3 characteristics :
-----------------------------------
1) Identification (Name of the Object)

2) Properties (Variables OR data members)

3) Behavior (Function Or Method.)

----------------------------------------------------------------------
First Object Oriented Program on Laptop 
---------------------------------------
package com.nit.oop;

public class Laptop 
{
	//Instance variable (Properties)
    String brand;
    double price;
    double screenSize;
    
    public void usedToWriteProgram()
    {
    	System.out.println("We are writing Java program using "+brand+"  laptop");
    }
    
    public String getLaptopInformation()
    {
    	return "[Laptop : Brand is :"+brand+", Laptop price is :"+price+", Laptop screen size is :"+screenSize+"]";
    }
    

	public static void main(String[] args) 
	{
              Laptop hp = new Laptop();
              //Initializing the properties
              hp.brand = "HP Pavilion";
              hp.price = 79000.78;
              hp.screenSize = 14.2;
              
              //calling the behavior
              hp.usedToWriteProgram();
              String information = hp.getLaptopInformation();
              System.out.println(information);
              
              System.out.println(".....................");
              
              Laptop lanavo = new Laptop();
              //Initializing the properties
              lanavo.brand = "Lanavo Idea Pad";
              lanavo.price = 60000.90;
              lanavo.screenSize = 15.4;
              
              //calling the behavior
              lanavo.usedToWriteProgram();
              String lanavoInformation = lanavo.getLaptopInformation();
              System.out.println(lanavoInformation);
              
	}

}
----------------------------------------------------------------------
Default constructor added by the compiler
--------------------------------------------------
In java whenever we write a class and If user does not write any type of constructor then automatically compiler will add default constructor to the class.

class Test
{
    //Here in this class we don't have constructor
}

javac Test.java    (At the time of compilation automatically compiler will add default constructor)

class Test
{
    Test() //default constructor added by the compiler
    {
    }
}
-------------------------------------------------------------------------
----------------------------------------------------------------
Why compiler adds default constructor to our class :
---------------------------------------------------
If the compiler does not add default constructor to our class then object creation is not possible in java. At the time of object creation by using new keyword we depend upon the constructor.

Every Java class contains at least one constructor, implicitly added by compiler OR explicitly written by user.

The main purpose of defualt constructor(added by the compiler) to initialize the instance variables of the class with some default values.
The default values are:
byte	- 0
short - 0
int	- 0
long	- 0
float	- 0.0
double - 0.0
char -    (Space)
boolean - false
String - null
Object - null
------------------------------------------------------------------------
//WAP in java to show that default constructor is used to initialize the instance variable.     

public class Student
{
  int sno;
  String sname;   

  public void talk()
  {
    System.out.println(sno);
    System.out.println(sname);
  }
  public static void main(String [] args)
  {
    Student ram = new Student();
            ram.talk();
  }
}
----------------------------------------------------------------------
How to provide our userdefined values for the instance variable :
-----------------------------------------------------------------
The default values provided by compiler are not useful for the user, hence user will take a separate method (acceptData()) to re-initialize the instance variable value so the user will get its own userdefined values.

The following program explains how to re-initialize our object property (instance variable) with method support.

Product.java
-------------
package com.nit.oop;

public class Product
{
  int prodId;
  String prodName;
  
  public void acceptData()
  {
	  prodId = 111;
	  prodName = "Nikon";
  }

  public void displayProductData()
  {
    System.out.println("Product Id is :"+prodId);
    System.out.println("Product Name is :"+prodName);
  }
  
  public static void main(String[] args) 
  {
	Product camera = new Product();
	        camera.displayProductData();
	        camera.acceptData();
	        camera.displayProductData();
  } 
}
---------------------------------------------------------------------
How to write BLC(Business Logic class ) and ELC (Executable Logic class)
---------------------------------------------------------------
In OOP if we write everything in a single class then it is not an object oriented approach even we are creating object, It enhances tight coupling (dependency is very high).

if we separate our classes with BLC and ELC approach then reusability of our BLC classes would be possible from same package and even from different package.

This package contains 3 files [All these classes are in the same package]
---------------------------------------------------------------------
Player.java
------------
package com.ravi.blc_elc;

//BLC
public class Player 
{
  int playerId;
  String playerName;
  double playerPrice;
  
  public void acceptPlayerData(int id, String name, double price)
  {
	  playerId = id;
	  playerName = name;
	  playerPrice = price;
  }
  
  public void playerInformation()
  {
	  System.out.println("Player Id is :"+playerId);
	  System.out.println("Player Name is :"+playerName);
	  System.out.println("Player Price is :"+playerPrice);
  }
  
}

Main.java
----------
package com.ravi.blc_elc;

//ELC
public class Main 
{
	public static void main(String[] args) 
	{
		Player rohit = new Player();
		rohit.acceptPlayerData(45, "Rohit Sharma", 12000.00);
		rohit.playerInformation();
		
	}

}


Virat.java
----------
package com.ravi.blc_elc;

public class Virat {

	public static void main(String[] args) 
	{
		Player virat = new Player();
		virat.acceptPlayerData(18, "Virat Kohli", 12500.00);
		virat.playerInformation();
	}

}



In order to re-use this Player class (BLC) class, we have another class called Dhoni available in another package

Dhoni.java
-----------
package com.ravi.re_use;

import com.ravi.blc_elc.Player;

public class Dhoni {

	public static void main(String[] args) 
	{
		Player dhoni = new Player();
		dhoni.acceptPlayerData(7, "MSD", 15890.90);
		dhoni.playerInformation();
	}

}

----------------------------------------------------------------------
instance variable :
--------------------
A non-static variable which is declared inside the class but outside of a method is called instance variable.

The life of an instance variable starts at the time of object creation.

[Instance variable is having strong association with object , we can't think about instance variable without object]

instance variables are always the part of the object.

As far as as its accessibility is concerned, instance variable we can use anywhere with object reference.


Parameter variable :
-----------------------
If a variable is declared inside the method parameter (not inside the method body) then the variables are called as parameter variables.

As far as its scope is concerned, parameters variables we can access within the same method body but not outside of the method.

----------------------------------------------------------------------
21-Sep-23
----------
this keyword (Diagram):
-----------------------
Whenever our instance variable name and parameter variable name both are same then at the time of variable initialization our runtime environment gets confused that which one is an instance variable which one is parameter variable.

To avoid this problem we should use this keyword. 

this keyword always refers to the current object and we know that instance variables are the part of object but not the parameter variable.

this keyword we can't use from a static context because it is a non- static member.

It is also known as variable shadowing.

2 files :
---------
Customer.java
-------------
package com.ravi.this_keyword;
//BLC
public class Customer 
{
   int custId;
   String custName; 
   
   //
   public void setCustomerData(int custId, String custName)
   {
	   this.custId = custId;
	   this.custName = custName;
	   
	   //this.getCustomerData();
   }
   
   public void getCustomerData()
   {
	 System.out.println("Customer Id is :"+custId);
	 System.out.println("Customer Name is :"+custName);
   }
   
}

CustomerDemo.java
-----------------

package com.ravi.this_keyword;
//ELC
public class CustomerDemo {

	public static void main(String[] args) 
	{
		new Customer().setCustomerData(111, "Raj");
		
	}

}
-----------------------------------------------------------------------
Role of instance variable while creating the Object :
-----------------------------------------------------
Whenever we create an object in java, a separate copy of all the instance variables will be created with each and every object as shown in the program below.

package com.ravi.this_keyword;

public class Test 
{
	int x = 10;

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		
		++t1.x;  --t2.x;
		
		System.out.println(t1.x);
		System.out.println(t2.x);
	}

}
-----------------------------------------------------------------------
Working with static variable :
----------------------------------
In static variable only one copy will be created and this single copy will be sharable by all the objects as shown in the program below.

package com.ravi.this_keyword;

public class Demo 
{
	static int x = 10;

	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		
		++d1.x;  ++d2.x;
		
		System.out.println(d1.x);
		System.out.println(d2.x);
	}

}

Note :

instance variable = MULTIPLE COPIES WITH MULTIPLE OBJECTS

static variable = SINGLE COPY FOR ALL THE OBJECTS
----------------------------------------------------------------------
22-Sep-23
---------
When we should declare a variable as an instance variable and when we should go with static variable?


Whenever the value of the variable is different with respect to objects then we should declare the variable as instance variable.

On the other hand if the value of the variable is common for all the objects then we should declare the variable as a  static variable, if we declare static variable as an instance variable then multiple copies will be created for holding same value, so there is a westage of memory.

Note :- static variable will save the memory so the overall execution of the program will become faster.

2 files :-
---------
Student.java
------------
package com.ravi.instance_static;
//BLC
public class Student 
{
  int rollNumber;
  String studentName;
  String studentAddress;
  static String collegeName = "NIT";
  static String courseName = "Java";
  
  public void setStudentData(int rollNumber, String studentName, String studentAddress)
  {
	  this.rollNumber= rollNumber;
	  this.studentName = studentName;
	  this.studentAddress = studentAddress;
  }
  
  public String getStudentData()
  {		
		  return "Student [Roll is :"+this.rollNumber+", Name is :"+this.
		  studentName+", Address is :"+this.studentAddress+", College Name is :"
		  +Student.collegeName+", Course Name is :"+Student.courseName+"]";
		 
  }
  
  
}

StudentDemo.java
-----------------
package com.ravi.instance_static;

import java.util.Scanner;

//ELC
public class StudentDemo 
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Student Roll Number :");
		int roll = sc.nextInt();
		
		System.out.print("Enter Student Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		
		System.out.print("Enter Student Address :");
		String addr = sc.nextLine();
		
		Student raj = new Student();
		raj.setStudentData(roll, name, addr);
		System.out.println(raj.getStudentData());
		sc.close();
	}
}
------------------------------------------------------------------------
How to print object properties value (instance variable value) :
----------------------------------------------------------------------
If we want to print object properties value then we need to override a method called toString() available in java.lang.Object class.

Whenever we override this toString() method in our class then we need not to write any kind of display() method to display our data(instance variable).

In order to call toString() method we need to print the object reference(name of the object) using System.out.println()

2 files :-

Manager.java
------------
package com.ravi.to_string;
//BLC
public class Manager 
{
   double managerSalary;
   String managerName;
   
   public void setManagerData(double sal, String name)
   {
	 this.managerSalary = sal;
	 this.managerName = name;
   }
   //Generate toString Automatically to print object properties

    @Override
	public String toString()
    {
	return "Manager [managerSalary=" + managerSalary + ", managerName=" + managerName + "]";
	}
   
}

ManagerDemo.java
----------------
package com.ravi.to_string;

//ELC
public class ManagerDemo 
{
	public static void main(String[] args) 
	{
		Manager m1 = new Manager();
		m1.setManagerData(40000.00, "VK");
		System.out.println(m1); //passing object reference inside the s.o.p 
		                        //statement which will automatically call
		                        //toString() method
	}

}
-----------------------------------------------------------------------
How to generate toString() method :
-----------------------------------
Right click on the program -> source -> generate toString()
-> select all -> generate
-----------------------------------------------------------------------
Lab Program :
-------------
2 files 
--------
Manager.java
-------------
package com.ravi.lab_prog;

public class Manager
{
	 int managerId;
	 String managerName;
	 double managerSalary;
	 char managerGrade;
  
	 public void setManagerData(int id, String name,double salary)
	 {
		managerId = id;
		managerName = name;
		managerSalary = salary;
	 }
	 
	 public void calculateManagerGrade()
	 {
		 if(this.managerSalary >=100000)
			 managerGrade  ='A';
		 
		 else if(this.managerSalary >=90000)
			 managerGrade  ='B';
		 
		 else if (this.managerSalary >=70000)
		 managerGrade  ='C';
		 
		 else
			 managerGrade = 'D';
	 }

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + ", managerSalary=" + managerSalary
				+ ", managerGrade=" + managerGrade + "]";
	}
	 
	 
  
}

ManagerDemo.java
----------------
package com.ravi.lab_prog;

public class ManagerDemo {

	public static void main(String[] args)
	{
       Manager m1 = new Manager();
       m1.setManagerData(1, "Raj", 95000);
       m1.calculateManagerGrade();
       System.out.println(m1);

	}
}
------------------------------------------------------------------------23-Sep-23
---------
Data hiding :
---------------
Data hiding means our data (variables) must be hidden from outer world that means no one can access our data directly from outside of the class.

To achieve data hiding concept we should declare our class properties or data members or variables with private access modifier.

We should not provide access of data directly but we can access our data via methods. Once we are accessing our data through methods then we can PERFORM VALIDATION ON DATA WHICH ARE COMING FROM OUTER WORLD.

Note :- Data members must be declared as private where as member functions (Method) must be declared as public.

2 Files :
---------
Customer.java
--------------
package com.ravi.data_hiding;

public class Customer 
{
   private double balance = 1000; //data hiding
   
   public void deposit(int amount)
   {
	   //Validate the amount
       if(amount<=0)
       {
    	   System.out.println("Amount can't be deposited!!!");
       }
       else
       {
    	   balance = balance + amount;
    	   System.out.println("Balance after deposit is :"+balance);
       }
   }
   
   public void withdraw(int amount)
   {
	  balance = balance - amount;
	  System.out.println("Balance after withdraw is :"+balance);	  
   }
}

BankingApplication.java
------------------------
package com.ravi.data_hiding;

public class BankingApplication 
{
	public static void main(String[] args) 
	{
		Customer raj = new Customer();
		raj.deposit(3000);
		raj.withdraw(1000);
	}
}
-----------------------------------------------------------------------
Abstraction (Hiding the complxcity):
------------------------------------
Abstraction :
--------------
Showing the essential details without showing the background details (non-essential) is called Abstraction.

In real world a user always interacts with the functionality of the product but not the data or internal details so for a user method/function is essential details where as data is non-essential details.

So being a developer we should always hide the data from the user(by declaring them private) where as on the other hand we should always decalre member function/Method as public so a user can easily interact with the product.

Example :
-----------
class Fan
{
   private int coil;
   private int wings;

   public void switchOn()
   {
   }

   public void switchOff()
   {
   }
}

Note :- Here User will interact with the functionality of the fan i.e switchOn and switchOff but will not interact with data(coil, wings) directly.

Note :- In java we can achieve abstarction by using abstract class and interface concept.

abstract class provide partial abstraction(0-100%) where as interface provides 100% abstraction.
-----------------------------------------------------------------------
Encapsulation :- 
----------------
Binding  the data member with its associated function/method in a single unit is called encapsulation.

In other words we can say "Grouping the related things together is called Encapsulation".

In encapsulation data must be tightly coupled with associated function.

It provides us security because we can't access the data directly, data must be accessible via methods.

We can achieve encapsulation in our program by using following

a) Declare all the data members as private (Tightly encapsulated class)
b) Define getters and setters for each instance variable to perform read and write operation.

Note :
-----
If we declare all the instance variables with private access modifier then it is called tightly encapsulated class

On the other hand if some variables are declared with private access modifier and other variables are not declared with private access modifier then it is called loosly encapsulated class


2 Files :
---------
Student.java
-------------
package com.ravi.encapsulation;

public class Student 
{
   private int rollNumber;

	public int getRollNumber() //getter
	{
		return rollNumber;
	}

	public void setRollNumber(int rollNumber) //setter
	{
		this.rollNumber = rollNumber;
	}  
   
}

StudentDemo.java
----------------

package com.ravi.encapsulation;

public class StudentDemo {

	public static void main(String[] args) 
	{
	  Student s1 = new Student();
	  s1.setRollNumber(111);
	  System.out.println("My roll Number is :"+s1.getRollNumber());

	}

}
------------------------------------------------------------------------
25-Sep-23
---------
Constructor :
--------------
Why we write a constructor in a program 
OR 
what is the benefit of writing constructor in our program :-
-----------------------------------------------------------
If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation.

(As shown in the diagram 25-09-23)
----------------------------------------------------------------
26-Sep-23
---------
Defination of constructor :
-----------------------------
It is used to construct the object that is why it is called Constructor.

If the name of the class and name of the method both are same then it is called constructor or in other words constructor is a special method whose name is same as class name.

*The main purpose of constructor is to initialize the instance variable of the object.

Every java class has a constructor either explicitly written by the user or implicitly added by the compiler.

A constructor never containing any return type including void also, if we try to put the return type then it will become normal method.

A constructor is automatically called and executed at the time of creating object.

A constructor is called and executed once per object that means if we create an object then automatically the constructor will be called and executed, again if we create another object for second time then again the constructor will be called and executed.

In java we have 3 types of constructors :
----------------------------------------------
1) Default constructor

2) No Argument constructor OR Parameterless constructor

3) Parameterized Constructor

----------------------------------------------------------------------
 2) No argument constructor :- 
    ----------------------------------
     The constructor written by the user in the class without any parameter then it is called No argument constructor or parameter less constructor or zero argument constructor.

     By using no argument constructor all the objects will be initialized with same values so it is not recommended approach because we will not be able to customized each individual object with different value, to avoid this parameterized constructor came into picture.
     [Diagram is available 26-SEp-23]

     Ex:-
     public class Test
     {
         int x, y;

	 public Test() //No argument constructor, written by the user
	 {
	    x = 100;
	    y = 200;
	 }
     }
-----------------------------------------------------------------------
2 files :
---------

Person.java
------------

package com.ravi.no_arg_cons;

public class Person 
{
  private Integer personId;
  private String personName;
  private Double personBill;
  
  public Person() //No-Argument Constructor
  {
	  personId = 111;
	  personName = "Raj";
	  personBill = 12890.67;
  }

	@Override
	public String toString() 
	{
		return "Person [personId=" + personId + ", personName=" + personName + ", personBill=" + personBill + "]";
	} 
  
}


NoArgumentConstructor.java
--------------------------
package com.ravi.no_arg_cons;

public class NoArgumentConstructor 
{
	public static void main(String[] args) 
	{
		Person raj = new Person();
		System.out.println(raj);
		
		System.out.println("............");
		
		Person ram = new Person();
		System.out.println(ram);

	}

}

Note :- In the above program we are creating two different objects but 
        they are containing same data.
----------------------------------------------------------------------
3) Parameterized Constructor :
------------------------------




----------------------------------------------------------------------

3) Parameterized Constructor :
------------------------------
If one or more argument is passed to the constructor then it is called parameterized constructor.

If we want to initialize our objects with different values(unlike no argument constructor) then we should choose parameterized constructor.

public class Test
{
     private int x,y;

     public Test(int x, int y) //parameterized constructor.
      {
          this.x = x;
	  this.y = y;
      }
}

Test t1 = new Test(10,20);
Test t2 = new Test(100,200);
----------------------------------------------------------------------

2 files :
---------
Dog.java
--------
package com.ravi.parameterized_constructor;

public class Dog 
{
	private String dogName;
	private int dogAge;
	private double dogHeight;
	
	public Dog(String dogName, int dogAge, double dogHeight) 
	{
		super();
		this.dogName = dogName;
		this.dogAge = dogAge;
		this.dogHeight = dogHeight;
	}
	
	//Modifying the Dog name
	public void setDogName(String dogName) {
		this.dogName = dogName;
	}



	@Override
	public String toString() {
		return "Dog [dogName=" + dogName + ", dogAge=" + dogAge + ", dogHeight=" + dogHeight + "]";
	}
}


ParameterizedConstructor.java
------------------------------
package com.ravi.parameterized_constructor;

public class ParameterizedConstructor {

	public static void main(String[] args) 
	{
		Dog d1 = new Dog("Tiger", 4, 3.2);
		d1.setDogName("Lion");
		System.out.println(d1);
		
		System.out.println("................");
		
		Dog d2 = new Dog("Tommy",6,3.0);
		System.out.println(d2);

	}

}
-----------------------------------------------------------------------
How many ways to initialize our object properties 
--------------------------------------------------------
There are 5 ways to initialize our object properties (instance variables)

1) AT THE TIME OF DECLARTION

    class Exapmle
    {
        int x = 10;
	int y = 20;
   }

   Exapmle e1 = new Exapmle();
   Exapmle e2 = new Exapmle();
   Exapmle e3 = new Exapmle();

   
   It is not a recommended approach because if we create multiple objects then all the objects will contain same value.


 2) BY USING OBJECT REFERENCE

     class Example
     {
         int x;
	 int y;

	 Example e1 = new Example(); e1.x=10;  e1.y=20;
	 Example e2 = new Example(); e2.x=30;  e2.y=40;
	 Example e3 = new Example(); e3.x=50;  e3.y=60;
     }

       It is also not a recommended approach because here the length of the code will increase as well as the understanability of the code will decrease.


 3) BY USING METHODS

	class Example
	{
            int x;
	    int y;
	    public void input()
	    {
                   x = 100;
		   y = 200;
	    }
	  }

	  Note :- All the objects will initialize with same value

        class Example   
	{
            int x;
	    int y;
	    public void input(int x, int y)
	    {
                   this.x = x;
		   this.y = y;
	    }
	  }

           All the objects will initialize with different values

	   It this approach variable initialization and variable re-initialization both will be done in different places so to avoid this constructors are introduced.


	   4) BY USING CONSTRUCTORS(PARAMETERIZED CONSTRUCTOR)

	       This is the best approach to initialize our instance variable of the object in this approach variable initialization and variable re-initialization both will be done in a single line.

	    5) BY USING SETTER METHOD

	    If we want to modify our instance variable then setter is best approach.

SO CONCLUSIUON IS 
  a) Constructors are used to initialize the object properties
  b) Setters are used to modify the object properties
  c) Methods are used for calculation or printing the data
  d) To print object properties we have toString() method
  e) If Properties are private then to read properties value in
     another class we should use getter.
---------------------------------------------------------------------
27-Sep-23
---------
HAS-A Relation :
----------------
Whenever we are using class variable (ref. variable) as a property to another class then it is called HAS-A relation.

Program on HAS-A relation :
---------------------------
3 Files :
---------
College.java(BLC)
-----------------
package com.ravi.has_a_reln;

public class College 
{
	private String collegeName;
	private String collegeAddress;
	
    public College(String collegeName, String collegeAddress) 
	{
		super();
		this.collegeName = collegeName;
		this.collegeAddress = collegeAddress;
	}

	@Override
	public String toString() 
	{
		return "College [collegeName=" + collegeName + ", collegeAddress=" + collegeAddress + "]";
	}	

}


Student.java(BLC)
------------------
package com.ravi.has_a_reln;

public class Student 
{
	private int studentId;
	private String studentName;
	private String studentAddress;
	
	private College clg; //HAS-A Relation

	public Student(int studentId, String studentName, String studentAddress, College clg) //clg = c1
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
		this.clg = clg;		 
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress=" + studentAddress
				+ ", clg=" + clg + "]";
	}
	
	
	

}


HasARelationProgram.java
-------------------------
package com.ravi.has_a_reln;

public class HasARelationProgram {

	public static void main(String[] args)
	{
		College c1 = new College("NIT", "Hyderabad");
		
		Student s1 = new Student(1, "A", "AMPT", c1);
		Student s2 = new Student(2, "B", "SR NAGAR", c1);
		System.out.println(s1);
		System.out.println(s2);

	}

}

---------------------------------------------------------------------
Another program on HAS-A Relation :
------------------------------------
Program on HAS-A relation :
---------------------------
3 Files :
---------
Order.java(BLC)
-----------------
package com.nit.has_a_reln;

public class Order 
{
   private int OrderId;
   private String itemName;
   private double itemPrice;
   private int itemQuantity;
   
   
	public Order(int orderId, String itemName, double itemPrice, int itemQuantity) {
		super();
		OrderId = orderId;
		this.itemName = itemName;
		this.itemPrice = itemPrice;
		this.itemQuantity = itemQuantity;
	}


	@Override
	public String toString() {
		return "Order [OrderId=" + OrderId + ", itemName=" + itemName + ", itemPrice=" + itemPrice + ", itemQuantity="
				+ itemQuantity + "]";
	}  
   
}

Customer.java(BLC)
-----------------
package com.nit.has_a_reln;

public class Customer 
{
  private int custId;
  private String customerName;
  private String shippingAddress;
  private double totalBill;
  private long mobileNumber;
  private Order order; //HAS - A Relation
  
  
	public Customer(int custId, String customerName, String shippingAddress, double totalBill, long mobileNumber,
			Order order) //order = o1
	{
		super();
		this.custId = custId;
		this.customerName = customerName;
		this.shippingAddress = shippingAddress;
		this.totalBill = totalBill;
		this.mobileNumber = mobileNumber;
		this.order = order;
	}


	@Override
	public String toString() {
		return "Customer [custId=" + custId + ", customerName=" + customerName + ", shippingAddress=" + shippingAddress
				+ ", totalBill=" + totalBill + ", mobileNumber=" + mobileNumber + ", order=" + order + "]";
	}
   
  
  
}

Zomato.java(ELC)
----------------
package com.nit.has_a_reln;

public class Zomato {

	public static void main(String[] args) 
	{
		//System.out.println(new Customer(1, "ABC", "b-61, AMPT, HYD", 280.0, 9812345678L, new Order(123,"Butter Chicken",280.00,1)));
        Order o1 = new Order(123,"Butter Chicken", 560.00, 2);
        Customer c1 = new Customer(1, "ABC", "Ameerpet", 560.00, 9812345678L, o1);
        System.out.println(c1);
	}
}
--------------------------------------------------------------------
Passing an object reference to the constructor (Copy Constructor) :
-------------------------------------------------------------------
How to pass an object reference to the constructor :
----------------------------------------------------
The main purpose of passing an object reference to the constructor is to copy the content of one object to another 
object.

3 files :
---------
Employee.java(BLC)
------------------
package com.ravi.passing_object_ref;

public class Employee 
{
   private int employeeNumber;
   private String employeeName;
   
	public Employee(int employeeNumber, String employeeName)
	{
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
	}

	@Override
	public String toString() {
		return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + "]";
	}

	public int getEmployeeNumber() {
		return employeeNumber;
	}

	public String getEmployeeName() {
		return employeeName;
	}  
   
}


Manager.java(BLC)
-----------------
package com.ravi.passing_object_ref;

public class Manager 
{
	private int managerId;
	private String managerName;
	
	public Manager(Employee emp)  //emp = e1
	{
	   managerId = emp.getEmployeeNumber();
	   managerName = emp.getEmployeeName();
	}

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}

}


PassingObjectRefToConstructor.java(ELC)
---------------------------------------
package com.ravi.passing_object_ref;

public class PassingObjectRefToConstructor 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111, "Raj");
		
		Manager m1 = new Manager(e1);
		System.out.println(m1);

	}
}
---------------------------------------------------------------------
28-Sep-23
---------
Program on Passing Object Reference to the Constructor :
--------------------------------------------------------
package com.ravi.passing_object_ref_to_cons;

public class Player 
{
   private String name1, name2;

	public Player(String name1, String name2) 
	{
		super();
		this.name1 = name1;
		this.name2 = name2;
	}
  
    public Player(Player p)  // p = p1
    {
    	this.name1 = p.name2;
    	this.name2 = p.name1;
    }

	@Override
	public String toString() {
		return "Player [name1=" + name1 + ", name2=" + name2 + "]";
	}
}


package com.ravi.passing_object_ref_to_cons;

public class ObjetReferenceToConstructor 
{
	public static void main(String[] args) 
	{
		Player p1 = new Player("Rohit", "Virat");
		System.out.println(p1);
		
		System.out.println("..............");
		Player p2 = new Player(p1);
		System.out.println(p2);
	}
}
---------------------------------------------------------------------
Copy Constructor Program :
--------------------------
Milk.java(BLC)
--------------
package com.ravi.copy_constr;

public class Milk 
{
  private double milkPrice;

	public double getMilkPrice() 
	{
		return milkPrice;
	}
	
	public void setMilkPrice(double milkPrice) 
	{
		this.milkPrice = milkPrice;
	}

	@Override
	public String toString() {
		return "Milk [milkPrice=" + milkPrice + "]";
	}
	  
  
  
}

Baby.java(BLC)
---------------
package com.ravi.copy_constr;

public class Baby 
{
  private String babyName;
  private int babyAge;
  private Milk milk;
  private String milkType;
  
	public Baby(String babyName, int babyAge, Milk milk) //milk = m
	{
		super();
		this.babyName = babyName;
		this.babyAge = babyAge;
		this.milk = milk;
		
		if(milk.getMilkPrice() > 60)
		{
			milkType = "Full Cream";
		}
		else
		{
			milkType = "Tonned Milk";
		}
	}

	@Override
	public String toString() {
		return "Baby [babyName=" + babyName + ", babyAge=" + babyAge + ", milk=" + milk + ", milkType=" + milkType
				+ "]";
	}
  
  
  
}



CopyConstructor.java(ELC)
-------------------------
package com.ravi.copy_constr;

public class CopyConstructor {

	public static void main(String[] args) 
	{
		Milk m = new Milk();
		m.setMilkPrice(55);
		
		Baby baby = new Baby("Aardhya", 2, m);
		System.out.println(baby);

	}

}
--------------------------------------------------------------------
Method return type as a class :
--------------------------------
We can take return type of the method as a class. As a return type of method we can take all primitive data type (byte, Short, int and so on) class name, interface name;

public class Test
{
   public Test m1()
    {
      
       return 5;   
    }
}
---------------------------------------------------------------------
The following program explains how to tale return type of a method as class

2 files :
---------
Employee.java
--------------
package com.ravi.class_as_a_return_type;

import java.util.Date;
import java.util.Scanner;

public class Employee 
{
  private int employeeId;
  private String employeeName;
  private double employeeSalary;
  private Date hireDate; //HAS-A Relation
  
  
  
  public Employee(int employeeId, String employeeName, double employeeSalary, Date hireDate) {
	super();
	this.employeeId = employeeId;
	this.employeeName = employeeName;
	this.employeeSalary = employeeSalary;
	this.hireDate = hireDate;
    }


  public static Employee getEmployeeObject()
  {
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter Employee Id :");
	  int id = sc.nextInt();
	  
	  System.out.print("Enter Employee Name :");
	  String name = sc.nextLine();
	  name = sc.nextLine();
	  
	  System.out.print("Enter Employee Salary :");
	  double salary = sc.nextDouble();
	  
	  Date d = new Date();  
	  
	  Employee e1 = new Employee(id, name, salary, d);
	  
	  return e1;
  }


@Override
public String toString() {
	return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
			+ employeeSalary + ", hireDate=" + hireDate + "]";
}
  
  
  
}

ClassAsAReturnValue.java
--------------------------
package com.ravi.class_as_a_return_type;

import java.util.Scanner;

public class ClassAsAReturnValue {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("How many objects you want ? ");
		int numberOfObjects = sc.nextInt();
		
	    for(int i=1; i<= numberOfObjects; i++)
	    {		
		  Employee emp = Employee.getEmployeeObject();
		  System.out.println(emp);
	    }

	}
}
------------------------------------------------------------------------
29-Sep-23
---------
LAB Program :
---------------
A BLC class called Customer is given to you. 
The task is to find the Applicable Credit card Type and create CardType object based on the Credit Points of a customer.

Define the following for the class.

Attributes : 
	customerName : String,private
	creditPoints: int, private

Constructor :
	parameterizedConstructor: for both cusotmerName & creditPoints in that order.

Methods :
	Name of the method : getCreditPoints
	Return Type : int
	Modifier   : public 
	Task : This method must return creditPoints
	
	Name of the method : toString, Override it, 
	Return type : String 
	Task :  return only customerName from this.

Create another class called CardType. Define the following for the class

Attributes :
	customer : Customer, private
	cardType : String, private
Constructor :
	parameterizedConstructor: for customer and cardType attributes in that order

Methods :
	Name of the method : toString  Override this.  
	Return type : String
	Modifier : public
	Task :  Return the string in the following format.
		The Customer 'Rajeev' Is Eligible For 'Gold' Card.


Create One more class by name CardsOnOffer and define the following for the class.

Method : 
	Name Of the method : getOfferedCard 
	Return type : CardType
	Modifiers: public,static
	Arguments: Customer object
	
	Task : 	Create and return a CardType object after logically finding cardType from creditPoints as per the below rules.
		creditPoints	    cardType
		100  - 500	-   Silver
		501  - 1000	-   Gold
		1000 >		-   Platinum
		< 100		-   EMI
		
Create  an ELC class CreditCard which contains Main method to test the working of the above.

Program :
---------
4 files are there :
--------------------
Customer.java(BLC)
------------------
package com.ravi.lab_credit_card_program;

public class Customer 
{
   private String customerName;
   private int creditPoints;
   
	public Customer(String customerName, int creditPoints) 
	{
		super();
		this.customerName = customerName;
		this.creditPoints = creditPoints;
	}
	 
	public int getCreditPoints()
	{
		return this.creditPoints;
	}

	@Override
	public String toString() 
	{
		return ""+this.customerName;
	}
   
}


CardType.java(BLC)
-------------------
package com.ravi.lab_credit_card_program;

public class CardType 
{
   private Customer customer;
   private String cardType;
   
	public CardType(Customer customer, String cardType) 
	{
		super();
		this.customer = customer;
		this.cardType = cardType;
	}

	@Override
	public String toString() 
	{				
		return "The Customer '"+this.customer+"' Is Eligible For '"+this.cardType+"' Card";
	}   
  
}


CardsOnOffer.java(BLC)
-----------------------
package com.ravi.lab_credit_card_program;

public class CardsOnOffer 
{
  public static CardType getOfferedCard(Customer obj)
  {
      int creditPoint = obj.getCreditPoints();
	  
	  if(creditPoint >= 100 && creditPoint <=500)
	  {
		 return new CardType(obj, "Silver");
	  }
	  else if(creditPoint > 500 && creditPoint <=1000)
	  {
		  return new CardType(obj, "Gold");
	  }
	  else if(creditPoint > 1000)
	  {
		  return new CardType(obj, "Platinum");
	  }
	  else
	  {
		  return new CardType(obj, "EMI");
	  }
  }
}


CreditCard.java(ELC)
---------------------
package com.ravi.lab_credit_card_program;

import java.util.Scanner;

public class CreditCard {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter Customer Name :");
		String name = sc.nextLine();
		
		System.out.print("Enter Credit Point of Customer :");
		int creditPoint = sc.nextInt();
		
		Customer c1 = new Customer(name, creditPoint);
		
		CardType offeredCard = CardsOnOffer.getOfferedCard(c1);
		
		System.out.println(offeredCard);
		
	}
}
-------------------------------------------------------------------------
Lab Program :
-------------
The payroll system of an organization involves calculating the gross salary of each type of employee and the tax applicable to each. 
Create the following entity classes as described below.

Class Employee
Fields: id: int, name : String, basicSalary : double, HRAPer : double, DAPer : double

Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer

Class Manager
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double, projectAllowance: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer + projectAllowance

Class Trainer
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double, batchCount: int, perkPerBatch: double

Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch)

Class Sourcing
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double, enrollmentTarget: int, enrollmentReached: int, perkPerEnrollment: double
Public Method: calculateGrossSalary() - returns a double

Calculate the gross salary as : basicSalary +HRAPer +DAPer +((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment)


Class TaxUtil
Fields: None
Public Methods:
calculateTax(Employee) - returns a double
calculateTax(Manager) - returns a double
calculateTax(Trainer) - returns a double
calculateTax(Sourcing) - returns a double

Tax Calculation Logic: If gross salary is greater than 30000 tax is 20% else, tax is 5%

Note : Attributes/Fields must be non-Private for the above classes.

A ClassObject class is given to you with the main Method. Use this class to test your solution.
---------------------------------------------------------------
This Lab program contains 6 files :
------------------------------------
Employee.java
-------------
package com.ravi.lab_prog_tax_util;

public class Employee 
{
  int id;
  String name;
  double basicSalary;
  double HRAPer;
  double DAPer;
  
  
  
  public Employee(int id, String name, double basicSalary, double hRAPer, double dAPer) {
	super();
	this.id = id;
	this.name = name;
	this.basicSalary = basicSalary;
	HRAPer = hRAPer;
	DAPer = dAPer;
}



public double calculateGrossSalary()
  {
	  double grossSalary = this.basicSalary + this.HRAPer + this.DAPer;
	  return grossSalary;
  }
}

Manager.java
-------------
package com.ravi.lab_prog_tax_util;

public class Manager 
{
	int id;
	String name;
	double basicSalary;
	double HRAPer;
	double DAPer;
	double projectAllowance;
	
	
	
	public Manager(int id, String name, double basicSalary, double hRAPer, double dAPer, double projectAllowance) {
		super();
		this.id = id;
		this.name = name;
		this.basicSalary = basicSalary;
		HRAPer = hRAPer;
		DAPer = dAPer;
		this.projectAllowance = projectAllowance;
	}



	public double calculateGrossSalary()
	  {
		  double grossSalary = this.basicSalary + this.HRAPer + this.DAPer+this.projectAllowance;
		  return grossSalary;
	  }
}  


Trainer.java
-------------
package com.ravi.lab_prog_tax_util;

public class Trainer 
{
	 int id;
	  String name;
	  double basicSalary;
	  double HRAPer;
	  double DAPer;
      int batchCount;
      double perkPerBatch;
      
      
      
      public Trainer(int id, String name, double basicSalary, double hRAPer, double dAPer, int batchCount,
			double perkPerBatch) {
		super();
		this.id = id;
		this.name = name;
		this.basicSalary = basicSalary;
		HRAPer = hRAPer;
		DAPer = dAPer;
		this.batchCount = batchCount;
		this.perkPerBatch = perkPerBatch;
	}



	public double calculateGrossSalary()
	  {
		  double grossSalary = basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch);

		  return grossSalary;
	  }
}



Sourcing.java
--------------
package com.ravi.lab_prog_tax_util;

public class Sourcing 
{
	  int id;
	  String name;
	  double basicSalary;
	  double HRAPer;
	  double DAPer;
	  int enrollmentTarget;
	  int enrollmentReached;
	  double perkPerEnrollment;
	  
	  
	  
	  public Sourcing(int id, String name, double basicSalary, double hRAPer, double dAPer, int enrollmentTarget,
			int enrollmentReached, double perkPerEnrollment) {
		super();
		this.id = id;
		this.name = name;
		this.basicSalary = basicSalary;
		HRAPer = hRAPer;
		DAPer = dAPer;
		this.enrollmentTarget = enrollmentTarget;
		this.enrollmentReached = enrollmentReached;
		this.perkPerEnrollment = perkPerEnrollment;
	}



	public double calculateGrossSalary()
	  {
		  double grossSalary = basicSalary +HRAPer +DAPer +((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment;
		  return grossSalary;
	  }
}



TaxUtil.java
-------------
package com.ravi.lab_prog_tax_util;

public class TaxUtil 
{
 public double calculateTax(Employee emp) 
 {
	 
	 if(emp.calculateGrossSalary() > 30000)
	 {
		return emp.calculateGrossSalary()*0.20; 
	 }
	 else
	 {
		 return emp.calculateGrossSalary()*0.05;
	 }
 } 
 public double calculateTax(Manager man) 
 {
	 if(man.calculateGrossSalary() > 30000)
	 {
		return man.calculateGrossSalary()*0.20; 
	 }
	 else
	 {
		 return man.calculateGrossSalary()*0.05;
	 }
 }
 public double calculateTax(Trainer tnr) 
 {
	 if(tnr.calculateGrossSalary() > 30000)
	 {
		return tnr.calculateGrossSalary()*0.20; 
	 }
	 else
	 {
		 return tnr.calculateGrossSalary()*0.05;
	 } 
 }
 public double calculateTax(Sourcing src) 
 {
	 if(src.calculateGrossSalary() > 30000)
	 {
		return src.calculateGrossSalary()*0.20; 
	 }
	 else
	 {
		 return src.calculateGrossSalary()*0.05;
	 } 
 }

}


ClassObject.java
----------------

package com.ravi.lab_prog_tax_util;

public class ClassObject {

	public static void main(String[] args)
	{
	  Employee e1 = new Employee(101, "Virat", 25000, 3000, 2500);
	  
	  TaxUtil tu = new TaxUtil();
	  double tax = tu.calculateTax(e1);
	  System.out.println("Total tax for Virat in this year is : "+tax);
	 

	}

}

-------------------------------------------------------------------------
instance block in java
------------------------
It is a new feature introduced in java. The main purpose of instance block to initialize the instance variable of the class before the constructor, that is the reason it is also known as instance initializer.

An instance block we can write inside the class even inside the method or constructor.

An instance block will be automatically placed in the second line of constructor at the time of compilation.

An instance block will be executed automatically at the time of creating the object BEFORE THE CONSTRUCTOR BODY EXECUTION.

Instance block will execute once per object that means whenever we create an object, instance block will be executed.

If we have multiple instance blocks in a class then they would be executed in the same order as they were written in the class(order wise)

Example :-

//Instance Block

{

}
------------------------------------------------------------------------
//WAP which displays instance block is executed before the Constructor
  body

2 files :
--------
package com.ravi.instance_block;

public class Instance 
{
	public Instance()
	{
		System.out.println("No argument Constructor");
	}
	
	//instance block
	{
		System.out.println("Instance Block");	
	}

}

InstanceBlock1.java
-------------------
package com.ravi.instance_block;

public class InstanceBlock1 {

	public static void main(String[] args)
	{
		new Instance(); //Nameless Object OR Anonymous object
		System.out.println("..........");
		new Instance();


	}
}

Note :- From the above program it is clear that instance block will be executed as per object.
------------------------------------------------------------------------
WAP in Java that describes instance blocks are executed from top to bottom.

2 files :-
-----------
Test.java
----------
package com.ravi.instance_block;

public class Test 
{
   int x;
   
   public Test()
   {
	   System.out.println(x);
   }
   
   {
	   x = 100;
	   System.out.println(x);
   }
   
   {
	   x = 200;
	   System.out.println(x);
   }
   
   {
	   x = 300;
	   System.out.println(x);
   }  
   
}

InstanceBlock2.java
-------------------
package com.ravi.instance_block;

public class InstanceBlock2 {

	public static void main(String[] args) 
	{
		new Test();
	}
}
------------------------------------------------------------------------
Some important points regarding constructor :-

1) We can declare a constructor as private. We should declare constructor
   as private due to following two reasons 

   a) If our class contains only static methods.
   b) We want to develop singleton class, singleton class means only one
      object is possible by owner of the class.

2) We cannot declare a constructor as a static and final
-------------------------------------------------------------------------
HEAP AND STACK DIAGRAM :
------------------------
What is HEAP Memory ?
---------------------
In java, whenever we create the objects, all the objects are created in a special memory called HEAP MEMORY.

What is STACK Memory?
---------------------
In java, All the methods are executed as a part of Stack Memory. Whenever we call a method then stack frame will be created.

What is Garbage Collector ?
---------------------------
Garbage Collector :-
----------------------
In older language like C++, It is the responsibility of the programmer to allocate the memory as well as to de-allocate the memory otherwise there may be chance of getting OutOfMemoryError

But in Java a user is not responsible to de-allocate the memory that means memory allocation is the responsibility of user but  memory de-allocation is automatically done by Garbage Collector.

Garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects (The object which does not contain any references).

It is an automatic memory management in java. JVM internally contains a thread called Garbage collector, It is responsible to delete the unused objects or the objects which are not containing any references in the heap memory.

Note :- GC uses an algorithm mark and sweep to make an un-used objects eligible for Garbage Collection.[Diagram 30-SEP-23]

-----------------------------------------------------------------------
How many ways we can make an object eligible for garbage Collector :
--------------------------------------------------------------------
There are 3 ways to make an Object eligible for Garbage Collector :
----------------------------------------------------------------
1) Assigning a null literal to reference variable

    Employee e1 = new Employee();
    e1 = null;

 2) Creating an object inside the method

      public void createObject()
      {
          Employee e2 = new Employee();
      }
Note :- Once the method execution is over automatically Object is eligible for Garbage Collector

3) Assigning new object to the Existing reference variable

     Employee e3 = new Employee();

     e3 = new Employee();
----------------------------------------------------------------------
HEAP and STACK diagram for Customer.java
-----------------------------------------
Customer.java (Single file)
---------------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) //constructor
	{
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val=100;
		Customer c = new Customer("Ravi",2);

        m1(c);
		
		//GC [1 object is eligible foe GC i.e 3000x]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust)
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  

// 9 5
----------------------------------------------------------------------------
HEAP and STACK diagram for Sample.java
-----------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2);  

		s1=null;

        //GC [4 objects are eligible for GC 1000x,2000x,5000x and 6000x]

		System.out.println(s2.i1);		
	}
public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}

//20  9
----------------------------------------------------------------------------
HEAP and STACK diagram for Test.java
-----------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; //3000x
		t3.t = t4; //4000x
		t1.t = t2.t; //3000
		t2.t = t4.t; //2000x

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
//300  200  400  200
----------------------------------------------------------------------
03-Oct-23
---------
HEAP and STACK diagram for Employee.java
--------------------------------------
public class Employee
{
	int id=100;
	public static void main(String[] args) 
	{
		int val=200;

		Employee e1 = new Employee();

		e1.id=val;

		update(e1);	
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id=500;

        
		switchEmployees(e2,e1);		

		    //GC [2 objects 2000x and 4000x are eligible for Garbage Collector]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)
	 {
        e.id=500;
		e=new Employee();
		e.id=400;
	 }

	 public static void switchEmployees(Employee e1,Employee e2)
	  {
		 int temp=e1.id;
		 e1.id=e2.id; 
		 e2= new Employee();
		 e2.id=temp;
	  }
   }

//500  500  500
---------------------------------------------------------------------
Relationship between the classes :
----------------------------------
In java, we have two types of relation between the classes.

  a) IS-A Relation (We can achieve by using Inheritance concept)
  b) HAS-A Relation(We can achieve by using Association concept)

  class Vehicle
  {
     private Engine engine; \\HAS-A relation

  }
  class Car extends Vechile
  {
    //Car IS-A Vehicle so it is creating IS-A relation
  }

--------------------------------------------------------------------
04-Oct-23
---------

Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to C++ the parent class is called Base class and the child class is called Derived class, According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downward more specialized properties will occur.

Types of Inheritance :
----------------------
There are 5 types of Inheritance in java :-

1) Single level Inheritance
2) Multi level Inheritance
3) Hierarchical Inheritance
4) Hybrid Inheritance
5) Multiple Inheritance [Not supported by Java using classes]

WAP in java to implement Single Level Inheritance (Only Basic)
---------------------------------------------------------------
3 files :
---------
Super.java
-----------
package com.ravi.inheritance;

public class Super 
{
  protected int x;
  protected int y;
  
  public void setSuperData(int x, int y)
  {
	  this.x= x;
	  this.y = y;
  }
  
}


Sub.java
---------
package com.ravi.inheritance;

public class Sub extends Super
{
   public void showData()
   {
	   System.out.println("x value is :"+x);
	   System.out.println("y value is :"+y);
   }
}



Main.java
---------
package com.ravi.inheritance;

public class Main 
{
	public static void main(String[] args) 
	{
		Sub s = new Sub();
		s.setSuperData(100, 200);
		s.showData();

	}

}
------------------------------------------------------------------------
WAP in java to implement Single level inheritance :
----------------------------------------------------
Writing multiple classes in a single file (Not recommended)

1 file :
---------
SingleLevelInheritance.java
---------------------------
package com.ravi.single_lev;

class Emp
{
  protected int employeeNumber;
  protected String employeeName;
  protected double employeeSalary;
  
	public void setEmp(int employeeNumber, String employeeName, double employeeSalary) 
	{
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	} 
  
}
class Pemp extends Emp
{
	protected String department;
	protected String designation;
	
	public void setPemp(String department, String designation) 
	{
		this.department = department;
		this.designation = designation;
	}

	@Override
	public String toString() 
	{
		return "Pemp [department=" + department + ", designation=" + designation + ", employeeNumber=" + employeeNumber
				+ ", employeeName=" + employeeName + ", employeeSalary=" + employeeSalary + "]";
	}	
}


public class SingleLevelInheritance 
{
	public static void main(String[] args) 
	{
		Pemp pemp = new Pemp();
		pemp.setEmp(101, "Raj", 80000.89);	
		pemp.setPemp("IT", "Developer");
		System.out.println(pemp);
	}
}
-------------------------------------------------------------------------
WAP in multilevel Inheritance :
-------------------------------
Single File :
------------
MultiLevelInheritance.java
--------------------------
package com.ravi.multilevel;

class GrandFather
{
	public void land()
	{
		System.out.println("1600 SQFT land");
	}
}
class Father extends GrandFather
{
	public void house()
	{
		System.out.println("3 BHK house");
	}
}

class Son extends Father
{
	public void car()
	{
		System.out.println("Audi car");
	}
}

public class MultiLevelInheritance 
{
	public static void main(String[] args) 
	{
		Son s1 = new Son();
		s1.land();  s1.house();  s1.car();
	}
}
------------------------------------------------------------------------
WAP in java to implement Hierarchical Inheritance :-
-----------------------------------------------------
HierarchicalInheritance.java
-----------------------------
package com.ravi.hierarchical;

class Employee
{
	protected double salary;
}

class Developer extends Employee
{
	public Developer(double salary)
	{
		this.salary = salary;
	}

	@Override
	public String toString() 
	{
		return "Developer [salary=" + salary + "]";
	}

	
	
}


class Designer extends Employee
{
	public Designer(double salary)
	{
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Designer [salary=" + salary + "]";
	}
	
}

public class HierarchicalInheritance 
{
	public static void main(String[] args) 
	{
		System.out.println(new Developer(80000));
		System.out.println(new Designer(25000));

	}

}
-------------------------------------------------------------------------
05-Oct-23
---------
super keyword :
---------------
It is a keyword in java which is used to access the member of super class.

super keyword we can use in 3 ways in java :

1) To call the super class variable
2) To call the super class Method
*3) To call the super class constructor


1) To call the variable of the super class
--------------------------------------------
    Whenever super class variable name and sub class variable name both are same and if we create an object for the sub class then the sub class will provide more priority to its own class variable, If we want to invoke the super class variable then we should use super keyword. It is also known as variable shadow (Hiding of variable)

    super keyword always refers to its immediate super class.

    Note :- We should use super keyword when the super class member name and sub class member name both are same as welll as We can't use super keyword from static context.

 3 files :
 ----------
 Father.java
 ------------
 package com.ravi.super_var;

 public class Father 
 {
  protected double balance = 50000;
 }

 Son.java
 --------
 package com.ravi.super_var;

public class Son extends Father
{
	protected double balance = 18000;
	
	public Son()
	{
		System.out.println("Son balance is :"+balance);
		System.out.println("Father balance is :"+super.balance);
	}
}



 SuperVar.java
 -------------
package com.ravi.super_var;

public class SuperVar 
{
	public static void main(String[] args) 
	{
		Son s1 = new Son();		
	}
}
------------------------------------------------------------------------
2) To call the method of the super class
---------------------------------------------
   Whenever super class method name and sub class method name both are same and if we create an object for the sub class then by default it will invoke or call the sub class method, if we want to call the super class method then we should use super keyword.
-------------------------------------------------------------------------
1 file SuperMethod.java
------------------------
package com.ravi.super_method;

class A
{
	public void show()
	{
		System.out.println("Show method of super class...");
	}
}

class B extends A
{
	public void show()
	{
		System.out.println("Show method of Sub class...");
		super.show();
	}
}

public class SuperMethod 
{
	public static void main(String[] args)
	{
		new B().show();
		
	}
}
--------------------------------------------------------------------
06-Oct-23
---------
*3) To call the super class constructor : (Constructor Chaining)
-------------------------------------------------------------------
Whenever we write a class in java and we don't write any kind of constructor to the class then the java compiler will automatically add one default constructor to the class.

THE FIRST LINE OF ANY CONSTRUCTOR IS RESERVERD EITHER FOR super() or this() keyword.

In the first line of any constructor if we don't specify either super() or this() then the compiler will automatically add super() to the first line of constructor.

Now the purpose of this super() [added by java compiler], to call the default constructor or No-Argument constructor of the super class.

In order to call the constructor of super class as well as same class, we have total 4 cases.

CASE 1 :
--------
 super() :- To call the no-argument constructor or default constructor of the super class. It is automatically added by the compiler.

CallingNoArgsConstructor.java [Single File Approach]
-----------------------------------------------------
package com.ravi.super_this;

class A
{
	public A()
	{
		System.out.println("No Argument constructor of Super class");
	}
}

class B extends A
{
	public B()
	{
		System.out.println("No Argument constructor of Sub class");
	}
}

public class CallingNoArgsConstructor 
{
	public static void main(String[] args) 
	{
		B b1 = new B();
	}
}

Note :- From the above program it is clear that, super() is added by compiler to the first line of constructor so, the control will reach to Object class first to maintain the hierarchy.
----------------------------------------------------------------------
CASE 2 :-
----------
super("NIT") :- To call the parameterized constructor of super class

package com.ravi.super_this;

class Parent 
{
	public Parent(String str)
	{
		System.out.println("My Institute Name is :"+str);
	}
}

class Child extends Parent
{
   public Child()
   {
	   super("NIT");
	   System.out.println("No Argument Constructor of Child class");
   }	
}
public class ParameterizedCall 
{
	public static void main(String[] args) 
	{
	   Child c = new Child();	
	}
}
----------------------------------------------------------------------
CASE 3 :-
---------
this() :- It is used to call no argument constructor of current class

CallingNoArgumentOfSameClass.java[Single File Approach]
-------------------------------------------------------
package com.ravi.super_this;

class Super
{
	public Super()
	{
		System.out.println("No-Args constructor of Super class");
	}
	
	public Super(String str)
	{
		this();
		System.out.println("Parameterized constructor :"+str);
	}
}
class Sub extends Super
{
	public Sub()
	{
		super("NIT");
		System.out.println("No-Args constructor of Sub class");
	}
}


public class CallingNoArgumentOfSameClass 
{
	public static void main(String[] args) 
	{
		Sub s1 = new Sub();
	}

}
----------------------------------------------------------------------
CASE 4 :-
----------
this("Ravi") :- It is used to invoked parameterized constructor of
                current class.

CallingParameterizedConstructorOfSameClass.java[Single File Approach]
----------------------------------------------------------------------
package com.ravi.super_this;

class Base
{
	public Base()
	{
		this(100,200);
		System.out.println("No argument constructor of Base class");
	}
	
	public Base(int x, int y)
	{
		System.out.println("Sum is :"+(x+y));
	}
}
class Derived extends Base
{
	public Derived()
	{
		System.out.println("No argument constructor of Derived class");
	}
}
public class CallingParameterizedConstructorOfSameClass 
{
	public static void main(String[] args) 
	{
		Derived d1 = new Derived();
	}

}
----------------------------------------------------------------------
ConstructorChaining.java[Single File Approach]

package com.ravi.super_this;

class Employee
{
	private int empId;
	private String empName;
	
	public Employee()
	{		
		this(222,"Rahul");
		this.empId = 111;
		this.empName = "Raj";
	}
	
	public Employee(int id, String name)
	{
	 
	  System.out.println(id);
	  System.out.println(name);
	}

	@Override
	public String toString() {
		return "Employee [empId=" + empId + ", empName=" + empName + "]";
	}
	
	
}

public class ConstructorChaining 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee();
		System.out.println(e1);
	}

}
----------------------------------------------------------------------
Program on super keyword, to call parameterized constructor of super class
by using Single level Inheritance 
--------------------------------------------------------------------------
package com.nit.super_ex;

import java.util.Scanner;

class Shape
{
	protected int x;
	public Shape(int x)
	{
		this.x = x;
		System.out.println("x value is :"+x);
	}
}

class Square extends Shape
{
	public Square(int side)  //5
	{
		super(side);
	}
	
	public void areaOfSquare()
	{
		System.out.println("Area of Square is :"+(x*x));
	}
}
public class SuperShapeExample 
{
	public static void main(String[] args) 
	{
	  Scanner sc = new Scanner(System.in);	
	  System.out.print("Enter the side of Square :");
	  int side = sc.nextInt();
	  
	  Square sq = new Square(side);
	  sq.areaOfSquare();

	}

}
--------------------------------------------------------------------------
Program on super keyword, to call parameterized constructor of super class
by using Hierarchical Inheritance 
--------------------------------------------------------------------------
package com.nit.super_hierarchical;
class Shape
{
	protected int x;
	public Shape(int x)
	{
		this.x = x;
		System.out.println("x value is :"+x);
	}
}
class Rectangle extends Shape
{
	protected int breadth;
	public Rectangle(int length, int breadth)
	{
		super(length);
		this.breadth = breadth;
	}
	
	public void areaOfRectangle()
	{
		System.out.println("Area of Rectangle :"+(x*breadth));
	}
}

class Circle extends Shape
{
	protected final double PI=3.14;
	
	public Circle(int radius)
	{
	  super(radius);	
	}
	public void areaOfCircle()
	{
		System.out.println("Area of circle is :"+(PI*x*x));
	}
}

public class ShapeExample {

	public static void main(String[] args) 
	{
		Rectangle rr = new Rectangle(10, 15);
		rr.areaOfRectangle();
		
		Circle cr = new Circle(9);
		cr.areaOfCircle();
	}

}
--------------------------------------------------------------------------
Program on super keyword using Hierarchical Inheritance :
----------------------------------------------------------
4 files :
----------
Employee.java
-------------
package com.nit.super_hierarchical;

public class Employee 
{
   protected int employeeId;
   protected String employeeName;
   protected String employeeRole;
   
	public Employee(int employeeId, String employeeName, String employeeRole) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeRole = employeeRole;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeRole="
				+ employeeRole + "]";
	}
   
	
   
}

Manager.java
------------
package com.nit.super_hierarchical;

public class Manager extends Employee
{
	protected double managerSalary;
	
  
    public Manager(int employeeId, String employeeName, String employeeRole, double managerSalary) {
		super(employeeId, employeeName, employeeRole);
		this.managerSalary = managerSalary;
	}


	@Override
	public String toString() {
		return super.toString()+"Manager [managerSalary=" + managerSalary + "]";
	}



  
  
  
}

HR.java
--------
package com.nit.super_hierarchical;

public class HR  extends Employee 
{
  protected double hrSalary;

public HR(int employeeId, String employeeName, String employeeRole, double hrSalary) {
	super(employeeId, employeeName, employeeRole);
	this.hrSalary = hrSalary;
}

@Override
public String toString() {
	return super.toString()+"HR [hrSalary=" + hrSalary + "]";
} 
}

EmployeeDemo.java
------------------
package com.nit.super_hierarchical;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Manager raj = new Manager(101,"Raj","Manager",80000);
		System.out.println(raj);
		
		HR sweta = new HR(201, "Sweta", "HR", 120000);
		System.out.println(sweta);
	}

}
-------------------------------------------------------------------------
07-Oct-23
---------
*Why java does not support multiple inheritance ?
-------------------------------------------------
Whenever a sub class wants to inherit the properties of two or more super classes and both the super class contains same method name then it leads ambiguity problem for the sub class to invoke the method of super classes as shown in our example (diagram 07-OCT-23)

In our example two super classes i.e class A and class B contain doSum(int x, int y) method and there is a sub class called C which try to extends two super classes i.e A and B.

For sub class C, it is difficult to call doSum(int x , int y) method because there would be an ambiguity problem.

That is the reason java does not support multiple inheritance using classes also known as "Diamond Problem" in java, but same(multiple inheritance) we can achieve by using interface concept later.

In java multiple inheritance is possible using interfaces but not by using the classes.
--------------------------------------------------------------------------
IQ
--
class A
{
	public A(double d)
	{
		System.out.println(d);
	}
}
class  Test extends A
{
	public static void main(String[] args) 
	{
		A a1 = new A(5);
   }
}
--------------------------------------------------------------------------
10-Oct-23
----------
Access modifiers in java :
-----------------------------
An access modifiers describes the accessibility scope of the classes as well as the member of the classes.

In java we have 4 access modifiers

1) private (Within the same class)

2) default (Within the same package)

3) protected (Accessible from another package but using inheritance)

4) public  (No restriction, Accessible from everywhere)

private :- 
---------
It is an access modifier and it is the most restrictive access modifier because the member declared as private can't be accessible from outside of the class.
In Java we can't declare an outer class as a private or protected. Generally we should declare the data member(variables) as private.

In java outer class can be declared as public, abstract and final only.

default :-
----------
It is an access modifier which is less restrictive than private. It is such kind of access modifier whose physical existance is not avaialble that means when we don't specify any kind of access modifier before the class name, variable name or method name then by default it would be default.

As far as its accessibility is concerned, default members are accessible within the same folder(package) only.

protected :
------------
It is an access modifier which is less restrictive than default because the member declared as protected can be accessible from the outside of the package (folder) too but by using inheritance concept.

Note :- Both the classes are in different package


Test.java [Available in package com.ravi.inheritance]
package com.ravi.inheritance;

public class Test 
{
   protected int x = 12;
}

Access.java [Available in package com.ravi.constructor]
package com.ravi.constructor;

import com.ravi.inheritance.Test;

public class Access extends Test
{
	public static void main(String[] args) 
	{
		Access access = new Access();
		System.out.println(access.x);

	}

}

public :-
-------
It is an access modifier which does not contain any kind of restriction that is the reason the member declared as public can be accessible from everywhere without any restriction.

According to Object Oriented rule we should declare the classes and methods as public where as variables must be declared as private or protected according to the requirement.
--------------------------------------------------------------------------
Data types in java : [diagram 10-OCT-23]
----------------------------------------
Type casting in Java :
-----------------------
Type casting is nothing but converting one data type to another data type.
In java, type casting can be divided into two types

1) Implicit type casting OR Widening OR Automatic type casting

2) Explicit type casting OR Narrowing OR Manual type casting

Implicit type casting :-
------------------------
If we try to assign a smaller data type to bigger data type then by default, compiler does not have any issue so it will be converted automatically This is the  reason it is known as Implicit or automatic type casting.

byte -> short -> char -> int -> long -> float -> double

Eg:-  byte b = 12;
         short s = b;
--------------------------------------------------------------------------------------------
//program on Implicit type casting 

package com.ravi.implicit;

public class ImplicitEx1 
{
	public static void main(String[] args)
	{
	  byte b = 15;
	  short s = b;
          System.out.println("value is :"+s);
	}
}
----------------------------------------------------------------------------------------------
package com.ravi.implicit;

public class ImplicitEx2 
{
	public static void main(String[] args) 
	{
	  int i = 4567;
	  long x = i;	  
	  System.out.println("Value is :"+x);
	}
}
---------------------------------------------------------------------------------------------
package com.ravi.implicit;

public class ImplicitEx3 
{
	public static void main(String[] args)
	{
	   int x = 'A';
	   System.out.println("x value is :"+x);
	}

}
-------------------------------------------------------------------------

Explicit type casting :
-----------------------
Whenever we try to assign a bigger data type to smaller data type then by default, compiler does not allow this but if we want to perform the explicit type casting then we need to convert the bigger type into smaller type by performing manual type casting.

While performing the explicit type casting there may be chance of loss of data if the value for smaller data type will be beyond the range.

double -> float -> long ->int -> char -> short -> byte

Eg:-
short s = 23;

byte b = s; //not possible short is bigger, byte is smaller

byte b = (byte) s; //converting short to byte type
---------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx1 
{
	public static void main(String[] args)
	{
	  short s = 127;
	  byte b = (byte)  s;  
      System.out.println("value is :"+b); 
	}
}
----------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx2 {

	public static void main(String[] args)
	{
		long l = 1299L;
		
		int x =  (int) l;
		
		System.out.println("x value is :"+x);

	}

}
---------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx3 {

	public static void main(String[] args) 
	{
		float f1 = (float)123.89;
		
		float f2 = 234.78f;
		
		float f3 = 1567.67F;
		
		System.out.println("f1 = "+f1+ " f2 = "+f2+ " f3 = "+f3);

	}

}
--------------------------------------------------------------------------
HAS-A relation between the classes :
------------------------------------------
In order to acheive HAS-A relation concept we should use Association.

Association (Relationship between the classes through Object reference)
------------------------------------------------------------------------
Association :
---------------
Association is a connection between two separate classes that can be built up through their Objects. 

The association builds a relationship between the classes and describes how much a class knows about another class. 

This relationship can be unidirectional or bi-directional. In Java, the association can have one-to-one, one-to-many, many-to-one and many-to-many relationships.

Example:-
One to One: A person can have only one PAN card
One to many: A Bank can have many Employees
Many to one:  Many employees can work in single department 
Many to Many: A Bank can have multiple customers and a customer can have multiple bank accounts.

The following program explians about association and it contains 3 files

Note : In this Program a trainer wants to view the profile of the Student.

3 files :
---------

Student.java
------------
package com.ravi.association_demo;

public class Student 
{
  private int studentId;
  private String studentName;
  private long mobileNumber;
  
    
     //GENERATE SETTER AND GETTER
	public int getStudentId() 
	{
		return studentId;
	}
	public void setStudentId(int studentId) //111
	{
		this.studentId = studentId;
	}
	public String getStudentName() 
	{
		return studentName;
	}
	public void setStudentName(String studentName) 
	{
		this.studentName = studentName;
	}
	public long getMobileNumber() 
	{
		return mobileNumber;
	}
	public void setMobileNumber(long mobileNumber) 
	{
		this.mobileNumber = mobileNumber;
	}
	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", mobileNumber=" + mobileNumber
				+ "]";
	}
	
	

}




Trainer.java
------------
package com.ravi.association_demo;

import java.util.Scanner;

public class Trainer 
{
   public void viewStudentProfile(Student s)  //s = s1
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Student Id :");
	   int id = sc.nextInt();
	   
	   if(id == s.getStudentId())
	   {
		  System.out.println(s);
	   }
	   else
	   {
		   System.out.println("Sorry!!! Student record is not available");
	   }
	   
   }	
}


Main.java
----------
package com.ravi.association_demo;

public class Main 
{
	public static void main(String[] args)
	{
		Student s1 = new Student();
		
		s1.setStudentId(1); 
		s1.setStudentName("Pooja"); 
		s1.setMobileNumber(9812345678L);	
		
        Student s2 = new Student();
		
		s2.setStudentId(2); 
		s2.setStudentName("Raj"); 
		s2.setMobileNumber(9912345678L);	
		
		
		Trainer ravi = new Trainer();
		ravi.viewStudentProfile(s1);
		
	}
}
--------------------------------------------------------------------------
Composition :
-------------
Composition relation is a restricted form of Aggregation in which two classes (or entities) are highly dependent on each other; the composed object cannot exist without the other entity. The composition can be described as a part-of relationship.

A car has an engine. Composition makes strong relationship between the objects. It means that if we destroy the owner object, its members  will be also destroyed with it. For example, if the Car is destroyed the engine will also be destroyed as well.
-------------------------------------------------------------------------
Engine.java
------------
package com.ravi.composition;
//Composition(Strong reference type)

public class Engine 
{
   private String engineType;
   private int horsePower;
   
   //Constructor
	public Engine(String engineType, int horsePower) 
		{
			super();
			this.engineType = engineType;
			this.horsePower = horsePower;
		}
	
	//Getter Methods
   
	public String getEngineType()
	{
	   return engineType;
	}
	public int getHorsePower() 
	{
	   return horsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", horsePower=" + horsePower + "]";
	}  
	
}


Car.java
---------
package com.ravi.composition;

public class Car 
{
	private String carName;
	private Engine engine;      //HAS-A Relation
	
	public Car(String carName)    //Car c1 = new Car("Naxon");
	{
		this.carName = carName;
		this.engine = new Engine("Battery", 1000); //composition (Strong Association)
	}

	//Generate toString() method
	@Override
	public String toString() {
		return "Car [carName=" + carName + ", engine=" + engine + "]";
	}	
}

Main.java
---------
package com.ravi.composition;

public class Main
{
	public static void main(String[] args) 
	{
		Car c1 = new Car("Ford");
		System.out.println(c1);
	}

}
-----------------------------------------------------------------------
11-Oct-23
----------
Aggregation (Weak Reference) :
-----------------------------------
Aggregation is a relation between two classes which can be built through entity reference,  It is a weak reference type that means one object entity does not depend upon another object entity.

An aggregation is a form of Association, which is a one-way relationship or a unidirectional association.

For example, customers can have orders but the reverse is not possible, hence unidirectional in nature.

Example :-
------------
3 files :
---------
Company.java
-------------
package com.ravi.aggregation_demo;

public class Company 
{
  private String companyName;
  private String companyLocation;
  
	public Company(String companyName, String companyLocation) 
	{
		super();
		this.companyName = companyName;
		this.companyLocation = companyLocation;
	}

	public String getCompanyName() {
		return companyName;
	}

	public void setCompanyName(String companyName) {
		this.companyName = companyName;
	}

	public String getCompanyLocation() {
		return companyLocation;
	}

	public void setCompanyLocation(String companyLocation) {
		this.companyLocation = companyLocation;
	}

	@Override
	public String toString() {
		return "Company [companyName=" + companyName + ", companyLocation=" + companyLocation + "]";
	}
	
	
  
  
  
}

Employee.java
-------------
package com.ravi.aggregation_demo;

public class Employee 
{
	private Integer emoloyeeNumber;
	private String employeeName;
	private Double employeeSalary;
	private Company company;
	
	

	public Employee(Integer emoloyeeNumber, String employeeName, Double employeeSalary, Company company) 
	{
		super();
		this.emoloyeeNumber = emoloyeeNumber;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
		this.company = company;
	}
	
	@Override
	public String toString() {
		return "Employee [emoloyeeNumber=" + emoloyeeNumber + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + ", company=" + company + "]";
	}
	
	
	
	
}

Main.java
----------
package com.ravi.aggregation_demo;

public class Main {

	public static void main(String[] args) 
	{
		Company company = new Company("TCS", "Hyderabad");
		
		Employee e1 = new Employee(1, "Virat", 75000.89,company);
		System.out.println(e1);
		
	}
}
---------------------------------------------------------------------
Polymorphism :
------------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Example:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)

Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding

----------------------------------------------------------------------
Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called static polymorphism.

In static polymorphism, compiler has very good idea that which method is going to invoke(call) depending upon the type of parameter we have passed in the method.

This type of preplan polymorphism is called static polymorphism. 

Example:- Method Overloading

----------------------------------------------------------------------
Dynamic Polymorphism :
----------------------------
The polymorphism which exist at runtime is called dynamic polymorphism.

In dynamic polymorphism, compiler does not have any idea about method calling, at runtime JVM will decide that which method is invoked depending upon the class type.

This type of polymorphism is called dynamic polymorphism.(Dynamic Method dispatched)

Example:- Method Overriding
----------------------------------------------------------------------
 Note :- In static polynorphism method calling is done at the time of compilation so it is also known as Early Binding.

 On the other hand In dynamic Polymorphism method calling is done at the of execution (after object creation by JVM) so it is also known as Late Binding.
-----------------------------------------------------------------------
IQ
---
Can we overload the main method ?
----------------------------------
We can overload the main method but JVM will always search the main method which takes String array as a parameter. 

Example :
------------
public static void main(String [] args)  //JVM will serach this method 
{
}
public static void main(String x)
{
}
public static void main(int y)
{
}

Program to show we can overload a main method :
----------------------------------------------
package com.ravi.poly;

public class StaticPolymorphism 
{
  public static void main(String[] args) 
  {
	  System.out.println("JVM calling main method");
	  main("NIT");
  }
  
  public static void main(String args)
  {
	  System.out.println("My Institute Name is "+args);
	  main(9);
  }
  
  public static void main(int y)
  {
	  System.out.println(y);
  }
}
-----------------------------------------------------------------------
12-Oct-23
---------
Method Overloading :
--------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

Method overloading is possible in the same class as well as super and sub class.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

Example :-

public void add(int x, int y)
{
}

public void add(int a, int b, int c)
{
}
----------------------------------------------------------------------
Program on Constructor Overloading :
------------------------------------
2 Files :

Addition.java
--------------
package com.ravi.constructor_overloading;

public class Addition 
{
   public Addition(int x, int y)
   {	  
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	  
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
---------
package com.ravi.constructor_overloading;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		new Addition(10, 20, 30);
		new Addition(12,90);
	}
}
-----------------------------------------------------------------------
Program on Constructor Overloading by using Constructor Chaining :
-----------------------------------------------------------------
2 Files :

Addition.java
--------------
package com.ravi.constructor_overloading1;

public class Addition 
{
   public Addition(int x, int y)
   {	  
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {
	   this(100,200);
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	
	   this(10,20,30);
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
---------
package com.ravi.constructor_overloading1;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		
	}

}
-----------------------------------------------------------------------
Program on Method overloading that describes we can change the return type of the method while Overloading a method.

Sum.java
----------
package com.ravi.method_overload;

public class Sum
{
  public int add(int x, int y)
  {
	  int z = x+y;
	  return z;	  
  }
  
  public String add(String x, String y)
  {
	  String z = x+y;
	  return z;
  }

  public double add(double x, double y)
  {
	  double z = x+y;
	  return z;
  }
}

Main.java
---------
package com.ravi.method_overload;

public class Main {

	public static void main(String[] args) 
	{
		Sum s1 = new Sum();
		String add = s1.add("Data", "base");
		
		int x = s1.add(12, 12);
		
		double y = s1.add(12.89, 12.90);
		
		
		System.out.println(add+" : "+x+" : "+y);

	}
}
-----------------------------------------------------------------------
Var-Args :
------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.(var args must be the last argument)    

We can use var-args as a method parameter only.
-----------------------------------------------------------------------
Program on var-args

2 Files

Test.java
---------
package com.ravi.var_args;

public class Test 
{
  public void input(int... x) //Array
  {
	  System.out.println("Var args executed");
  }
}

Main.java
---------
package com.ravi.var_args;

public class Main {

	public static void main(String ...x)
	{ 			
		Test t1 = new Test();
		t1.input();
		t1.input(12);
		t1.input(15,19);
		t1.input(10,20,30);
		t1.input(10,20,30,40);
		t1.input(10,20,30,40,50);
						
	}

}
-----------------------------------------------------------------------
Program to add parameters values of a method at the time of calling

2 Files 

Test.java
---------

package com.ravi.var_args1;

public class Test 
{
  public void acceptData(int ...x)
  {
	  int sum =0;
	  
	  for(int y : x)
	  {
		 sum = sum+ y; 
	  }
	  System.out.println("Sum of parameters are :"+sum);
  }
}

Main.java
---------
package com.ravi.var_args1;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.acceptData();
		t1.acceptData(10,20);
		t1.acceptData(10,20,30);
		t1.acceptData(100,100,100,100);

	}

}
-----------------------------------------------------------------------
Program that describes var args must be only one and last argument.

2 Files 

Test.java
----------
package com.ravi.var_args2;

public class Test {

	
	
	
	/*
	 * public void accept(float ...x, int ...y) //invalid {
	 * 
	 * }
	 * 
	 * 
	 * public void accept(int ...x, int y) //Invalid {
	 * 
	 * }
	 */
	 	 
	 	 

	public void accept(int x, int... y) // valid
	{
		System.out.println("x value is :"+x);
		for (int z : y) 
		{
			System.out.println(z);
		}
	}
}
Main.java
----------
package com.ravi.var_args2;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(10, 20,30,40,50);
	}
}
-----------------------------------------------------------------------
Var-args can hold hetrogeneous types of data

Test.java
----------
package com.ravi.var_args3;

public class Test 
{
   public void acceptHetro(Object ...obj)
   {
	   for(Object o : obj)
	   {
		   System.out.println(o);
	   }
   }
}

Main.java
---------
package com.ravi.var_args3;

public class Main {

	public static void main(String[] args) 
	{
		new Test().acceptHetro("Ravi",true,45.90,12,'A');

	}

}
-----------------------------------------------------------------------
13-Oct-23
---------
Ambiguity issues while overloading a method ?
----------------------------------------------
Points to remember :
--------------------
1) While Overloading if we get ambiguity issues compiler will provide more priority to the nearest data type.

2) While ambiguity issues compiler will also provide the priority 
   on the basis of following (WAV)

   [Widening  ->  Autoboxing  -> var-args]
   
Main.java
---------
package com.ravi.ambigity_issues;
class Test
{
   public void access(byte b) 
   {
	   System.out.println("byte is executed :"+b);
   }
   public void access(short b)
   {
	   System.out.println("short is executed :"+b);
   }
   
   
}
public class Main1 {

	public static void main(String[] args)
	{
	   Test t1 = new Test();
	   //t1.access(15); //invalid, 15 is of type integer 	 
	   
	   t1.access((byte)29);
	   t1.access((short)22);
	   
	}
}
-----------------------------------------------------------------------
Main2.java
----------
package com.ravi.ambigity_issues;
class A
{
	public void access(String x)
	  {
	    System.out.println("String is invoked :"+x);
	  }

	  public void access(Object x)
	  {
	    System.out.println("Object is invoked :"+x);
	  }
}
public class Main2 
{
   public static void main(String[] args) 
   {
	  A a1 = new A(); 
	  a1.access("Ravi");
	  a1.access(null);
	  	  
   }
}
-----------------------------------------------------------------------
package com.ravi.ambigity_issues;
class B
{
	  public void access(Integer x) 
	  {
	    System.out.println("Autoboxing is invoked :"+x);
	  }

	  public void access(long x) 
	  {
	    System.out.println("Widening is invoked :"+x);
	  }
}
public class Main3 {

	public static void main(String[] args) 
	{
		B b1 = new B();
		b1.access(15);
	}
}
----------------------------------------------------------------------
package com.ravi.ambigity_issues;
class C
{
	  public void access(Integer x) 
	  {
	    System.out.println("Autoboxing is invoked :"+x);
	  }

	  public void access(int ...x) 
	  {
	    System.out.println("Var-Args is invoked :"+x);
	  }
}
public class Main4 {

	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.access(15);

	}

}
----------------------------------------------------------------------
package com.ravi.ambigity_issues;

class D
{	
	  public void access(Integer x)
	  {
	     System.out.println("Autoboxing is invoked :"+x); 
	  }
	  
	  public void access(String x) 
	  { 
		  System.out.println("String is invoked :"+x);
	  } 
	 
}
public class Main5 {

	public static void main(String[] args) 
	{
		D d1 = new D();
		//d1.access(null);   //Invalid
		
	}

}
----------------------------------------------------------------------
package com.ravi.ambigity_issues;

class E
{	
	  public void access(int x)
	  {
	     System.out.println("int is invoked :"+x); 
	  }
	  
	  public void access(long x) 
	  { 
		  System.out.println("long is invoked :"+x);
	  } 
	 
}
public class Main6 {

	public static void main(String[] args) 
	{
	   E e1 = new E();
	   e1.access(15);
		
	}
}
------------------------------------------------------------------------
16-Oct-23
---------
Method Overriding :
-------------------
Writing two or more methods in the super and sub class in such a way that method signature(method name along with method parameter) of both the methods must be same in the super and sub classes. 

While working with method overriding generally we can't change the return type of the method but from JDK 1.5 onwards we can change the return type of the method in only one case that is known as Co-Variant.

Without inheritance method overriding is not possible that means if there is no inheritance there is no method overriding.
------------------------------------------------------------------------
Advantage of Method Overriding :
--------------------------------
Advantage of Method overriding is, Each class is specifying its own specific behavior (Diagram 16-OCT-23).
------------------------------------------------------------------------
Upcasting :- 
------------
It is possble to assign sub class object to super class reference variable using dynamic polymorphism. It is known as Upcasting.

Example:-    Animal a = new Dog();  //valid [upcasting]

Downcasting :
---------------
By default downcasting is not possible, Here we are trying to assign super class object to sub class reference variable but the same we can achieve by using explicit type casting. It is known as downcasting

Eg:-    Dog d = new Animal(); //Invalid

	  Dog d =(Dog) new Animal(); //Valid because Explicit type casting.

	  But by using above statement (Downcasting) whenever we call a method we will get a runtime exception called java.lang.ClassCastException. [Animal cann't be  cast to Dog]
-------------------------------------------------------------------------
package com.nit.oop;

class Animal
{
	public void eat()
	{
		System.out.println("I cannot say");
	}
}

class Dog extends Animal
{
	public void eat()
	{
		System.out.println("Non-Veg type");
	}
}
public class AnimalDemo 
{
	public static void main(String[] args) 
	{
		Animal a = new Dog();  a.eat();		
	}
}
------------------------------------------------------------------------
package com.nit.oop;

class Animal
{
	public void eat()
	{
		System.out.println("I cannot say");
	}
}

class Dog extends Animal
{
	public void eat()
	{
		System.out.println("Non-Veg type");
	}
}
public class AnimalDemo 
{
	public static void main(String[] args) 
	{
		Animal a = new Dog();  a.eat();		
	}

}
-----------------------------------------------------------------------
17-Oct-23
---------
Program on Method Overriding by using Dynamic Method Dispatch:
--------------------------------------------------------------
class RBI
{
	public void loan()
	{
		System.out.println("Bank Should provide loan!!!");
	}
}
class SBI extends RBI
{
	public void loan()
	{
		System.out.println("SBI provides loan @ 9.2%");
	}
}
class BOB extends RBI
{
	public void loan()
	{
		System.out.println("BOB provides loan @ 10.4%");
	}
}

public class MethodOverridingDemo 
{
	public static void main(String[] args) 
	{
		RBI r;
	        r = new SBI();   r.loan(); //Dynamic Method Dispatch
		r = new BOB();   r.loan(); //Dynamic Method Dispatch		
	}
}
------------------------------------------------------------------------
@Override Annotation :
----------------------
In Java we have a concept called Annotation, introduced from JDK 1.5 onwards. All the annotations must be start with @ symbol.

@Override annotation is optional but it is always a good practice to write @Override annotation before the Overridden method so compiler as well as user will get the confirmation that the method is overridden method and it is available in the super class.

If we use @Override annotation before the name of the method in the sub class and if the method is not available in the super class then it will generate a compilation error so it is different from comment because comment will not generate any kind of compilation error if method is not an overridden method, so this is how it is different from comment.
------------------------------------------------------------------------
class Shape
{
	public void draw()
	{
		System.out.println("No idea about shape");
	}
}
class Rectangle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}
}
class Square extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Square");
	}
}

public class ShapeDemo 
{
	public static void main(String[] args) 
	{
		Shape s;
		s = new Rectangle(); s.draw();
		s = new Square(); s.draw();
	}
}
-----------------------------------------------------------------------
Role of access modifier while overriding a method :
---------------------------------------------------
While overriding the method from super class, the access modifier of sub class method must be greater or equal in comparison to access modifier of super class method otherwise we will get compilation error.

public is greater than protected, protected is greater than default (public > protected > default)
[default < protected < public]

So the conclusion is we can't reduce the visibility while overriding a method.

Note :- private access modifier is not availble (visible) in sub class so it is not the part of method overriding.

AccessModifier.java
-------------------
class Super         
{
	public void show()
	{
		System.out.println("Super class show method");
	}
}
class Sub extends Super
{	
	@Override
	protected void show()  //error
	{
		System.out.println("Sub class show method");
	}
}
public class AccessModifier 
{
	public static void main(String[] args) 
	{
		Super s = new Sub();
		s.show();
	}
}
-----------------------------------------------------------------------
Co-variant concept in method overriding :
------------------------------------------------
In general we cann't change the return type of method while overriding a method. if we try to change it will generate compilation error as shown in the program below.


class Super
{
	public void show()
	{
		System.out.println("Super class show method ...");		
	}
}
class Sub extends Super
{
	@Override
	public int show() //error[int is not compatible with void]
	{
		System.out.println("Sub class show method ");
		return 0;
	}
}
public class IncompatibleOverride
{
	public static void main(String [] args)
	{
		Super s = new Sub();
		s.show();
	}
}

Note :- The above program will generate compilation error because we
        are trying to change the return type of the method while 
	overriding so int is not compatible with void.

	But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP called Co-Variant as shown in the program below.
----------------------------------------------------------------------
class Animal
{
}
class Dog extends Animal
{
}

class Bird
{
	public Animal fly()
	{
		System.out.println("Bird is flying");
		return new Dog();
	}
}
class Parrot extends Bird
{
	@Override
    public Dog fly()
	{
		System.out.println("Parrot is flying");
		return new Dog();
	}
}

public class CoVariant 
{
	public static void main(String[] args) 
	{
		Bird b = new Parrot();
		b.fly();
	}
}
-----------------------------------------------------------------------

class Super
{
	public Object display()
	{
		System.out.println("Super class display method!!!");
		return new Object();
	}
}
class Sub extends Super
{
	@Override
	public String display()
	{
		System.out.println("Sub class display method!!!");
		return null;
	}
}
class CoVariant1 
{
	public static void main(String[] args) 
	{
		Super s = new Sub();
		s.display();
	}
}
-----------------------------------------------------------------------
18-10-2023
----------
*Can we override main method?
           OR
Can we override static method
           OR
What is method hiding in java?

Points to remember :(4 points)
-------------------------------
1) We can't override static method because it is the part of the class but not the part of the Object.

2) We can't overide static method with non-static (instance) method.

3) We can't overide non-static method with static method.

4) We can't override main method but we can overload the main method, Here JVM will always search the main method which contains String array as a parameter.

Defination
----------
We can't override static method because it is not the part of the object it is executed at the time of loading the .class file into JVM memory.

If a sub class defines a static method with the same signature with the static method in the super class, the method in the sub class is hidden by the method in the super class. 

We can declare a static method with the same signature in the sub class as declared in the super class which  looks like we can override static methods but in java static methods of super class are hidden from sub class which is known as Method Hiding.

Note :- a) we can't override static and  private methods.
------------------------------------------------------------------
//program on Method Hiding.

class Super
{
	public static void display()
	{
		System.out.println("Display Method of Super class");
	}
}
class Sub extends Super
{	
	//Method Hiding
	public static void display()
	{
		System.out.println("Display Method of Sub class");
	}
}
public class MethodHiding 
{
	public static void main(String[] args) 
	{
		Super s = new Sub();
		      s.display();
	}
}
-------------------------------------------------------------------
Method Chaining :
-----------------
It provides a facility to call n number of methods in a single statement. 

By using method chaining concept we can concise our code.

While calling the method, we always depend upon previous method return type and the last invoked method will be final return type of the statement(18-OCT-23)

public class MethodChaining
{	
	public static void main(String[] args) 
	{
		String str = "India";
		int len = str.toUpperCase().concat(" is great").length();
		System.out.println(len); //14
	}
}
------------------------------------------------------------------
19-10-2023
-----------
final keyword in java :
-----------------------
In java we use final keyword to provide some kind of restrictions.

We can use final keyword in three ways in java 

1) To declare a class as a final (Inheritance is not possible)

2) To declare a method as a final (We can't override)

3) To declare a variable(Field) as a final (Re-assignment is not possible)


To declare a class as a final :
-------------------------------
Whenever we declare a class as a final class then we cann't extend or inherit that class otherwise we will get a compilation error.

We should declare a class as a final if the composition of the class (logic of the class) is very important and we don't want to share the feature of the class to some other developer to modify the original behavior of the existing class, In that situation only we should declare a class as a final.

Declaring a class as a final does not mean that the variables and methods declared inside the class will also become as a final only the class behavior is final that means we can modify the variables value as well as we can create the object for the final classes.

Note :- In java String and all wrapper classes declared as final class.
------------------------------------------------------------------
//Program that describes we can inherit final class

final class A
{
	private int x = 100;
	public void setData()
	{
		x = 120;
		System.out.println(x);
	}
}
class B extends A //error
{   
}
public class FinalClassEx
{
	public static void main(String[] args)
	{
		B b1 = new B();
		b1.setData();		
	}
}
------------------------------------------------------------------
final class Test
{
	private int data = 100;

	public void setData(int data)
	{
		this.data = data;
		System.out.println("Data value is :"+data);
	}
}
public class FinalClassEx1 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.setData(200);
	}
}

Note :- It is clear that we can create the object for final class as well as we can modify the data of final class.
------------------------------------------------------------------
2) To declare a method as a final (Overriding is not possible)
-----------------------------------------------------------------
Whenever we declare a method as a final then we can't override that method in the sub class otherwise there will be a compilation error.

We should declare a method as a final if the body of the method i.e the implementation of the method is very important and we don't want to override or change the super class method body by sub class method body then we should declare the super class method as final method.
-----------------------------------------------------------------
class A
{
	protected int a = 10;
	protected int b = 20;

     public final void calculate()
	  {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	  } 
}
class B extends A
{	
	public void calculate() //error
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
public class FinalMethodEx 
{
	public static void main(String [] args) 
	{
		 A a1 = new B();
		 a1.calculate();
	}
}
------------------------------------------------------------------
3) To declare a variable(field) as a final :(Re-assignment is not possible)
-----------------------------------------------------------------

In older langugaes like C and C++ we use "const" keyword to declare a constant variable but in java const is a reserved word for future use so instead of const we should use "final" keyword.

If we declare a variable as a final then we can't perform re-assignment (i.e nothing but re-initialization) of that variable.

In java It is always a better practise to declare a final variable by uppercase letter according to the naming convention.

Some example of predefined final variables 

Byte.MIN_VALUE   -> MIN_VALUE is a static and final variable

Byte.MAX_VALUE  -> MAX_VALUE is a static and final variable

Example:-   final int DATA = 10; (Now we can not perform re-assignment )
------------------------------------------------------------------
class A
{
	final int A = 10;
	public void setData()
	{
		 A = 10;  //error re-assignment is not possible 
		 System.out.println("A value is :"+A);
	}
}
class FinalVarEx 
{
	public static void main(String[] args) 
	{
		A a1 = new A();

		a1.setData();
	}
}
------------------------------------------------------------------
class FinalVarEx1 
{
	public static void main(String[] args) 
	{
		final int A = 12;
		byte b = A;
		System.out.println(b);
	}
}
------------------------------------------------------------------
Blank final variable :
-----------------------

1) final variables must be initialized at the time of declaration or later (only constructor), after that we can't perform re-initialization.
 
2) A blank final variable can't be initialized by default constructor.

3) A blank final variable must be initialized by the user as a part of constructor. If we have multiple constructor then final variable must be initialized with all the constructor to provide values for the blank final variable to all the objects.
-----------------------------------------------------------------
public class BlankFinalVar 
{
	final int A;  //Blank final variable
		
	public static void main(String[] args) 
	{
		BlankFinalVar fv = new BlankFinalVar();
		System.out.println(fv.A); 
	}
}

Note :- From the above program it is clear that Blank final variable cannot be initialized by default constructor.
------------------------------------------------------------------
class Demo
{	
	 final int A; // blank final variable
	
	public Demo()  //No Argument constructor
	{		
		A = 15;
		System.out.println(A);
	}

	public Demo(int x)  //parameterized constructor
	{		
		A = x;
		System.out.println(A);
	}
}	
public class  BlankFinalVariable
{
	public static void main(String[] args) 
		{		
	         Demo d1 = new Demo();

			 Demo d2 = new Demo(8);
	    }
}
------------------------------------------------------------------
20-10-2023
----------
Object class and it's Method :
-----------------------------
There is a predefined class called Object available in java.lang package, this Object class is by default the super class of all the classes we have in java.

class Test 
{

}

Note :- Object is the super class for this Test class. by default this Object class is super class so explicitly we need not to mention.

Since, Object is the super class of all the classes in java that means we can override the method of Object class as well as we can use the methods of Object class anywhere in java because every class is sub class of Object class.

The Object class provides some common behavior to each sub class Object like we can compare two objects (equals(Object obj)), we can create clone (duplicate) objects (clone()), we can print object properties(instance variable) by using toString(), providing a unique number to each and every object(hashCode()) and so on.
------------------------------------------------------------------
public native int hashCode() :
------------------------------ 
It is a predefined method of Object class.

Every Object contains a unique number generated by JVM at the time of Object creation is called hashCode.

we can find out the hashCode value of an Object by using hashCode() method of Object class, return type of this method is int.

Program :
---------
HashCodeDemo1.java
------------------
package com.ravi;

class Test
{	
}

public class HashCodeDemo1 
{
	public static void main(String[] args) 
	{		
       Test t1 = new Test();
       Test t2 = new Test();
       
       System.out.println(t1.hashCode());
       System.out.println(t2.hashCode());
	}
}

HashCodeDemo2.java
------------------
package com.ravi;

class Student
{
  private int studentId;
  private String studentName;
  
	public Student(int studentId, String studentName) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}  
}
public class HashCodeDemo2 
{
	public static void main(String[] args) 
	{
	   Student s1 = new Student(111, "Virat");	
	   Student s2 = new Student(222, "Rohit");
	   Student s3 = s1;
	   System.out.println(s1.hashCode() +" : "+s2.hashCode()+" : "+s3.hashCode());
	}
}
-------------------------------------------------------------------
public final native Class getClass() :-
------------------------------------------
It is a predefined method of Object class.

This method returns the runtime class of the object, the return type of this method is java.lang.Class.

This method will provide the class keyword + fully qualified name
[fully qualified name = Package Name + class name]

This getClass() method return type is java.lang.Class so further we can apply any other method of java.lang.Class class to this method.
-------------------------------------------------------------------
GetClassDemo1.java
-------------------
package com.ravi;

class Employee
{	
}

public class GetClassDemo1 
{
	public static void main(String[] args) 
	{
		Employee emp = new Employee();
		Class cls = emp.getClass();
		System.out.println(cls);
		
		Integer i = 23;
		cls = i.getClass();
		System.out.println(cls); //[class keyword + FQN]
	}

}
-------------------------------------------------------------------
package com.ravi;

class Customer
{	
}

public class GetClassDemo2 
{
	public static void main(String[] args) 
	{		
      Customer c1 = new Customer();
      String name = c1.getClass().getName(); 
      System.out.println("CLASS NAME IS :"+name);
      
      Double d1 = 89.67;
      name = d1.getClass().getName(); 
      System.out.println("CLASS NAME IS :"+name);
	}
}
------------------------------------------------------------------
21-10-2023
-----------
public String toString() :
----------------------------
It is a predefined method of Object class.

it returns a string representation of the object. In general, the toString method returns a string that "textually represents" this object. The result should be a concise but informative representation that is easy for a person to read

toString() method of Object class conatins following logic.

public String toString()
{
	return getClass().getName()+" @ "+Integer.toHexString(hashCode());   
}

Please note internally the toString() method is calling the hashCode() and getClass() method of Object class.

In java whenever we print any Object reference by using System.out.println() then internally it will invoke the toString() method of Object class as shown in the following program.
-----------------------------------------------------------------
package com.ravi;

class Foo
{
	
}

public class ToStringDemo1 
{
	public static void main(String[] args) 
	{
		Foo f1 = new Foo();
		System.out.println(f1.toString()); //toString();
	}

}

Here in the above program, we are calling the toString() method 
of Object class which will return the Object in String format.
-----------------------------------------------------------------
package com.nit;

class Demo
{
   @Override
   public String toString()
   {
	   super.toString();
	   return "Overridden toString() method";
   }
}

public class ToStringDemo2 
{
	public static void main(String[] args) 
	{
	   Demo d1 = new Demo();
	   System.out.println(d1);
	   
	   Object d2 = new Demo();
	   System.out.println(d2);

	}

}
-----------------------------------------------------------------
public boolean equals(Object obj) :
----------------------------------

-----------------------------------------------------------------
package com.ravi.equals;

class Customer
{
  private int customerId;
  private String customerName;
  
  public Customer(int customerId, String customerName) 
  {
		super();
		this.customerId = customerId;
		this.customerName = customerName;
  }  
}

public class EqualMethodDemo1 
{
	public static void main(String[] args) 
	{
         Customer c1 = new Customer(111, "Virat");	
         Customer c2 = new Customer(111, "Virat");	
      
         System.out.println(c1==c2);
         System.out.println(c1.equals(c2));
	}
}

Note :- Here in both the cases we will get the output as a false because == operator always verify the memory address or momory reference on the other hand equals(Object obj) method of Object class, internally uses == operator only so equals() method will provide false.
-----------------------------------------------------------------
//Overriding the equals(Object obj) method for comparing the content of two objects.
package com.ravi.equals;
class Student
{
	private int studentId;
	private String studentName;
	
	public Student(int studentId, String studentName) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}
	//Overriding the equals(Object obj) method for content comparison
	@Override
	public boolean equals(Object obj) //obj = s2
	{
		//Retrieving the data from 1st object (s1 variable)
		  int sid1 = this.studentId;
		  String sname1 = this.studentName; 
		
		//Retrieving the data from 2nd object (s2 variable)
		  Student s2 = (Student)obj; //Down casting
		  int sid2 = s2.studentId;
		  String sname2 = s2.studentName;
		  
		  if(sid1 == sid2 && sname1.equals(sname2))
		  {
			  return true;
		  }
		  else
		  {
			  return false;
		  }
	}	
}
public class EqualsMethodDemo2 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(111,"Virat");
		Student s2 = new Student(111,"Virat");
		
		System.out.println(s1.equals(s2));
	}
}

In the above program we have overridden equals(Object obj) method from Object class for content comparison. 

String class has an overridden method called equals(Object obj) method for comparing the String content, return type of this method is boolean.
----------------------------------------------------------------
//Same as above program 

package com.ravi.equals;
class Player
{
	int playerId;
	String playerName;
	
	public Player(int playerId, String playerName) 
	{
		super();
		this.playerId = playerId;
		this.playerName = playerName;
	}
	
	//Overriding equals(Object obj) for content comparison
	@Override
	public boolean equals(Object obj)
	{
		Player p2 = (Player) obj;
		
		if(this.playerId == p2.playerId && this.playerName.equals(p2.playerName))
		{
			return true;
		}
		else
		{
			return false;
		}
	}	
}

public class EqualsMethdDemo3 
{
	public static void main(String[] args) 
	{
		Player p1 = new Player(222,"Rohit");
		Player p2 = new Player(222,"Rohit");
		System.out.println(p1.equals(p2));
	}
}
------------------------------------------------------------------
package com.ravi.equals_demo;

class Student
{
	private int studentId;
	private String studentName;
	
	public Student(int studentId, String studentName) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}
	
	@Override
	public boolean equals(Object obj) //obj = e2
	{
		if(obj instanceof Student)
		{
			Student s2 = (Student) obj;
			if(this.studentId == s2.studentId && this.studentName.equals(s2.studentName))
			{
				return true;
			}
			else
			{
				return false;
			}
			
		}
		else
		{
			System.out.println("Sorry! Comparison is not possible");
			return false;
		}
	}
	
	
}

class Employee
{
	private int empId;
	private String empName;
	
	public Employee(int empId, String empName) {
		super();
		this.empId = empId;
		this.empName = empName;
	}	
}

public class EqualsMethodDemo4 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(111,"Virat");
		Student s2 = new Student(111,"Virat");
		Employee e2 = new Employee(111, "Virat");
		System.out.println(s1.equals(e2));
		System.out.println(s1.equals(null));
		System.out.println(s1.equals(s2));
	}

}
-----------------------------------------------------------------
25-10-2023
-----------
enum in java :
--------------
An enum is a keyword in java which is introduced from java 1.5v
onwards.

enum is used to represent Univarsal Constants.

Example :

enum Direction
{
   EAST, WEST, NORTH, SOUTH   //public + static + final
}

All the enum constants are public, static and final. We should write enum constants inside the enum and every constant must be separated by comma.

An enum we can write outside of the class, inside of the class or even inside of the method.

An enum defined inside a class can be declare private, protected, public and static.

An enum by default extends from java.lang.Enum class so we can't inherit an enum.

By default an enum is final so of we try to extend it will generate compilation error.

Enum keyword has provided the method values() through which we can fetch all the enum constants.

In order to fetch the enum constant position we can use ordinal method of Enum class. The return type of this method is int.

We can define a method or a constructor inside an enum but here ; is compulsory.

The first line of an enum is reserved for enum constants.

We can also write constructor inside an enum but it should not be declared as public.

All enum constants are by default object of type enum.
------------------------------------------------------------------
public class Test1
{
	public static void main(String[] args) 
	{
		enum Month
		{
			JANUARY, FEBRUARY,MARCH     //public + static + final
		}

		System.out.println(Month.MARCH);
	}
}
-----------------------------------------------------------------
enum Month 
{
	JANUARY,FEBRUARY,MARCH 
} 
public class Test2
{
	enum Color { RED,BLUE,BLACK } 

     public static void main(String[] args) 
	{
		enum Week {SUNDAY, MONDAY, TUESDAY }
		
		System.out.println(Month.FEBRUARY);
		System.out.println(Color.RED);
		System.out.println(Week.SUNDAY);
	}
}

Note :- From the above Program it is clear that we can define an enum inside a class, outside of a class and inside a method as well.
----------------------------------------------------------------
//Comapring the constant of an enum
public class Test3 
{
	enum Color { RED,BLUE } 

     public static void main(String args[])
     {
          Color c1 = Color.RED; 
          Color c2 = Color.RED;  
		  
          if(c1 == c2)
          {
                System.out.println("==");
          }
          if(c1.equals(c2))
          {
                 System.out.println("equals");
          }
     }	
}
------------------------------------------------------------------
public class Test4 
{
	private enum Season   //private, public, protected, static
	{
	SPRING, SUMMER, WINTER, RAINY;
	}

	public static void main(String[] args) 
	{
		System.out.println(Season.RAINY);
	}
}
------------------------------------------------------------------
//Interview Question
class Hello
{
	int x = 100;
}

enum Direction extends Hello
{
	EAST, WEST, NORTH, SOUTH
}

class Test5 
{
	public static void main(String[] args) 
	{
		System.out.println(Direction.SOUTH);
	}
}

Note :- The above program will generate the error because by default every enum extends java.lang.Enum class. Which is an abstract class.
------------------------------------------------------------------
//All enums are by default final so can't inherit

enum Color
{
	RED, BLUE, PINK;
}
class Test6 extends Color
{
	public static void main(String[] args) 
	{
		System.out.println(Color.RED);
	}
}

Note :- enum is be default final so we can't inherit.
------------------------------------------------------------------
//values() to get all the values of enum

class Test7 
{
	enum Season   
	{
	SPRING, SUMMER, WINTER, FALL, RAINY
	}

	public static void main(String[] args) 
	{
		Season x []=  Season.values();
         
		 for(Season y : x)
		  System.out.println(y);
	}
}
-----------------------------------------------------------------
//ordinal() to find out the order position
class Test8
{
	static enum Season   
	{
	SPRING, SUMMER, WINTER, FALL, RAINY
	}


	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+" order is :"+x.ordinal());
	}
}
------------------------------------------------------------------
//We can take main () inside an enum

enum Test9 
{
	TEST1, TEST2, TEST3;       //Semicolon is compulsory 

	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}	
}
----------------------------------------------------------------
//constant must be in first line of an enum

enum Test10
{
	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}

	 HR, SALESMAN, MANAGER;
}
------------------------------------------------------------------
//Writing constructor in enum
enum Season
{
	WINTER, SUMMER, SPRING, RAINY;   //All are object of type enum

	Season()
	{
		System.out.println("Constructor is executed....");
	}
}
class Test11 
{
	public static void main(String[] args) 
	{
		System.out.println(Season.WINTER);
		System.out.println(Season.SUMMER);
		
	}
}

Note :- All enum constants are by default Object of type enum  so when JVM will load enum to the memory all objects will be automatically loaded so for every enum Object respective constructor will be executed.
------------------------------------------------------------------
   //Writing constructor with message
   enum Season   
	{
	   SPRING("Pleasant"), SUMMER("UnPleasent"), RAINY("Rain"), WINTER;

        String msg;
	  
	    Season(String msg)
		{
		  this.msg = msg;
		}

		Season()
		{
			this.msg = "Cold";
		}

		public String getMessage()
		{
			return msg;
		}
	}
class Test12
{	
	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+"  is :"+x.getMessage());
	}
}
-----------------------------------------------------------------
enum MyType 
{
ONE 
{
	@Override
    public String toString() 
	{
        return "this is one";
    }
},
 
TWO 
{
	@Override
    public String toString() 
	{
        return "this is two";
    }
}
}
public class Test13
{
	public static void main(String[] args) 
	{
		System.out.println(MyType.ONE);
		System.out.println(MyType.TWO);
		
	}
}
------------------------------------------------------------------
public class Test14
{  
	enum Day
		{ 
		  SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
		}  
  
public static void main(String args[])
{    
	Day day=Day.SUNDAY;  
	  
	switch(day)
	{  
	 case SUNDAY:   
	 System.out.println("Sunday");  
	 break;  
	 case MONDAY:   
	 System.out.println("Monday");  
	 break;  
	 default:  
	 System.out.println("other day");  
    }  
  
  }
}  
-----------------------------------------------------------------
26-10-2023
-----------
Inner classes in java :
------------------------
In java it is possible to define a class (inner class) inside another class (outer class). It is also called Nested class.

A nested class or an inner class is a class that exists within another class. In other words, the inner class is a part of a class, just as variables and methods are members of a class

An inner class, .class file will be represented by $ symbol.

Advantages of inner class :
--------------------------------
1) It helps us to logically divide the class and it's respective code.

2) It is used to achieve encapsulation.

3) It enhance the readability and maintainability of the code.

Java supports four kinds of inner classes :
-----------------------------------------------
1) Nested inner class OR Member class OR Regular class 

2) Method local inner class

3) Static nested inner class

4) Anonymous inner class
------------------------------------------------------------------
1) Member Inner class OR Nested Inner class OR Regular class :
------------------------------------------------------------------
A non-static class that is created inside a class but outside of a method is called Member Inner class OR Nested Inner class OR Regular class.  

It can be declared with access modifiers like private, default, protected, public, abstract and final.

It is also called as Regular Inner class.

An inner class can also access the private member of outer class.

Note :- The .class file of an inner class will be represented by $ symbol at the time of compilation.

An outer class can be declared as public, abstract and final only.
------------------------------------------------------------------
class Outer 
{
	private int a = 15;

	class Inner 
	{
		public void displayValue() 
		{
			System.out.println("Value of a is " + a);
		}
	}
}
public class Test1
{
	public static void main(String... args)  
	{		
		//Outer mo = new Outer(); //Outer class Object is created
		//Outer.Inner inner = mo.new Inner(); //Inner class object is created

        Outer.Inner inner = new Outer().new Inner();
		inner.displayValue();
	}
}
------------------------------------------------------------------
class MyOuter
{
      private int x = 7;
      public void makeInner()
      {
            MyInner in = new MyInner();
			System.out.println("Inner y is "+in.y);
            in.seeOuter();
      }

      class MyInner
      {
		    private int y = 15;
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test2
{
      public static void main(String args[])
      {
            MyOuter m = new MyOuter();
            m.makeInner();   
      } 
}
-----------------------------------------------------------------
class MyOuter
{
      private int x = 15;
      class MyInner
      {
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test3
{
      public static void main(String args[])
      {
		  //Creating inner class object in a single line
           MyOuter.MyInner m = new MyOuter().new MyInner();
			m.seeOuter();
      } 
}
-----------------------------------------------------------------
class MyOuter  
{
      static int x = 7;
      class MyInner
      {
            public static void seeOuter()  //MyInner.seeOuter();
            {
                  System.out.println("Outer x is "+x);
            }
      }
}

public class Test4
{
      public static void main(String args[])
      {
          MyOuter.MyInner.seeOuter();
      } 
}
-----------------------------------------------------------------
class OuterClass 
{
	int x;
	public class InnerClass
	{
		int x;
	}
}
public class Test5
{
}
Note :- We can declare an inner class as public.
---------------------------------------------------------------------
class OuterClass 
{
	int x;
	protected class InnerClass
	{
		int x;
	}
}
public class Test6
{
}
Note :- We can't declare an outer class as private and protected but an inner class we can declare with private and protected access modifiers.
---------------------------------------------------------------------
class OuterClass 
{
	int x;
	private class InnerClass
	{
		int x;
	}
}
public class Test7
{
}

Note :- Inner class can be declared with private.
---------------------------------------------------------------------
class OuterClass 
{
	int x;
	abstract class InnerClass
	{
		int x;
	}
}
public class Test8
{
}
Note :- Inner class can be declared with abstract.
-------------------------------------------------------------------
class OuterClass 
{
	int x;
	final class InnerClass
	{
		int x;
	}
}
public class Test9
{
}

Note :- Inner class can be declared with final.
----------------------------------------------------------------
class OuterClass 
{
	private int x=200;
	class InnerClass
	{
		public void display()  //Inner class display method
		{
		System.out.println("Inner class display method");
		}
		
		public void getValue()
		{
			display();
			System.out.println("Can access outer private var :"+x);
		}
	}

		public void display()  //Outer class display method
		{
			System.out.println("Outer class display");
		}	
}
public class Test10
{
	public static void main(String [] args)
	{
		OuterClass.InnerClass inobj = new OuterClass().new InnerClass();
		inobj.getValue();
		
		new OuterClass().display();
	}
}
-----------------------------------------------------------------
27-10-2023
----------
2) Method local inner class :
 -------------------------------
 If a class is declared inside the method then it is called  method local inner class.

 We cann't apply any access modifier on method local inner class but they can be marked as abstract and final.

 A local inner class we can't access outside of the method that means the scope of method local inner class within the same method only.
-----------------------------------------------------------------
//program on method local inner class
class MyOuter3
{
      private String x = "Outer class private data";

      public void doSttuff()
      { 
           String z = "local variable";  //must be final till JDK 1.7

           class MyInner  //only final and abstract is possible
           {
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+x);
                      System.out.println("Local variable z is : "+z);
                 }
           }
		  MyInner mi = new MyInner();
          mi.seeOuter();
      }
	  
	   
	 
}
public class Test11
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}
----------------------------------------------------------------
//local inner class we can't access outside of the method
class MyOuter3
{
      private String x = "Outer class Data";

      public void doSttuff()
      { 
           String z = "local variable";  
            class MyInner        
            {
				 String z = "CLASS variable"; 
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+x);
                      System.out.println("Local variable z is : "+z);
                 }
           }
		   MyInner mi = new MyInner();
	        mi.seeOuter(); 
		      
      }    	
	  
}
public class Test12
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}

Note :- Method local inner class object must be created inside the method only.
-----------------------------------------------------------------
3) Static Nested Inner class :
---------------------------------
A static inner class which is declared with static keyword inside an outer class is called static Nested inner class.

It cann't access non-static variables and methods  i.e (instance members) of outer class.

For static nested inner class, Outer class object is not required.

If a static nested inner class contains static method then object is not required for inner class. On the other hand if the static inner class contains instance method then we need to create an object for static nested inner class.
-----------------------------------------------------------------
//static nested inner class
class BigOuter
{
     static class Nest   //static nested inner class   
     {
          void go()  //Instance method of static inner class
          {
               System.out.println("Hello welcome to static nested class");  
          }  
     }
}
class Test13
{    
      public static void main(String args[])
      {
          BigOuter.Nest n = new BigOuter.Nest();
          n.go();
			
			
      } 
}
-----------------------------------------------------------------
class Outer
{  
	  static int x=15;  

	  static class Inner
	  {  
			void msg()
				{
					System.out.println("x value is  "+x);
				}  
	  }
}
class Test14
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
-----------------------------------------------------------------
class Outer    
{  
	  static int x = 25;  
	  static class Inner
	  {  
			static void msg()
				{
					System.out.println("x value is  "+x);					
				}		
	  }	  
}
class Test15
{  
	public static void main(String args[])
	{  
		Outer.Inner.msg();
	}  
}  
-----------------------------------------------------------------
class Outer
{  
	  int x=15;  //error (not possible because try to access instance variable)
	  static class Inner
	  {  
			void msg()
				{
					System.out.println("x value is  "+x);
				}  
	  }
}
class Test16
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
-----------------------------------------------------------------
4) Anonymous inner class :
------------------------------ 
It is an inner class without a name and for this kind of inner class only single Object is created. (Singleton class)

*A normal class can implement any number of interfaces but an anonymous inner class can implement only one interface at a time.

A normal class can extend one class and implement any number of interfaces at the same time but an anonymous inner class can extend one class or can implement one interface at a time.
-----------------------------------------------------------------
package com.ravi.anonymous;

class Vehicle
{
	public void run()
	{
		System.out.println("Vehicle is running");
	}
}

public class Anonymous {

	public static void main(String[] args) 
	{
		//Anonymous inner class
		Vehicle car = new Vehicle()
		{
			@Override
			public void run()
			{
				System.out.println("Car is running");
			}
			
		};
		
		//Anonymous inner class
		Vehicle bike = new Vehicle()
		{
			@Override
			public void run()
			{
				System.out.println("Bike is running");
			}
			
		};
		
		car.run();  bike.run();

	}

}
-----------------------------------------------------------------
28-10-2023
-----------
Abstract class and abstract methods :
-------------------------------------
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub class.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final,private and static (illegal combination of modifiers)
-----------------------------------------------------------------
//Program on abstract class and abstract method

abstract class Shape
{
	public  abstract void draw();
}

class Rectangle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}
}
class Square extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Square");
	}
}

public class ShapeDemo 
{
	public static void main(String[] args) 
	{
		Shape s ;

		s = new Rectangle(); s.draw();

		s = new Square(); s.draw();
	}
}
-----------------------------------------------------------------
package com.ravi.iq;

abstract class Car
{
   protected int speed = 100;
   
   public Car()
   {
	   System.out.println("Car class Constructor!!!");
   }
   
   public void getDetails()
   {
	   System.out.println("Car has 4 wheels");
   }
   
   public abstract void run();
   
}

class Honda extends Car
{
	@Override
	public void run() 
	{		
	   System.out.println("Running Safely");	
	}	
}
public class InterviewQuestion 
{
	public static void main(String[] args) 
	{
		Car c = new Honda();
		System.out.println("Speed of car is :"+c.speed);
		c.getDetails();
		c.run();
	}
}

Note :- In the above program Car class constructor will be executed by super keyword of Honda class using default constructor.

Abstract class constrcutor will be executed with the help of sub class object.
-----------------------------------------------------------------
31-10-2023
----------
Program that describes, all the abstract method defined in the super class must be overridden in the sub class

AbstractExample.java
---------------------
package com.ravi.abstract_demo;

abstract class A
{
	public abstract void show();
	public abstract void demo();
}
abstract class B extends A
{
	@Override
	public void show() // + demo();
	{
	  System.out.println("Show method implemented in class B");			
	}	
}
class C extends B
{
	@Override
	public void demo() 
	{
	  System.out.println("Demo method implemented in class C");			
	}	
}

public class AbstractExample 
{
	public static void main(String[] args)
	{
		C c1 = new C();    c1.show();   c1.demo();
	}

}
------------------------------------------------------------------
//Program to describe common abstract method must be overridden 
  in the sub classes.

package com.ravi.abstract_demo;

abstract class Shape
{
	public abstract void area();
}
class Rectangle extends Shape
{
	private int length, breadth;

	public Rectangle(int length, int breadth) 
	{
		super();
		this.length = length;
		this.breadth = breadth;
	}

	@Override
	public void area() 
	{
		double area = this.length * this.breadth;
		System.out.println("Area of Rectangle is :"+area);		
	}	
}
class Circle extends Shape
{
	private final double PI = 3.14;
	private int radius;
	
	public Circle(int radius) 
	{
		super();
		this.radius = radius;
	}

	@Override
	public void area() 
	{
		double area = PI * radius * radius;
		System.out.println("Area of Circle is :"+area);
	}	
}

public class ShapeDemo 
{
	public static void main(String[] args) 
	{
		Shape s;
		
		s = new Rectangle(3, 5);  s.area();
		s = new Circle(5); s.area();
	}
}
-------------------------------------------------------------------
What is the advantage of writing constructor in the abstract class ?
----------------------------------------------------------------
If my abstract class contains any properties (state OR Data) then we can initialize those properties of abstract class with the help of sub class object by using super keyword as shown in the below 
program.

VehicleDemo.java
-----------------

package com.ravi.abstract_demo;

abstract class Vehicle
{
	protected String vehicleNumber;
	
	public Vehicle(String vehicleNumber) 
	{
		super();
		this.vehicleNumber = vehicleNumber;
	}

	public abstract void run();
}

class Car extends Vehicle
{
	private String carName;
	
	public Car(String carName)
	{
		super("TS 09 6578");
		this.carName = carName;
	}

	@Override
	public void run() 
	{
		System.out.println(this.carName + " Car is running!!");		
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", vehicleNumber=" + vehicleNumber + "]";
	}	
}

public class VehicleDemo 
{
	public static void main(String[] args) 
	{
		Vehicle v = new Car("Naxon");
		v.run(); 
		System.out.println(v);
	}
}
--------------------------------------------------------------------
Implementing the abstract method with the help of anonymous inner class.
package com.ravi.abstract_demo;

abstract class Bird
{
	public abstract void fly();
}

public class AnonymousDemo 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		Bird parrot = new Bird()
		{
			@Override
			public void fly() 
			{
				System.out.println("Parrot can fly");				
			}
			
		};
		
		//Anonymous inner class
		Bird sparrow = new Bird()
		{
			@Override
			public void fly() 
			{
				System.out.println("Sparrow can fly");				
			}
			
		};
		
		 //Anonymous inner class
		  Bird peacock = new Bird()
		  {
			@Override
			public void fly() 
			{
				System.out.println("Peacock can fly");				
			}					
		};
		
		parrot.fly(); sparrow.fly(); peacock.fly();
		
	}

}
----------------------------------------------------------------
interface :
-----------
interface (Upto 1.7) :-
------------------------
An interface is a keyword in java which is similar to a class.

Upto JDK 1.7 an interfcae contains only abstract method that means there is a gurantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can acheive 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we should apply public access modifier to sub class method.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub class otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interfcae we can acheive multiple inheritance in java.

Note :- inside an interface we can't declare any blocks (instance, static) as well as we can't write constructor inside an interface.
----------------------------------------------------------------
3 files :
---------
Moveable.java(I)
-----------------
package com.ravi.variable;

public interface Moveable 
{  
  int SPEED = 90; //public, static and final
  
  void move(); //public and abstract  
}

Car.java(C)
-----------
package com.ravi.variable;

public class Car implements Moveable 
{	
	@Override
	public void move() 
	{		
		//SPEED = 120; Invalid because variable is final
		System.out.println("Car speed is :"+SPEED);
	}

}

Main.java(C)
------------
package com.ravi.variable;

public class Main 
{
	public static void main(String[] args) 
	{
		Moveable m = new Car();
		m.move();
		System.out.println("My Car speed is :"+Moveable.SPEED);
	}

}
---------------------------------------------------------------
3 files :

Client.java(I)
---------------
package com.ravi.interface_demo;

public interface Client 
{
   void doSum(int x, int y);
   void doSub(int x, int y);
   void doMul(int x, int y);
}

Developer.java(C)
-----------------
package com.ravi.interface_demo;

public class Developer implements Client
{

	@Override
	public void doSum(int x, int y) 
	{
		int sum = x + y;
		System.out.println("Addition is :"+sum);
	}


	@Override
	public void doSub(int x, int y) 
	{
		int sub = x - y;
		System.out.println("Subtraction is :"+sub);
	}
	

	@Override
	public void doMul(int x, int y) 
	{
		int mul = x * y;
		System.out.println("Multiplication is :"+mul);
	}

}


Tester.java(C)
-----------------
package com.ravi.interface_demo;

public class Tester {

	public static void main(String[] args) 
	{
		Client c = new Developer();
		c.doSum(12, 10);
		c.doSub(12, 5);
		c.doMul(12, 12);
	}

}
---------------------------------------------------------------
H.W

interface Bank
{
   void deposit(int amount);
   void withdraw(int amount);
}
----------------------------------------------------------------
Program on loose coupling :
---------------------------
IQ
--
How to achieve loose coupling using interfaces :
------------------------------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling.

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

The following program explains how to achieve loose coupling :
--------------------------------------------------------------
6 files :-
----------
HotDrink.java(I)
----------------
package com.ravi.loose_coupling;

public interface HotDrink 
{
  public abstract void prepare();
}


Tea.java
-----------
package com.ravi.loose_coupling;

public class Tea implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Tea!!!");		
	}

}

Coffee.java
-----------
package com.ravi.loose_coupling;

public class Coffee implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee!!!");		
	}

}

Horlicks.java
--------------
package com.ravi.loose_coupling;

public class Horlicks implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Horlicks!!");		
	}

}


Restaurant.java
---------------
package com.ravi.loose_coupling;

public class Restaurant 
{
  public static void createObject(HotDrink drink)
  {
	  drink.prepare();
  }
}

package com.nit.loose_coupling;

public class Main {

	public static void main(String[] args) 
	{
		Restaurant.createObject(new Tea());
		
		Restaurant.createObject(new Coffee());
		
		Restaurant.createObject(new Horlicks());
	}

}

------------------------------------------------------------------
Note :- We can also take return type of the method as an interface so that method can return the object of all the sub classes which are implementing from that particular interface.

public HotDrink accept()
{

   return  new Tea(); OR new Coffee(); OR null OR new Horlicks(); .....(future)
}
----------------------------------------------------------------
02-11-2023
------------
Multiple inheritance by using interface :
------------------------------------------
Upto java 7, interface does not contain any method body that means all the methods are abstract method so we can achieve multiple inheritance by providing the logic in the implementer class as shown in the below program [02-NOV-23]

package com.ravi.interface_demo;

interface A
{
	void m1();
}
interface B
{
	void m1();
}
class Implementer implements B,A
{
  @Override
  public void m1()
  {
	  System.out.println("Multiple Inheritance using interface..");
  }  
}
public class MultipleInheritance 
{
	public static void main(String[] args) 
	{
	   Implementer i = new Implementer();
	               i.m1();
	}
}
------------------------------------------------------------------

package com.ravi.interface_demo;

interface C
{	
  void doSum(int x, int y);  
}
interface D extends C
{
	void doSub(int x, int y);
}
class Calculate implements D
{
	@Override
	public void doSum(int x, int y) 
	{
		int sum = x+y;
		System.out.println("Sum is :"+sum);
		
	}

	@Override
	public void doSub(int x, int y) 
	{
		int sub = x-y;
		System.out.println("Sub is :"+sub);		
	}	
}
public class ExtendingInterface 
{
	public static void main(String[] args) 
	{
		Calculate c = new Calculate();
		c.doSum(12, 12);
		c.doSub(100, 50);
	}

}
------------------------------------------------------------------
Extending one interface to another interface :
-----------------------------------------------
One interface can extends another interface but one interface can't implement another interface.

The following program explains how one interface can extends another interface 

package com.ravi.interface_demo;

interface C
{	
  void doSum(int x, int y);  
}
interface D extends C
{
	void doSub(int x, int y);
}
class Calculate implements D
{
	@Override
	public void doSum(int x, int y) 
	{
		int sum = x+y;
		System.out.println("Sum is :"+sum);
		
	}

	@Override
	public void doSub(int x, int y) 
	{
		int sub = x-y;
		System.out.println("Sub is :"+sub);		
	}	
}
public class ExtendingInterface 
{
	public static void main(String[] args) 
	{
		Calculate c = new Calculate();
		c.doSum(12, 12);
		c.doSub(100, 50);
	}

}
------------------------------------------------------------------
Overriding interface method by using anonymous inner class :
-----------------------------------------------------------
By using anonymous inner class without using an external class, inside the ELC class only we can take an anonymous class to override the super class method/abstract class method/ interface method.

package com.ravi.interface_demo;

interface Student
{
	void writeExam();
}

public class AnonymousInner 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		Student science = new Student()
		{
			@Override
			public void writeExam() 
			{
			 System.out.println("Science Student is Writing Exam");				
			}
			
		};
		
		//Anonymous inner class
		Student commerce = new Student()
		{
		  @Override
		  public void writeExam() 
		  {
			System.out.println("Commerce Student is Writing Exam");				
		  }
					
		};
		science.writeExam();
		commerce.writeExam();		
	}
}
-----------------------------------------------------------------
java 8 features : (March 2014)
-----------------------------
Limitation of abstract method :
           OR
Maintenance problem with interface in an Industry upto JDK 1.7
--------------------------------------------------------------
The major maintenance problem with interface is, if we add any new abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation as shown in the program below.
-----------------------------------------------------------------
4 Files :
---------
Vehicle.java(I)
---------------
package com.nit.java_8;

public interface Vehicle 
{
  void run();
  void horn();
  
  default void digitalMeter() //From java 1.8 onwards
  {
	System.out.println("Digital Meter Facility");  
  }
}

Car.java(C)
------------
package com.nit.java_8;

public class Car implements Vehicle
{
	@Override
	public void run() 
	{
	  System.out.println("Car is Running");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has horn");		
	}
	
	 @Override
	public void digitalMeter() //From java 1.8 onwards
	  {
		System.out.println("Car has Digital Meter Facility");  
	  }
}

Bike.java(C)
------------
package com.nit.java_8;

public class Bike implements Vehicle
{
	@Override
	public void run() 
	{
	  System.out.println("Bike is Running");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("Bike has horn");		
	}
}
Tester.java(C)
------------
package com.nit.java_8;

public class Tester 
{
	public static void main(String[] args) 
	{
		Vehicle v;
		v = new Car();  v.run(); v.horn(); v.digitalMeter();
		v = new Bike(); v.run(); v.horn();

	}

}

Note :- 
--------
Here in the Vehicle interface we have added dafault method digitalMeter() so now for Car class as well as Bike class, there is no boundation to override this default method.

If an implementer class is really required it then that class can override it.
-----------------------------------------------------------------
03-11-2023
----------
interface from JDK 1.8 onwards :
------------------------------------
Upto JDK 1.7 we can use only abstract methods inside an interface, as we know all the abastrct methods must be overridden in the sub class otherwise the sub class will become as an abstract class.

This facility of abstract methods leads to maintenance problem because if we add any new abstract method inside an existing interface then that method has to override by all the sub classes or the classes which are implementing from that particular interface.

To avoid this boundation problem java software people has introduced default and static method inside an interface so from JDK 1.8 onwards we can define the body of the method inside an interface by declaring those method as default method and static method or both.
-------------------------------------------------------------------
What is default Method inside an interface?
------------------------------------------------
default method is just like concrete method which contains method body and we can write inside an interface from java 8 onwards.

default method is used to  provide  specific implementation for the implementer classes which are implmenting from interface because we can override default method inside the sub classes to provide our own specific implementation.

*By using default method there is no boundation to override the default method in the sub class, if we really required it then we can override to provide my own implementation.

by default, default method access modifier is public so at the time of overriding we should use public access modifier.
------------------------------------------------------------------
//default method for specific class method implementation

interface HotDrink
{
	void prepare();

	default void expressPrepare()     //possible from jdk 1.8 
	{
        System.out.println("Preparing with premium");
	}
}
class Tea implements HotDrink
{
	@Override
	public void prepare()
	{
		System.out.println("Preparing Tea");
	}

	@Override
	public void expressPrepare()  //public is compulsory here
	{
        System.out.println("Preparing premium Tea");
	}
}
class Coffee implements HotDrink
{
 @Override
  public void prepare()
	{
		System.out.println("Preparing Coffee");
	}	

	@Override
	public void expressPrepare()  //public is compulsory here
	{
        System.out.println("Preparing Filter Coffee");
	}
}
public class DefaultMethod 
{
	public static void main(String[] args) 
	{
		HotDrink hk;
		hk = new Tea(); hk.prepare(); hk.expressPrepare();		
		hk = new Coffee(); hk.prepare(); hk.expressPrepare();
	}
}
------------------------------------------------------------------
The following program explains that default methods are having low priority than normal methods (Concrete Method). class is having more power than interface.

interface I
{
	default void demo()
	{
		System.out.println("Demo Method in interface I1");
	}
}

class A
{
	public void demo()
	{
		System.out.println("Demo Method in class A");		
	}
}

class B extends A implements I
{	
	
}

public class DefaultMethod1 
{
	public static void main(String[] args) 
	{
		B b1 = new B();
		b1.demo();  b1.access();
	}
}
------------------------------------------------------------------
Multiple Inheritance using default method :
--------------------------------------------
interface I1
{
	default void m1()
	{
		System.out.println("Default method of I1 interface...");
	}
}
interface I2
{
	default void m1()
	{
		System.out.println("Default method of I2 Interface...");
	}
}
class MyClass implements I1,I2
{
   @Override
   public void m1()
	{
	   System.out.println("m1 method of MyClass");
		I1.super.m1();
		I2.super.m1();
	}
}
class MultipleInheritance 
{
	public static void main(String[] args) 
	{
		MyClass m = new MyClass();
		m.m1();
	}
}

Note :- MI is possible by using default method of interface but here we need to use super keyword.
------------------------------------------------------------------

Methods We can write inside an interface :
------------------------------------------
package com.ravi.static_method;

public interface Callable 
{
	public abstract void m1(); //abstract method
	
	default void m2() //default method
	{		
	}

	public static void main(String[] args) 
	{
	   System.out.println("Static method inside interface");	
	}
	
	private void m4() //private non-static method
	{		
	}
	
	private static void m5() //private static method
	{		
	}
}
-----------------------------------------------------------------
04-11-2023
----------
What is static method inside an interface?
------------------------------------------
We can define static method inside an interface from java 1.8 onwards.

static method is only available inside the interface where it is defined that means we cannot invoke static method from the implementer classes.

It is used to provide common functionality which we can apply/invoke from any ELC class.
------------------------------------------------------------------
package com.ravi.static_demo;

interface Calculate
{
	public static int doSum(int x, int y)
	{
		return (x+y);
	}
	public static int doSub(int x, int y)
	{
		return (x-y);
	}
}

public class StaticMethodDemo1 
{
	public static void main(String[] args) 
	{
	  int result = Calculate.doSum(12, 67);
	  System.out.println("Sum is :"+result);
	  
	  result = Calculate.doSub(200, 100);
	  System.out.println("Sub is :"+result);
	}

}
------------------------------------------------------------------
interface Callable
{
	public static void access()
	{
		System.out.println("static method available inside interface");
	}
}
public class StaticDemo2 implements Callable
{
	public static void main(String[] args) 
	{
		Callable.access();

		StaticDemo2.access(); //error

        StaticDemo2 sm = new StaticDemo2();
		            sm.access(); //error
	}
}

Note :- In the above program we will get compilation error because static method is available to Callable interface only so, implementer class cannot invoke static method access.
------------------------------------------------------------------
What is Functional interface ?
-------------------------------
@FunctionalInterface Annotation :
---------------------------------------
If an interface contains only one abstract method then we can say that interface is Functional Interface.

Functional Interface can be defined by @FunctionInterface annotation.

Functional Interface may contain default method and static method but it must contain only one abstract method.

@FunctionalInterface
interface Printable
{
	void print1();//SAM [Single Abstract Method]

	default void print2()
	 {
	 }	
}
------------------------------------------------------------------
Lambda Expression :
----------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
It can be used with functional interface only.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference

Lamda target can't be class or abstract class, it will work with functional interface only.
------------------------------------------------------------------
package com.ravi.lambda;
@FunctionalInterface
interface Drawable
{
	void draw();	
}

public class Lambda1 
{
	public static void main(String[] args) 
	{
		Drawable d = () -> System.out.println("Drawing");
		d.draw();
	}

}
------------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Calculate
{
	void doSum(int x, int y);
}
public class Lambda2 
{
	public static void main(String[] args) 
	{
       Calculate c = (p,q)-> System.out.println("Sum is :"+(p+q));
       c.doSum(10, 20);
	}
}
------------------------------------------------------------------
package com.ravi.lambda;

interface Length
{
	int getLength(String str);	
}

public class Lambda3 
{
	public static void main(String[] args)
	{
		Length l = str -> str.length();		
		System.out.println("Length is :"+l.getLength("India"));
	}

}
--------------------------------------------------------------------------------
06-11-2023
----------
Programs on Lambda :
--------------------
@FunctionalInterface
interface Moveable
{
	void move();  //SAM (Single Abstract Method)
}
public class Lambda1 
{
	public static void main(String[] args) 
	{
		Moveable car =  () -> System.out.println("Moving With Car......"); 		
		car.move();		

		Moveable bike = () -> System.out.println("Moving with Bike");
		bike.move();

		Moveable bus = () -> System.out.println("Moving with Bus");
		bus.move();
	}
}
---------------------------------------------------------------------------------
@FunctionalInterface
interface Calculate
{
	 void add(int a, int b, double c);  	
}
public class Lambda2 
{
	public static void main(String[] args) 
	{
	   Calculate calc =   (x, y, z) -> System.out.println(x+y+z);
	   calc.add(12,12,12.78);
	}
}
--------------------------------------------------------------------------------
import java.util.Scanner; 

@FunctionalInterface
interface Length
{
	 int getLength(String str);	
}

public class Lambda3 
{
	public static void main(String[] args)     
	{
		Length l = str -> str.length();	
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.next();
		System.out.println("Your Name length is :"+l.getLength(name));
	}
}
--------------------------------------------------------------------------------
@FunctionalInterface
interface Calculate
{
	int getSquare(int num);	
}

public class Lambda4 
{
	public static void main(String[] args) 
	{
		Calculate c =   x -> x*x;

		System.out.println("Square is :"+c.getSquare(4));
	}
}
------------------------------------------------------------------------
Working with predefined functional interfaces provided by java software people :
------------------------------------------------------------------------
Java software prople has provided a predefined functional interaface called Runnable available in java.lang package, it contains only one abstract method i.e run() so, it is a functional interface.

@FunctionalInterface
public interface Runnable
{
   public abstract void run();
}
------------------------------------------------------------------------
Implementation of predefined Runnable interafce using Lambda :
--------------------------------------------------------------
public class Test
{ 
	public static void main(String []a)
	{
		Runnable r1 = ()-> System.out.println("Run method implemnted!!!");
		r1.run();
    }	
}
------------------------------------------------------------------------
Working with predifined fuctional interfaces which are taking type parameter :
------------------------------------------------------------------------
Type Parameter in Java :
---------------------------
Java software people take this concept from C++ to make our variables are independent of data type which is known as Type Parameter<T>.

Type parameter will accept Wrapper type OR User-defined class type, it will not accept primitive type.

Program on Type Parameter :
---------------------------
package com.ravi.type_parameter;

class Accept<T
>  //T can accept any type Wrapper + User-Defined (No primitive)
{
	private T var;  //var = new Student();

	public Accept(T var) //var = new Student();
	{
		super();
		this.var = var;
	}

	public T getVar() 
	{
		return var;
	}	
}
class Student
{
	@Override
	public String toString() 
	{
		return "Student -> With Type Parameter";
	}
}

public class TypeParameter
{
	public static void main(String[] args) 
	{
		Accept<Integer> intType = new Accept<Integer>(12);
		System.out.println("Integer Object :"+intType.getVar());
		
		Accept<Double> doubleType = new Accept<Double>(12.90);
		System.out.println("Double Object :"+doubleType.getVar());
		
		Accept<Boolean> boolType = new Accept<Boolean>(true);
		System.out.println("Boolean Object :"+boolType.getVar());
		
		Accept<Student> studentType = new Accept<Student>(new Student());
		System.out.println(studentType.getVar());
	}

}

In the above program we can accept only Wrapper type and User-defined class type as a parameter we cannot accept primitive type as a parameter.
------------------------------------------------------------------------
07-11-2023
----------
Working with predefined functional interfaces :
------------------------------------------------------
In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces

1) Predicate<T>   
2) Consumer<T> 
3) Function<T,R>
4) Supplier<T>

Note :-
-------
All these predefined functional interfaces are provided as a part of java.util.function sub package.

Predicate<T> funactional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.
---------------------------------------------------------------------
Program to verify whether a number is even or odd using Predicate.

package com.ravi.predicate_interface;

import java.util.Scanner;
import java.util.function.Predicate;

//Verify a number is even or odd
public class PredicateDemo1 
{
	public static void main(String[] args) 
	{
	   Predicate<Integer> evenOrOdd = num -> num % 2==0;

	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter a Number :");
	   int no = sc.nextInt();
	   
	   boolean test = evenOrOdd.test(no);
	   if(test)
	   {
		   System.out.println(no + " is Even");
	   }
	   else
	   {
		   System.out.println(no + " is Odd");
	   }
	   sc.close();
	}

}
-----------------------------------------------------------------------
Write a program to verify whether a name starts with 'A' or not ?
---------------------------------------------------------------
package com.ravi.predicate_interface;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo2 
{
	public static void main(String[] args) 
	{
	 Predicate<String> startsWith = str -> str.startsWith("A");
	 
	 Scanner sc = new Scanner(System.in);
	 System.out.print("Enter Your Name :");
	 String name = sc.next();
	 
	        boolean test = startsWith.test(name);	
	        
	        if(test)
	        {
	        	System.out.println(name +" starts with A");
	        }
	        else
	        {
	       System.out.println(name +" does not start with A");
	        }
	}
}
----------------------------------------------------------------------
WAP to verify whether a person is eligible 4 voting or not ?
------------------------------------------------------------
package com.ravi.predicate_interface;

import java.util.function.Predicate;

public class PredicateDemo3 {

	public static void main(String[] args) 
	{
		Predicate<Integer> p = age -> age >=18;
		System.out.println("Person is eligible for vote :"+p.test(16));

	}
}
----------------------------------------------------------------------
WAP to verify my name is Ravi or not ?
--------------------------------------
package com.ravi.predicate_interface;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo4 
{
	public static void main(String[] args) 
	{
		Predicate<String> p = str -> str.equals("Ravi");
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter your Name :");
		String name = sc.next();
		System.out.println("Are you Ravi :"+p.test(name));
	}

}
---------------------------------------------------------------------
//Leap Year or Not ?

package com.ravi.predicate_interface;

import java.util.function.Predicate;

public class PredicateDemo5 
{
	public static void main(String[] args) 
	{
		Predicate<Integer> leapOrNot = year -> year %4 ==0;
		System.out.println("leap year ?"+leapOrNot.test(2024));
	}

}
-----------------------------------------------------------------------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() and returns nothing. It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
 }
------------------------------------------------------------------------
//Program on Consumer to accept multiple values :
import java.util.function.*;
public class ConsumerDemo1
{
	public static void main(String [] args)
	{
		 Consumer<Integer> printInt =  x -> System.out.println(x);
         printInt.accept(15);

		 Consumer<String> printString = x -> System.out.println(x);
		 printString.accept("Naresh i Technology");

		 Consumer<Double> printDouble = x -> System.out.println(x);
		 printDouble.accept(78.90);

		  Consumer<Boolean> printBoolean = x -> System.out.println(x);
		 printBoolean.accept(true);

		   Consumer<Character> printChar = x -> System.out.println(x);
		   printChar.accept('A');

		   Consumer<Student> printStudent =  x -> System.out.println(x);
           printStudent.accept(new Student());
	}
}

class Student
{
	@Override
	public String toString()
	{
		return "Consumer Student Object";
	}
}
-------------------------------------------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   R apply(T x);        
 }
-------------------------------------------------------------------------
//Square of the number

package com.ravi.function_interface;

import java.util.Scanner;
import java.util.function.Function;


public class FunctionDemo1 
{
	public static void main(String[] args) 
	{
	Function<Integer,Integer> fn1 = x -> x*x;
	
	Scanner sc = new Scanner(System.in);
	System.out.print("Enter a Number :");
	int no = sc.nextInt();
	
	System.out.println("Square of "+no+" is "+fn1.apply(no));

	}

}
-------------------------------------------------------------------------
//Length of the name + Name starst with particular String or not

package com.ravi.function_interface;

import java.util.function.Function;

public class FunctionDemo2 
{
	public static void main(String[] args) 
	{
		//Finding the length
		Function<String,Integer> fn2 =  str -> str.length();
		System.out.println("Length is :"+fn2.apply("Ravi"));
		
		//My name starts with R or not
		Function<String,Boolean> fn3 = str -> str.startsWith("R");
		System.out.println("Starting with R :"+fn3.apply("Ravi"));
		
	}

}
------------------------------------------------------------------------
08-11-2023
----------
Supplier<T> interface :
---------------------------
It is a predefined functional interface available in java.util.function sub package. It provides an abstract method get() which does not take  any argument but produces/supply a value of type T.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}
--------------------------------------------------------------------------
//Here Supplier get() method is returning Player object
package com.ravi.supplier_interface;

import java.util.function.Supplier;

class Player
{
	int pid;
	String pname;
	public Player(int pid, String pname) {
		super();
		this.pid = pid;
		this.pname = pname;
	}
	@Override
	public String toString() {
		return "Player [pid=" + pid + ", pname=" + pname + "]";
	}
	
	
}

public class SupplierDemo {

	public static void main(String[] args) 
	{
		Supplier<Player> p = ()-> new Player(111, "Virat");
	
		System.out.println(p.get());

	}

}
------------------------------------------------------------------------
//Here Supplier get() method is returning String object
package com.ravi.supplier_demo;

import java.util.function.Supplier;

public class SupplierDemo2 {

	public static void main(String[] args) 
	{
	  Supplier<String> s2 = ()-> 10+20+" Ravi "+40+40;
	  String data = s2.get();
	  System.out.println(data);
	}

}
------------------------------------------------------------------------
//Here Supplier get() method is returning Employee object

2 files :
---------
Employee.java
-------------
package com.ravi.supplier_demo;

public class Employee 
{
  private int employeeId;
  private String employeeName;
  private double employeeSalary;
  
	public Employee(int employeeId, String employeeName, double employeeSalary) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public double getEmployeeSalary() {
		return employeeSalary;
	} 
  
}

SupplierDemo.java
-----------------
package com.ravi.supplier_demo;

import java.util.function.Supplier;

public class SupplierDemo 
{
	public static void main(String[] args) 
	{
		Supplier<Employee> emp =   ()->
				{
			       Employee e1 = new Employee(1, "Ankita", 24000);
			       return e1;
				};
				
				Employee employee = emp.get();
				System.out.println(employee);
	}

}
-------------------------------------------------------------------
Can a functional interface contains the method of Object class?
---------------------------------------------------------------
Yes, Functional interface may contain the method of Object class. The main reason to re-declare Object class method inside functional ineterface to follow the contract.

package com.ravi.functional_interface;

@FunctionalInterface
public interface Callable 
{
   public abstract void call();
   
   public String toString();
   
   public int hashCode();
   
   public boolean equals(Object obj);
   
}

From the avove interface, It is clear that inside a Functional interface we can re-declare the method of Object class.
--------------------------------------------------------------
Can we override Object class methods inside a functional interface as a default method?

No, We cannot override Object class method as a default method inside a functional interface, we can only re-declare as showm in interface below.

package com.ravi.functional_concept;

@FunctionalInterface
public interface Printable 
{
   void print();
   
   public default String show()
   {
	   return "";
   }
   
   public default String toString()
   {
	   return "";
   }
}


--------------------------------------------------------------
Can we write private method inside an inetrafce?

Yes, From java 9 onwards we can also write private static and private non-static methods inside an interface.

These private methods will improve code re-usability inside interfaces.
For example, if two default methods needed to share code, a private method would allow them to do so, but without exposing that private method to itÄºs implementing classes.

Using private methods in interfaces have four rules :

1) private interface method cannot be abstract.
2) private method can be used only inside interface.
3) private static method can be used inside other static and non-static    interface methods.
4) private non-static methods cannot be used inside private static        methods.
-------------------------------------------------------------------------
package com.ravi.supplier_demo;

interface CustomInterface 
{    
    public abstract void method1(); //abstract method
     
    public default void method2() //java 8
    {
        method4();  //private non -static method
        method5();  //private static method
        System.out.println("default method");
    }
     
    public static void method3() //java 8
    {
    	method5(); //static method inside other static method
        System.out.println("static method");
        
    }
     
    private void method4() //java 9
    {
        System.out.println("private non -static method");
    } 
     
    private static void method5() //java9
    {
        System.out.println("private static method");
    } 
}
 
public class PrivateMethod implements CustomInterface {
 
    @Override
    public void method1() {
        System.out.println("abstract method");
    }
     
    public static void main(String[] args){
        CustomInterface instance = new PrivateMethod();
        instance.method1();
        instance.method2();
        CustomInterface.method3();
    }
}
--------------------------------------------------------------------
Can we write main method inside an interface ?
----------------------------------------------
Yes, we can write main method inside an interface from java 8v and it will be executed without class.

public interface Main 
{
	public static void main(String[] args)
	{
	  System.out.println("Main method inside an interface ");	
	}
}
--------------------------------------------------------------------
What is marker interface ?
-------------------------------
An interface which does not contain any method and field is called marker interface. In other words, an empty interface is known as marker interface or tag interface.

It describes run-time type information about objects, so the JVM have additional information about the object. [like object is clonable OR object is serializable]

Example :
----------
public interface Drawable  //Marker interface
{
}

Note :-In java we have Clonable and Serializable are predefined marker interface.
--------------------------------------------------------------------
*What is difference between abstract class and interface ?
------------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final.

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) We can write concrete method inside an abstract class but inside an interface we can't write concrete public method, only abstract , default, static and private methods are allowed.
----------------------------OOPS ENDED--------------------------------


09-11-2023
-----------
Class loader sub system with JVM Architecture :
------------------------------------------------------
The three main components of JVM 

1) class loader sub system

2) Runtime Data Areas

3) Execution engine

class loader sub system internally performs 3 task

a) Loading     b) Linking      c) Initialization   (Diagram 9th NOV)

Loading:
----------
In order to load the required .class file, JVM makes a request to class loader sub system. The class loader sub system follows delegation hierarchy algorithm to load the required .class files from different areas.

To load the required .class file we have 3 different kinds of class loaders.

1) Bootstrap/Primordial class loader

2) Extension/Platform class loader

3) Application/System class loader

Bootstrap/Primordial class Loader :-
---------------------------------
It is responsible to load the required .class file from java API that means all the predfined classes (provided by java software people) .class file will be loaded by Bootstrap class loader.
It is the super class of Extension class loader as well as It has the highest priority among all the class loader.

Extension/Platform  class  Loader :-
--------------------------------------
It is responsible to load the required .class files from ext (extension) folder. Inside the extension folder we have  jar file(Java level zip file) given by some third party or user defined jar file.
It is the super class of Application class loader as well as It has more priority than Application class loader.


Note :- Command to create the jar file 

           jar cf MyJar.jar  FileName.class

Application/System class Loader :-
--------------------------------------
It is responsible to load the required .class file from class path level i.e Environment variable. It has lowest priority as well as It is the sub class of Extension/Platform class loader.

Note :- 
------
If all the class loaders are failed to load the .class file into JVM memory then we will get a Runtime exception i.e java.lang.ClassNotFoundException.
----------------------------------------------------------------------
10-11-2023
-----------
//Write a program in java which shows that our userdefined .class file will be loaded by Application class loader

public class ClassLoaderDemo   
{
	public static void main(String[] args) 
	{
		System.out.println("This ClassLoaderDemo class is loaded by :"+ClassLoaderDemo.class.getClassLoader()); 

		System.out.println("Parent or Super class for Application class loader is  :"+ClassLoaderDemo.class.getClassLoader().getParent());
		
		System.out.println("Parent or Super class for Platform class loader is  :"+ClassLoaderDemo.class.getClassLoader().getParent().getParent()); //null
	}
}
/* getClassLoader() is a predefined method of class called Class available in java.lang package and it's return type is ClassLoader. 

getParent() is a predefined method of ClassLoader class in java, available in java.lang package. It is an abstract class.
*/
----------------------------------------------------------------------
The following program explains that any .class file return type is 
java.lang.Class

package com.ravi.jvm_architecture;

class Customer{}
class Employee{}

public class Loader {

	public static void main(String[] args) 
	{
		Class cls = Customer.class;
		System.out.println(cls.getName());
		
		cls = Employee.class;
		System.out.println(cls.getName());

	}

}
----------------------------------------------------------------------
Linking :
---------
verify :-
-------
It ensures the correctness of the .class files, If any suspicious activity is there in the .class file then It will stop the execution immediately by throwing an exception i.e java.lang.VerifyError.

There is something called ByteCodeVerifier(Component of JVM), responsible to verify the loaded .class file i.e byte code. Due to this verify module JAVA is highly secure language. 

java.lang.VerifyError is the sub class of java.lang.linkageError

---------------------------------------------------------------------
prepare:
---------
It will allocate the memory for all the static data members, here all the static data member will get the default values so if we have static int x = 100;

then for variable x  memory will be allocated and now it will initialize with default value i.e 0.
----------------------------------------------------------------------
Resolve :-
-----------
All the symbolic references will be converted to direct references or actual reference.

javap -verbose  FileName.class

Note :- By using above command we can read the internal details of .class file.
----------------------------------------------------------------------
Initialization :-
-----------------
In Initialization, all the static data member will get their actual (Original) value as well as if any static block is present in the class then the static block will be exceuted here.

static block :-
---------------
It is a very special block in java which will be executed automatically at the time of loading the .class file into JVM memory by class loader sub system.

Example:-

static
{

}

The main purpose of static block to initialize the static data member of the class.

static block will be executed only once because class loading is possible only once in java.

If we have multiple static blocks are present in a class then It will be executed according to order (Top to bottom).

static block will be executed before the main method.

We can't access static field before it is declared otherwise we will get illegal forward reference error but we can initialize in the static block before declaration.

[Initialization is possible but accessing is not possible]
----------------------------------------------------------------------
11-11-2023
----------
//static block
class Foo
{
	Foo()
	{
		System.out.println("No Argument constructor..");
	}

	{
		System.out.println("Instance block..");
	}

	static
	{
		System.out.println("Static block...");
	}
}
public class StaticBlockDemo  
{
	public static void main(String [] args)
	{ 		
		System.out.println("Main Method Executed ");			
	}
}


Note :- In the above program Foo.class file is not loaded into JVM memory so the static block of Foo.class file will not be executed.
---------------------------------------------------------------------
class Test
{
	static int x;

	static
	{
		x = 100;
		System.out.println("x value is :"+x);
	}
	
	static
	{
		x = 200;
		System.out.println("x value is :"+x);
	}

	static 
	{
		x = 300;
		System.out.println("x value is :"+x);
	}

	static
	{
		x = 400;
		System.out.println("x value is :"+x);
	}
}
public class StaticBlockDemo1   
{
	public static void main(String[] args) 
	{
		System.out.println(Test.x);
	}
}

Note -: From the above program it is clear that static blocks are executed according to order i.e top to bottom
--------------------------------------------------------------------
class Foo
{	
	static int x;
    static
	{		
		System.out.println("x value is :"+x);
	}
}

public class StaticBlockDemo2 
{
	public static void main(String[] args) 
	{
		 new Foo();
	}
}

Note :- The program says that static variables are also initialized with default value.
---------------------------------------------------------------------
class Demo
{
	// static blank final variable
	static final  int a;	

	static
	{			
		a = 10; //Initialization is compulsory becuae final blank static 
	}
}	
public class  StaticBlockDemo3
{
	public static void main(String[] args) 
		{		
	         System.out.println("a value is :"+Demo.a);		
	    }
}

static final blank variable, initialization is compulsory before use.
----------------------------------------------------------------------
class  A         
{
	static 
	{
		System.out.println("A");
	}

	 
	{
		System.out.println("B");
	}

	A() 
	{		
		System.out.println("C");
	}
}
class B extends A
{
	static 
	{
		System.out.println("D");
	}

	 
	{
		System.out.println("E");
	}

	B() 
	{		
		System.out.println("F");
	}

}
public class StaticBlockDemo4 
{
	public static void main(String[] args) 
	{
		new B();
	}
}

Note :- The programs Syas 2 things 

  a) Always the super class wil be loaded first then only sub class will be loaded into JVM Memory.
  b) The first two line of any constructor is reserved for super() and
      non-static block i.e instance block.
----------------------------------------------------------------------
//illegal forward reference

class Demo 
{	
        static 
	{   
		i = 10; //valid
		//i = i + 19;             //error
		//System.out.println(i); //error
        }

    static int i;
}

public class StaticBlockDemo5
{

    public static void main(String[] args) 
	{
        System.out.println(Demo.i);
	}
}

Note :- This program says :
         If we declare static block before static variable declaration then inside the static block we can initialize the static variable but we can't access that means in other words we can perform write operation but we cannot perform read operation.
----------------------------------------------------------------------
class Demo 
{
    static 
	{   
		i = 10; //before defining initialization is possible	
    }

    static int i;
}

public class StaticBlockDemo6
{

    public static void main(String[] args) 
	{
		System.out.println(Demo.i);
	}
}

Note :- This program says :
        static variables memory allocation and initialization both are done at prepare phase so inside a static block we can initialize the static data member before declaration.
---------------------------------------------------------------------
Can we execute a Java program without main method ?
---------------------------------------------------------------
 We can't execute a java program without main method, Upto jdk 1.6 it was possible to execute a java program without main method by writing the static block. 
 
 From JDK 1.7 onwards now we can't execute java program without main method because JVM checks the presence of the main method before initializing the class.

Eg:-
class WithoutMain
{
        static
	{
	System.out.println("Hello world");
	System.exit(0);
	}
}
The above program was possible to execute upto JDK 1.6.
----------------------------------------------------------------------
How many ways we can load the .class file into JVM memory :
-----------------------------------------------------------
There are so many ways we can load our .class file into JVM memory, Here we have few example

1) By using Java command 

   class Test
   {
   }

    javac Test.java (Compile the Test.java)
    java Test (Here java command will make a request to load Test.class file 
               into JVM memory)


2) By Using Constructor [Object creation]
   
   class Test
   {
   }
   class ELC
   {
      public static void main(String [] args)
       {  
          new Test(); [Making a request to JVM to load the Test.class file]
       }    
    }


3) By accessing the static data member of the class :
   class Test
   {
      static int x = 100;
   }
   class ELC
   {
      public static void main(String [] args)
       {  
          System.out.println(Test.x); [Making a request to JVM to load the 
                                        Test.class file]
       }    
    }

4) By using Inheritance :

   class Alpha
   {
   }
   class Beta extends Alpha
   {
   }

   class ELC        
   {
      public static void main(String [] args)
       {  
          new Beta(); [Before Beta.class, first of all Alpha.class file will
                       be loaded and then Beta.class file will be loaded]
       }    
    }
  
5) By using Reflection API.

   Class.forName(String className);

----------------------------------------------------------------------
1) By using Java tools 
    javac Test.java 
    java Test [Load the Test.class file into JVM memoy]

 
2) By using Constructor [Object creation].

3) By Calling static variable and static method using class name.

class Demo
{
	static int x = 10;
	static
	{
		System.out.println("Static Block of Demo class Executed!!! :"+x);
	}
}
public class ClassLoading 
{
	public static void main(String[] args) 
	{		
	  System.out.println(Demo.x);	
	}
}
---------------------------------------------------------------------
13-11-2023
-----------
4) By using Inheritance :
-------------------------
By using Inheritance concept, whenever we want to load sub class .class file then first of all super class .class file will be loaded and then only syb class .class file will be loaded.

class A
{
	static
	{
		System.out.println("Static Block of super class A!!");
	}
}
class B extends A 
{
	static
	{
		System.out.println("Static Block of Sub class B!!");
	}
}
class InheritanceLoading 
{
	public static void main(String[] args) 
	{
		 new B();
	}
}
----------------------------------------------------------------------
By Using Reflection API :
--------------------------
In java.lang package, there is a predefined class called Class. This class called Class contains one predefined static method forName(String className) which is used to LOAD THE SPECIFIED .CLASS INTO JVM MEMORY DYNAMICALLY. [In eclipse, class name must be Fully Qualified Name]

forName() method is throwing a checked execption i.e ClassNotFoundException.

This predefined static method forName(String className) returns java.lang.Class itself, the method whose rturn type is same class name
known as Factory Methods.

This Package contains two files :
---------------------------------
Foo.java
---------
package com.ravi.dynamic_class_loading;

public class Foo 
{
  static 
  {
	  System.out.println("Foo class static block");
  }
}


DynamicLoading.java
--------------------
package com.ravi.dynamic_class_loading;

public class DynamicLoading {

	public static void main(String[] args) throws ClassNotFoundException 
	{
	   //In Eclise IDE Fully Qualified class name reqd
	   Class.forName("com.ravi.dynamic_class_loading.Ravi");
	}

}
---------------------------------------------------------------------
* What is the difference java.lang.ClassNotFoundException and java.lang.NoClassDefFoundError.

java.lang.ClassNotFoundException :
----------------------------------
In Java whenever we try to load the .class file dynamically at runtime by using Class.forName() or loadClass() method of ClassLoader class and if the required .class file is not availavle at RUNTIME then it will generate an execption i.e java.lang.ClassNotFoundException

Note :- Class.forName(String className) does not have any concern with
compile time.

Program :
----------
class Foo
{
	static
	{
		System.out.println("static block gets executed...");
	}
}
public class ClassNotFoundExceptionDemo 
{
	public static void main(String[] args) throws ClassNotFoundException
	{
		Class.forName("Player");
	}
}

In the above program java.lang.ClassNotFoundException will be generated because Player.class file is not available at runtime.

java.lang.NoClassDefFoundError :
--------------------------------
In this approach the class name is available at the time of compilation but after compilation the .class file (Message.class) will be deleted by user manually or It was re-located from one package to another package then at the time of execution the required .class file is not available hence we will get java.lang.NoClassDefFoundError.

Plaese notice, class was present at the time of compilation but at runtime the required .class file is not available.


class Message
{
	public void greet()
	{
		System.out.println("Hello Everyone I hope you are fine..");
	}
}
public class NoClassDefFoundErrorDemo 
{
	public static void main(String[] args) 
	{
		Message m = new Message();
		m.greet();
	}
}



//After compilation delete the Message.class file mannually.
---------------------------------------------------------------------
What is the drawback on "new" keyword ?
            OR
How to create the Object for the classes which are coming from the database or from file.
            OR
What is newInstance() method?

"new" keyword is suitable for creating the object for the classes which are available at compilation time or at the time of writing the source code (.java file) but on the other hand it is not suitable for 
the classes are coming from database or some file at runtime dynamically.

In order to create the object for the classes which are coming from the database or file at runtime we need to use newInstance() method available in java.lang.Class. 

class Customer
{

}
class ObjectAtRuntime 
{	
   public static void main(String [] args) throws Exception
   {
         Object obj = Class.forName(args[0]).newInstance();
	 System.out.println(obj.getClass().getName());
   }
}

javac ObjectAtRuntime.java
java ObjectAtRuntime Customer


/* getclass() is the method of Object class and its return type is Class, so we can apply any method of class called Class, getName() is the method of Class class.
*/
----------------------------------------------------------------------
class Customer
{
  public void greet()
	{
	  System.out.println("Hello Batch 24");
	}
}
class ObjectAtRuntime1 
{	
   public static void main(String [] args) throws Exception
   {
     Object obj = Class.forName(args[0]).newInstance();
	 Customer c1 = (Customer) obj;
	 c1.greet();
   }
}

javac ObjectAtRuntime.java
java ObjectAtRuntime Customer
----------------------------------------------------------------------
14-11-2023
-----------
Runtime Data Areas :
--------------------
Once the .class file is loaded successfully in the JVM memory then the content of the class is divided into different memory areas which are as follows :

	a) Method Area
	b) HEAP Area
	c) Stack Area
	d) PC Register
	e) Native Method Stack


a) Method Area :
-------------------
In this area all class level information is available. Actually the .class file is dumpped here hence we have all kinds of information related to class is available like name of the class, name of the immediate super class, package name, method name , variable name, static variable, all method available in that particular class and so on.

This method area returns type java.lang.Class class , this java.lang.Class class object can hold any .class file 
(Class c = AnyClass.class)

There is only one method area per JVM.
----------------------------------------------------------------------
Methods of java.lang.Class :
-----------------------------
1) public String getName() :- It is used to provide the class name 
                              without class keyword.

2) public String getPackageName() :- It is used to provide the package 
                                     name from where the class is belonging.

3) public Method [] getDeclaredMethods() :- It will provide all the 
   declared methods available in the specified class. The return type of this method is Method array.

4) public Field [] getDeclaredFields() :- It will provide all the 
   declared fields(variable static + non static ) available in the specified class. The return type of this method is Field array.

 Note :- Method and Field both are predefined classes available java.lang.reflect package. Both contain getName() method to get the name of the method and name of the field.

This package contains two files :
---------------------------------
Load.java
---------
package com.ravi.method_area;

import java.util.Scanner;

public class Load 
{
  private int x = 10;
  static int y = 20;
  Scanner sc = new Scanner(System.in);
  
  public void m1() {}
  
  public void m2() {}
  
  public void m3() {}
  
  public void m4() {}
  
  public void m5() {}
  
  public void m6() {}
}


ClassDescription.java
----------------------
package com.ravi.method_area;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ClassDescription 
{
	public static void main(String[] args) throws Exception
	{
		Class cls = Class.forName(args[0]);
		
		//Getting Complete information
		System.out.println("Class Name is :"+cls.getName());
		
		System.out.println("Package Name is :"+cls.getPackageName());
		
		System.out.println("Methods Are :");
		Method[] methods = cls.getDeclaredMethods();
		int methodCount = 0;
		for (Method method : methods)
		{
			System.out.println(method.getName());
			methodCount++;
		}
		System.out.println("Total Methods are :"+methodCount);
		
		System.out.println("Fields Are :");
	    Field[] fields = cls.getDeclaredFields();
	    
	    int fieldCount = 0;
	    for(Field field : fields)
	    {
	    	System.out.println(field.getName());
	    	fieldCount++;
	    }
	    System.out.println("Total Fields are :"+fieldCount);
	}
}
----------------------------------------------------------------------
Why static method does not act on instance variable ?
-----------------------------------------------------
All the static data member like static variable, static block, static nested inner class and static method are executed at the time of loading .class file into JVM memory, At the time of execution of these static data member, object is not available and we known instance variables are the part of the object so, we cannot act on instance variable using static area.

Demo.java
----------
public class Demo 
{
	int x = 100;

	public static void main(String[] args) 
	{
		System.out.println("x value is :"+x);
	}
}
--------------------------------------------------------------------
class Test
{
	private int x;

    public Test(int x)
	{
		this.x = x;
	}

	public static void access()
	{
		System.out.println("x value is :"+x);
	}

}
public class StaticTest 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(10);
		Test.access();
	}
}

From the above two programs it is clear that we cannot access instance variables from static area even object is already created.
----------------------------------------------------------------------
HEAP Area :
-----------
In java whenever we create the Object, all object related data like instance variable and instance methods are strored in HEAP Area.
This is the 2nd layer architecture of JVM so from this area we can access the static memeber of the class but vice versa is not possible.

We have only one Heap Area per JVM.
----------------------------------------------------------------------
Stack Area :
------------
In java all the methods are executed as a part of Stack Area. Whenever we call a method then it creates Stack Frame. Each Stack Frame contains 3 parts 
              a) Local variable.
	      b) Frame Data.
	      c) Operand Stack.


We have n number of stack area in one JVM.
----------------------------------------------------------------------
24-11-2023
-----------
Garbage Collector :-
----------------------
In older languages like C++, It is the responsibility of the programmer to allocate the memory as well as to de-allocate the memory otherwise there may be chance of getting OutOfMemoryError.

But in Java a user is not responsible to de-allocate the memory that means memory allocation is the responsibility of user but  memory de-allocation is automatically done by Garbage Collector.

Garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects (The object which does not contain any references).

It is an automatic memory management in java. JVM internally contains a thread called Garbage collector which is daemon thread, It is responsible to delete the unused objects or the objects which are not containing any references in the heap memory.

Note :- GC uses an algorithm mark and sweep to make an un-used objects eligible for Garbage Collection.

The garbage Collector thread is visiting our program at regular interval to delete the unused objects but as a programmer we can call garbge collector explicitly to visit our program by using the following code.

System.gc(); //explicitly calling the garbage collector

gc() is a predefined static method of System class.
--------------------------------------------------------------
There are 3 ways to make an Object eligible for Garbage Collector:
----------------------------------------------------------------
1) Assigning a null literal to reference variable

    Employee e1 = new Employee();
    e1 = null;

 2) Creating an object inside the method

      public void createObject()
      {
          Employee e2 = new Employee();
      }
Note :- Once the method execution is over automatically Object is eligible for Garbage Collector

3) Assigning new object to the Existing reference variable

     Employee e3 = new Employee();

     e3 = new Employee();

HEAP and Stack Diagram :
------------------------

CustomerDemo.java (Diagram 24-NOV-23)
--------------------------------------

class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) //constructor
	{
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val=100;
		Customer c = new Customer("Ravi",2);

        m1(c);
		
		//GC [only one object 3000x is eligible for GC]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust)
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  

//9 5
----------------------------------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2); 

		s1=null;

        //GC [4 objects 1000x, 2000x, 5000x and 6000x are eligible]

		System.out.println(s2.i1);		
	}
    public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}

//20 9
-----------------------------------------------------------------------
25-11-2023
----------
HEAP and STACK diagram for Employee.java
-----------------------------------------
public class Employee
{
	int id=100;
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();

		e1.id=val;

		update(e1);	
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id=500;

        
		switchEmployees(e2,e1);		

		    //GC [2 objects 2000x and 4000x are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)
	 {
        e.id=500;
		e=new Employee();
		e.id=400;
	 }

	 public static void switchEmployees(Employee e1,Employee e2)
	  {
		 int temp=e1.id;
		 e1.id=e2.id; //500
		 e2= new Employee();
		 e2.id=temp;
	  }
   }

//500 500  500
-------------------------------------------------------------------------
HEAP and STACK diagram for Test.java
-------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)  
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; //3000x
		t3.t = t4; //4000x
		t1.t = t2.t; //3000x 
		t2.t = t4.t; //2000x

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
//300  200  400  200
--------------------------------------------------------------------------
HEAP and STACK Diagram for Beta.java
------------------------------------
class Alpha
{
	int val;
	static int sval = 200;
	static Beta b = new Beta();

	Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta  
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2);  

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;

        Alpha fa[] = new Alpha[]{a2, a1};

		return fa;
	}
}

//15 15
--------------------------------------------------------------------------
Runtime Data Areas :
--------------------
  a) Method Area
  b) Heap Area
  c) Stack Area
  d) PC register
  e) Native Method Stack

PC Register :
-------------
It stands for Program counter Register.

In order to hold the current executing instruction of running thread we have separate PC register for each and every thread.

Native Method Stack :
----------------------
Native method means, the java methods which are written by using native languages like C and C++. In order to write native method we need native method library support.

Native method stack will hold the native method information in a separate stack.
--------------------------------------------------------------------------
Execution Engine :
------------------
Interpreter 
------------
In java, JVM is an interpreter which executes the program line by line. JVM (Interpreter) is slow in nature because at the time of execution if we make a mistake at line number 9 then it will throw the execption at line number 9 and after solving the execption again it will start the execution from line number 1 so it is slow in execution that is the reason to boost up the execution java software people has provided JIT compiler.

JIT Compiler :
--------------
It stands for just in time compiler. The main purpose of JIT compiler to boost up the execution so the execution of the program will be completed as soon as possible.

JIT compiler holds the repeated instruction like method signature, variables and make it available to JVM at the time of execution so the overall execution becomes very fast.
--------------------------------------------------------------------------
27-11-2023
----------
Exception Handling :
--------------------
What is an execption ?
----------------------
An execption is a runtime error.

An execption is an abnormal situation or un-expected situation in a noraml execution flow.

An exception encounter due to dependency, if one part of the program is dependent to another part then there might be a chance of getting Exception.

AN EXCEPTION ALSO ENCOUNTER DUE TO WRONG INPUT GIVEN BY THE USER.

Exception Hierarchy :
--------------------
This Exception hierarchy is available in the diagram (Exception_Hierarchy.png)

Criteria for Exception in Java :
---------------------------------
1) java.lang.ArithmeticException

   int x = 10;
   int y = 0;
   int z = x /y; [Dividing a number by zero (int value) then we will get
                  java.lang.ArithmeticException]


2) java.lang.ArrayIndexOutOfBoundsException
    int []arr = {10,20,30};
    System.out.println(arr[3]); [Accessing the index which is out of the 
                                 bound]
   
3) java.lang.NullPointerException
   String str = null;
   System.out.println(str.length()); [calling any method on null literal]


4) java.lang.NumberFormatException
   String str = "Ravi";
   int no = Integer.parseInt(str);
  
 -----------------------------------------------------------------------
 Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.
 -----------------------------------------------------------------------
 Exception is the super class of all the execptions whether it is a predefined exception or user-defined exception in Java.
 -----------------------------------------------------------------------
 WAP that describes that Exception is the super class of all the exceptions we have in java :

 package com.ravi.basic;

public class ExceptionSuper 
{
	public static void main(String[] args) 
	{		
	   Exception e1 = new ArithmeticException("Dividing a number by zero");
	   System.err.println(e1);
	   
	   Exception e2 = new ArrayIndexOutOfBoundsException("Index is out of Bounds");
	   System.err.println(e2);
	}
}
------------------------------------------------------------------------
WAP that describes that whenever an exception encounter in the program then program will be terminated in the middle.

package com.ravi.basic;

import java.util.Scanner;

public class Test 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int result = x /y;  //if y is 0 then program will halt
		System.out.println("Result is :"+result);
		System.out.println("Main method completed!!!");
		sc.close();
   }
}

Note :- In the above program if the value of y will be 0 then our program will halt in the middle, it is called abnormal termination so, JVM is having default exception handler, which will terminate the program and provide the appropriate message.
------------------------------------------------------------------------
In order to work with Exception, Object Oriented Programming has provided the following keywords :

  1) try
  2) catch
  3) finally (try with resources [java 1.7])
  4) throw
  5) throws

-----------------------------------------------------------------------
28-11-2023
-----------
try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement
then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption encounter then TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.

WAP in java to implement try catch 
-----------------------------------
package com.ravi.basic;

import java.util.Scanner;

public class TryDemo {

	public static void main(String[] args)  
	{		
		   System.out.println("Main method started....");	
		   Scanner sc = new Scanner(System.in);		   
		   try
		   {
			   System.out.print("Enter the value of x :");
			   int x = sc.nextInt();
			   
			   System.out.print("Enter the value of y :");
			   int y = sc.nextInt();
			   
			   int result = x /y;
			   
			   System.out.println("Result is :"+result);
			   System.out.println("End of try block");
			    
		   }
		   catch(Exception e)
		   {
			   System.out.println("Inside catch Block");
			   System.err.println(e);
		   }
		   sc.close();
		   System.out.println("Main method ended....");
	}
}

In the above program, even exception encounter but program will be terminated normally.
-----------------------------------------------------------------------
package com.ravi.basic;

public class ThrowException 
{
	public static void main(String[] args) 
	{
		try
		{
		 //System.out.println(10/0); //new ArithmeticException();
			
		  throw	new ArithmeticException();
		   
		}
		catch(Exception e)
		{
			System.out.println("Inside catch");
			System.err.println(e);
		}
	}
}
-----------------------------------------------------------------------
Program that describes we should provide user-friendly message to our client

package com.ravi.basic;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		 System.out.println("Hello Client, Welcome to my application!!");	       
		 Scanner sc = new Scanner(System.in);   
		 try
		         {	    	   
				   System.out.print("Enter the value of x :");
				   int x = sc.nextInt();

				   System.out.print("Enter the value of y :");
				   int y = sc.nextInt();

				   int z = x/y;  
				   System.out.println("z value is :"+z);
				   
		    }
		    catch(Exception e)
		    {
		    	System.err.println("Please don't put zero");
		    }
		 System.out.println("Thank you 4 visiting!!");
		    sc.close();
		    
	}	    
}
-------------------------------------------------------------------------
29-11-2023
----------
Methods of Throwable class :
----------------------------
The Throwable class has provided the following methods to work with Exception.

1) public void printStackTrace() :
   -------------------------------
   By using this method we can get the complete details of an exception
   like, exception name, exception error message, package name, class name, method name, line number where exactly the exception encounter.

2) public String getMessage() :
   ---------------------------
   It is used to provide only the error message.

PrintStackTrace.java
---------------------
package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started...");		
		try
		{
			String x = "Ravi";
			int y = Integer.parseInt(x); 
			System.out.println(y);	
		}
		catch(Exception e)
		{
			e.printStackTrace(); //For complete Exception details
			System.out.println("---------------------------");
			System.err.println(e.getMessage()); //only for Exception message				
		}
		System.out.println("Main method ended...");		

	}

}
-------------------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, NullPointerException and so on) which will handle only one type i.e specific type of exception.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class SpecificException 
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");
		Scanner sc = new Scanner(System.in);
		
		try
		{
			System.out.print("Enter your Roll :");
			int roll = sc.nextInt();
			System.out.println("Your roll Number is :"+roll);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is not in a proper format!!");
			e.printStackTrace();
		}
		
		sc.close();
		System.out.println("Main ended");
	}
}
-------------------------------------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined


While working Integral literal in both the cases i.e Infinity (10/0) and 
Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final variable support to deal with 
Infinity and Undefined.

On the other hand while working with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final variable 
support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = Nan

InfinityFloatingPoint.java
---------------------------
package com.ravi.basic;

public class InfinityFloatingPoint 
{
   public static void main(String[] args) 
   {
	    System.out.println("Main method started");
	   
	    System.out.println(10/0.0);
	    System.out.println(-10/0.0);
	    System.out.println(0/0.0);
	    
	    System.out.println(0/0);
	    System.out.println(10/0);   
	    
		System.out.println("Main method ended");
	}
}
-------------------------------------------------------------------------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.

package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}
-----------------------------------------------------------------------
* Multiple catch block with single try block :
--------------------------------------------
According to industry standard we should write try with multiple catch block so we can provide proper information for each and every exception.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7 this multiple catch block we can also represent by using | symobl.

package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int a=10,b=3,c;
			c=a/b;
			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[5]);
						
		}
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}		
		catch(Exception e1)
		{
		  System.out.println("General");
		}				
		System.out.println("Main Ended...");
	}
}
-----------------------------------------------------------------------
01-12-2023
----------
Multiple catch block using single try with Java 7 using | symbol.

package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "India";
		   System.out.println(str1.toUpperCase());
		   
		   String str2 = "nit";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException | NullPointerException  e)
		{
			e.printStackTrace();
		}

		System.out.println("Main method ended!!");
	}

}
-----------------------------------------------------------------------
finally block :
---------------
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.

//Program with the combination of try and finally
package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		
		try
		{
			System.out.println(10/0);
		}
		finally
		{
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}

//Program with the combination of try-catch and finally
--------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{
		    int []x = new int[-2];	//We can't pass negative size of an array in negative
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}
-----------------------------------------------------------------------
Limitation of finally block :
-----------------------------
The following are the limitations of finally block :

1) User is responsible to close the resources manually.
2) Due to finally block the length of the code will be increased.
3) While using finally block we should declare all our resources 
   outside of the try block otherwise the resourses will become 
   block level variable.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class FinallyLimitation 
{
	public static void main(String[] args) throws Exception 
	{				
		System.out.println("Main method started!!");
		Scanner sc = new Scanner(System.in);
		try
		{			
			System.out.print("Enter Employee Number :");
			int empNo = sc.nextInt();
			System.out.println("Employee Number is :"+empNo);
			
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is not matching");
		}
		finally
		{
			sc.close();
			System.out.println("Finally Ended");
		}
		System.out.println("Main Ended");
	}

}
-----------------------------------------------------------------------
02-12-2023
-----------
try with resources :
--------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 1.7 onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
try(resource1 ; resource2) //Resources and Exception both will be 
{                            //handled
}
catch(Exception e)
{
}

There is a predefined interface available in java.lang package called AutoCloseable which contains predefined abstract method i.e close()
which throws Exception.

There is another predefined interface available in java.io package called Closeable, this Closeable interface is the sub interface for Auto Closeable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}
public interface java.io.Closeable extends java.lang.AutoCloseable
{
}

Whenever we pass any resourse class as part of try with resources then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

try(ResourceClass rc = new ResourceClass())  //This ResourceClass must
{                                              implements either
                                               Closeable or AutoCloseable interface
}                                              so, try block will 
catch(Exception e)                             automatically call the
{                                              close() method.

}

The following program explains how try block is invoking the close() method available in DatabaseResource class and FileResource class. 

This package contains 3 files :
-------------------------------
DatabaseResource.java
---------------------
package com.ravi.try_resource;

public class DatabaseResource implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database Resource closed");
		
	}

}

FileResource.java
-----------------
package com.ravi.try_resource;

import java.io.Closeable;
import java.io.IOException;

public class FileResource implements Closeable
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("File Resource Closed");		
	}

}

TryWithResource.java
---------------------
package com.ravi.try_resource;

public class TryWithResource 
{
	public static void main(String[] args) 
	{
		DatabaseResource dr = new DatabaseResource();
		FileResource fr = new FileResource();
		try(dr; fr)
		{
		   System.out.println(10/0);	
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		System.out.println("Main Method Ended");
	}

}
-----------------------------------------------------------------------
Program on try-with Resources :
-------------------------------
package com.ravi.try_resource;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResourceDemo 
{
	public static void main(String[] args)
	{
		//From java 9 we can write resources outside of try
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{
			System.out.print("Enter your Age :");
			int age = sc.nextInt();
			System.out.println("Your Age is :"+age);
		}
		catch(InputMismatchException e)
		{
			e.printStackTrace();
		}
        System.out.println("Main Method Ended!!!");
	}

}

Here in the above program we need to close Scanner class manually, it 
will be taken care by try with resources.
----------------------------------------------------------------------
Exception propagation :-  [Exception object will shift from callee to caller]
--------------------------
Whenever we call a method and if the the callee method contains any kind of exception and if callee method doesn't contain any kind of exception handling mechanism (try-catch) then JVM will propagate the exception to caller method for handling purpose. This is called Exception Propagation.

If the caller method also does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.

package com.ravi.try_resource;

public class ExceptionPropagationDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!");
		try
		{
			m1();
		}
		catch(ArithmeticException e)
		{
			System.err.println("Handled in Main Method");
		}
		System.out.println("Main method ended!!");
	}	
	public static void m1()
	{
		System.out.println("m1 method started!!");
		m2();
		System.out.println("m1 method ended!!");
	}	
	public static void m2()
	{
		System.out.println(10/0);
	}
}
-----------------------------------------------------------------------
Nested try block :
------------------
If we write a try block inside another try block then it is called Nested try block.

try  //Outer try
{
  statement1;
     try  //Inner try
     {
        statement2;
     }
     catch(Exception e) //Inner catch
     {
     }

}
catch(Exception e) //Outer Catch
{
}

The execution of inner try block depends upon outer try block that means if we have an exception in the Outer try block then inner try block will not be executed.

package com.ravi.basic;

public class NestedTryBlock 
{
	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = "India";
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "Ravi"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
----------------------------------------------------------------------
Writing try-catch inside catch block :
---------------------------------------
We can write try-catch inside catch block but this try-catch block will be exceuted if the catch block will be executed.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithCatchInsideCatch 
{
	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{			
			System.out.print("Enter your Roll number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);			
			
		}	
		catch(InputMismatchException e)
		{
			System.err.println("Provide Valid input!!");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			
		}
	}

}
---------------------------------------------------------------------
05-12-2023
----------
try-catch with return statement
-------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present. After this finally block we cannot write any kind of statement. (Unrechable)

package com.ravi.advanced;
public class ReturnExample
{
    public static void main(String[] args) 
    {    	
       System.out.println(methodReturningValue());        
    }	
	
	@SuppressWarnings("finally")
	public static int methodReturningValue()
    {
        try
        {
            System.out.println("Try block");
            return 10/0;      
        }
        catch (Exception e)
        {
            System.out.println("catch block");         
            return 10/0; 
        }
        finally
        {        	
        	System.out.println("Finally block");        	
        	
        }
       	  
    }
}
-----------------------------------------------------------------------
Initialization of a variable in try and catch :
-----------------------------------------------
A local variable must be initialized inside try block as well as catch block OR at the time of declaration otherwise we will get compilation error if we want to use the local variable.

package com.ravi.basic;

public class VariableInitialization 
{
	public static void main(String[] args) 
	{
       int x;
       try
       {    	  
    	   x = 12;
    	   System.out.println(x);
       }
       catch(Exception e)
       {    	  
    	   x = 12;  //Variable initialization is compulsory here
    	   System.out.println(x);
       }
      
       System.out.println("Main completed!!!");
	}

}
-----------------------------------------------------------------------
* Difference between Checked Exception and Unchecked Exception :
----------------------------------------------------------------
Checked Exception :
----------------------
In java some exceptions are very common exceptions are called Checked excption here compiler takes very much care and wanted the clarity regarding the exception by saying that by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

All the checked exceptions are directly sub class of java.lang.Exception

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException and so on

Unchecked Exception :-
--------------------------
The exceptions which are rarely occurred in java and for these kinds of exception compiler does not take very much care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

All the un-checked exceptions are sub class of RuntimeException

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
-------------------------------------------------------------------------
06-12-2023
-----------
Checked Exception :
------------------
  1) Common Exception
  2) Compiler takes care (Will not compile the code)
  3) Handling is compulsory (try-catch OR throws)
  4) Directly the sub class of java.lang.Exception

Unchecked Exception :
----------------------
  1) Rare Exception
  2) Comiler will not take any care
  3) Handling is not Compulsory
  4) Sub class of RuntimeException

When we should declare the method as throws and when we should write 
--------------------------------------------------------------------
try-catch
---------
When to provide try-catch or declare the method as throws :-
---------------------------------------------------------------------
We should provide try-catch if we want to handle the exception by own as well as if we want to provide user-defined messages to the client but on the other hand we should declare the method as throws when we are not interested to handle the exception and try to send it to the JVM for handling purpose. 

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.
-------------------------------------------------------------------------
Why compiler takes very much care regarding the checked Exception ?
---------------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception "handling is compulsory" because checked Exception depends upon other resources as shown below.

IOException  (we are depending upon System Keyboard )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
-------------------------------------------------------------------------
* What is the difference between throw and throws :
----------------------------------------------------
throw :
--------
In case of predefined exception try block is responsible to create the exception object and throw the exception object to the nearest catch block but it works with predefined exception only.

If a user wants to throw an exception based on his own requirement and specification by using userdefined exception then we should write throw keyword to throw the user defined exception object explicitly. (throw new LowBalanceException())

THROWING THE EXCEPTION OBJCET EXPLICITLY.

throws :- 
---------
In case of checked Exception if a user is not interested to handle the exception and wants  to throw the exception to JVM, wants to skip from the current situation then we should declare the method as throws.
It is mainly used to work with Checked Exception.
-------------------------------------------------------------------------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on

Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException
------------------------------------------------------------------------
Steps to create userdefined exception :
------------------------------------------
In order to create user defined exception we should follow the following steps.

1) A userdefined exception class must extends either Exception(Checked Exception) Or RuntimeException(Unchecked Exception) as a super class.

    a) If our userdefined class extends RuntimeException that menas we are creating UncheckedException.

    b) If our userdefined class extends Exception that menas we are creating checkedException and exception handling is compulsory here.

2) The userdefined class must contain No argument constructor as well as parameterized construtor(in case we want to pass some userdefined message).

   We should take No argument constructor if we don't want to send any message where as we should take parameterized constructor with super keyword if we want to send the message to the super class.

3) We should use throw keyword to throw the Exception object manually
-------------------------------------------------------------------------
Program on user-defined Checked Exception :
-------------------------------------------
package com.ravi.userdefined_exception;

import java.util.Scanner;

@SuppressWarnings("serial")
class InvalidAgeException extends Exception //Checked Exception
{
  	public InvalidAgeException()
  	{  		
  	}
  	
  	public InvalidAgeException(String message)
  	{
  		super(message);
  	}
}

public class CustomCheckedException 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.print("Enter your age :");
			int age = sc.nextInt();
			
			if(age < 18)
			{
				throw new InvalidAgeException("Invalid Age");			
			}
			else
			{
				System.out.println("Welcome to Vote");
			}
		}
		catch(InvalidAgeException e)
		{
			System.err.println(e);
		}
	}
}

Program on user-defined UnChecked Exception :
-------------------------------------------
package com.ravi.userdefined_exception;

import java.util.Scanner;

@SuppressWarnings("serial")
class GreaterMarksException extends RuntimeException
{
	public GreaterMarksException()
	{		
	}
	
	public GreaterMarksException(String message)
	{
		super(message);
	}
}
public class CustomUnChecked 
{
	public static void main(String[] args) 
	{
	   Scanner sc = new Scanner(System.in);
	   try(sc)
	   {
		   System.out.print("Enter the marks :");
		   int marks = sc.nextInt();
		   
		   if(marks > 100)
		   {
			   throw new GreaterMarksException("Invalid Marks");
		   }
		   else
		   {
			   System.out.println("Your Marks is :"+marks);
		   }
	   }
	   catch(GreaterMarksException e)
	   {
		   e.printStackTrace();
	   }
	   
	   System.out.println("Main Completed");
	}

}
------------------------------------------------------------------------
07-12-2023
----------
Some important rules to follow :
---------------------------------
a) If the try block does not throw any checked exception then in the corresponding catch block we can't handle checked exception.It will generate compilation error i.e "exception never thrown from the corresponding try statement"

Example :-

try
{
  //try block is not throwing any checked Exception
}
catch(IOException e) //Error
{

}
-----------------------------------------------------------------------
package com.ravi.method_related_rule;

import java.io.IOException;

public class CatchingCheckedWithoutThrow 
{
	public static void main(String[] args) 
	{
		try
		{
			throw new IOException();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}

	}

}
------------------------------------------------------------------------
b) If the try block does not throw any exception then in the corresponding catch block we can write Exception, Throwable because both are the super classes for all types of Exception whether it is checked or unchecked.

package com.ravi.method_related_rule;

import java.io.IOException;
import java.sql.SQLException;

public class CatchingWithSuperClass 
{
	public static void main(String[] args) 
	{
		try
		{
			//throw new IOException();
		}
		catch(Exception e)
		{
          e.printStackTrace();			
		}

	}

}
------------------------------------------------------------------------
c) At the time of method overriding if the super class method does 
   not reporting or throwing checked exception then the overridden method of sub class not allowed to throw checked exception. otherwise it will generate compilation error.(Sub class method can throws un-checked Exception)

   package com.ravi.method_related_rule;
class Super
{
	public void show()  
	{
		System.out.println("Super class method not throwing checked Exception");
	}
}
class Sub extends Super
{
	@Override
	public void show()  //throws java.io.IOException
	{
		System.out.println("Sub class method should not throw checked Exception");
	}
}

public class MethodOverridingWithChecked {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
------------------------------------------------------------------------
d) If the super class method declare with throws keyword to throw a checked exception, then at the time of method overriding, sub class method may or may not use throws keyword.
               If the Overridden method is also using throws
 keyword to throw checked exception then it must be either same exception class or sub class, it should not be super class as well as we can't add more exceptions in the overridden method.

package com.ravi.method_related_rule;

import java.io.FileNotFoundException;
import java.io.IOException;

class Base
{
	public void show() throws IOException
	{
		System.out.println("Super class method ");
	}
}
class Derived extends Base
{
	//throws is applicable but must be equal or sub class
	public void show() throws FileNotFoundException
	{
		System.out.println("Sub class method ");
	}
}

public class MethodOverridingWithThrows 
{
	public static void main(String[] args) 
	{
	  System.out.println("Overridden method may or may not throw checked exception but if it is throwing then must be same or sub class");	
	}

}
------------------------------------------------------------------------
package com.ravi.method_related_rule;

class Parent
{
	public void m1() throws InterruptedException
	{
		System.out.println("Parent class m1 method");
	}
}

class Child extends Parent
{
	public void m1() 
	{
	         //super.m1();	    //error becoz no protection
		System.out.println("Child class m1 method");
	}
}

public class CallingSuperClassMethodWithThrows {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

Note :- In the above program we are calling super class method which is throwing a checked Exception but the caller method does not have any protection so compilation error hence provide either try-catch or declare the method as throws. (Same will not be applicable for Un checked Exception)
----------------------------------------------------------------------
package com.ravi.method_related_rule;

import java.io.IOException;

class Parent1
{
	public void m1() throws IOException
	{
		System.out.println("Parent class m1 method");
	}
}

class Child1 extends Parent1
{
	public void m1() throws IOException 
	{
	    super.m1();	
		System.out.println("Child class m1 method");
	}
}


public class CallingSuperClassMethodWithThrows1 {

	public static void main(String[] args) 
	{
		System.out.println("Main");

	}

}

Here we are calling the super class method by declaring the method as 
throws.
------------------------------------------------------------------------

package com.ravi.method_related_rule;

import java.util.Scanner;

class Parent2
{
	public void m1() throws InterruptedException
	{
		System.out.println("Parent class m1 method");
	}
}

class Child2 extends Parent2
{
	
	public void m1() 
	{
	    try
	    {
	    	super.m1();
	    }
	    catch(InterruptedException e)
	    {
	    	e.printStackTrace();
	    }
	}
}
public class CallingSuperClassMethodWithThrows2 {

	public static void main(String[] args) 
	{
		System.out.println("main");

	}
}

So the Conclusion is, if we are calling any method and that method is throwing any checked exception then the caller method must have either try-catch or throws (Protection is reqd).
------------------------------------------------------------------------
Input Output in java :
-----------------------
In order to work with input and output concept, java software people has provided a separate package called java.io package.

By using this java.io package we can read the data from the user, creating file, reading/writing the data from the file and so on.

How to take the input from the user using java.io package :
------------------------------------------------------------
Scanner class is available from java 1.5 onwards but before 1.5, In order to read the data we were using the following two classes which are available in java.io package.

1) DataInputStream (Deprecated)
2) BufferedReader

How to create the object :
--------------------------
DataInputStream :
-----------------
DataInputStream d = new DataInputStream(System.in);

BufferedRedaer :
----------------
It provides more faster technique because it internally stores the data in a buffer and it is always recomended to read the data from the buffer.

InputStreamReader isr = new InputStreamReader(System.in);
BufferedReader br = new BufferedReader(isr);
                       OR
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Working with Methods :
----------------------
1) public int read() :- It is used to read a single character from  
                        the source and return the UNICODE value of
			the character. 
			If the data is not available from the source then it will return -1.


2) public String readLine() :- It is used to read multiple characters
                               or complete line from the source. The
			       return type of this method is String.

Program to read name from the keyboard :
-----------------------------------------
package com.ravi.input_data;

import java.io.DataInputStream;

public class ReadName 
{
	@SuppressWarnings("deprecation")
	public static void main(String[] args) throws Exception
	{
		DataInputStream dis = new DataInputStream(System.in);
		System.out.print("Enter your Name :");
	    String name = dis.readLine();
	    System.out.println("Your Name is :"+name);
	                 

	}
}
-----------------------------------------------------------------------
Program to read age from the keyboard :
package com.ravi.input_data;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ReadAge 
{
	
	public static void main(String[] args) throws Exception
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		System.out.print("Enter your Age :");
		int age = Integer.parseInt(br.readLine());
		System.out.println("Age is :"+age);

	}

}
-----------------------------------------------------------------------
Program to read the salary from the keyboard :
----------------------------------------------
package com.ravi.input_data;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ReadSalary {

	public static void main(String[] args)
	{
		var br = new BufferedReader(new InputStreamReader(System.in));
		try(br)
		{			
			System.out.print("Enter your Salary :");
			double sal = Double.parseDouble(br.readLine());
			System.out.println("Salary is :"+sal);
			
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}

	}

}
-----------------------------------------------------------------------
Program to read the character (gender) from the keyboard :
-----------------------------------------------------------
package com.ravi.input_data;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ReadGender {

	public static void main(String[] args)
	{
		var br = new BufferedReader(new InputStreamReader(System.in));
		try(br)
		{			
			System.out.print("Enter your Gender :");
			char gender = (char) br.read();
			System.out.println("Your Gender is :"+gender);
			
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}

	}

}
-----------------------------------------------------------------------
Program to read the Employee Data :
-----------------------------------
package com.ravi.input_data;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class EmployeeData 
{
	public static void main(String[] args) throws Exception
	{
		var br = new BufferedReader(new InputStreamReader(System.in));
		System.out.print("Enter Employee Id :");
		int id = Integer.parseInt(br.readLine());
		
		System.out.print("Enter Employee Gender :");
		char gen = br.readLine().charAt(0); //Here there will be  buffer problem if we use read() method.
		
		System.out.print("Enter Employee Name :");
		String name = br.readLine();
		
		System.out.println("Employee Data :");
		System.out.println("Id is :"+id);
		System.out.println("Gender is :"+gen);
		System.out.println("Name is :"+name);
	}
}
------------------------------------------------------------------------
File Handling :
---------------
What is the need of File Handling ?
-----------------------------------
 As we know variables are used to store some meaningful value in our program but once the execution of the program is over, now we can't get those values so to hold those values permanently in our memory we use files.

Files are stored in the secondary storage devices so, we can use/read the data stored in the file anytime according to our requirement. 

In order to work with File system java software people has provided number of predefined classes like File, FileInputStream, FileOutputStream and so on. All these classes are available in java.io package. We can read and write the data in the form of Stream.

-----------------------------------------------------------------
Streams in java :
--------------------
A Stream is nothing but flow of data or flow of characters to both the end.
Stream is divided into two categories

1) byte oriented Stream :- 
    ------------------------
It used to handle characters, images, audio and video file in binary format.  

2) character oriented Stream :-
--------------------------------
It is used to handle the data in the form of characters or text.

Now byte oriented or binary Stream can be categorized as "input stream" and "output stream". input streams are used to read or receive the data where as output streams are used to write or send the data.

Again Character oriented Stream is divided into Reader and Writer. Reader is used to read() the data from the file where as Writer is used to write the data to the file.

All Streams are represented by classes in java.io package. 

InputStream is the super class for all kind of input operation where as OutputStream is the super class for all kind of output Operation for byte oriented stream.

Where as Reader is the super class for all kind reading operation where as Writer is the super class for all kind of writing operation in character oriented Stream.
---------------------------------------------------------------------
11-12-2023
----------
File :-
-----
It is a predefined class in java.io package through which we can create file and directory. By using this class we can verify whether the file is existing or not.

File f = new File("abc.txt");

The above statement will not create any file, It actually create the file object and perform one of the following two task.
   a) If abc.txt does not exist, It will not create it
   b) if abc.txt does exist, the new file object will be refer to the referenec variable f

Now if the file does not exist and to create the file we should use createNewFile() method as shown below.

File f = new File("Hello.txt");
      f.createNewFile();

File class has also provided a method called exists() through which we can verify the corresponding file is available or not. The return type of this method is boolean.

Note :- The return type of both the methods i.e exists() and createNewFile() are boolean.

File class has also a predefined method called getName(), to get the name of the file.
---------------------------------------------------------------
//Create a file and verify file is existing or not?
import java.io.*;  
public class File0 
	{
		public static void main(String[] args) 
		{
			try 
				{
					File f = new File("C:\\new\\India.txt");

                    if(f.exists())
					{
						System.out.println("File is existing");
					}
					else
					{
						System.out.println("File is not existing");
					}

					if (f.createNewFile())
					   {
						 System.out.println("File created: " + f.getName());
                       }
					   else  
						{
                             System.out.println("File is already existing....");
                         }								  
                  }
				  catch (IOException e)
                 {
					System.err.println(e);
				} 
		}
}

H.W :- With the help of File class create directory.
----------------------------------------------------------------------
FileOutputStream : (Creating the file + Writing the data to the file)
----------------------------------------------------------------------
It is a predefined class available in java.io package. The main purpose of this class to create a new file and write the data to the file. 

Whenever we want to write the data into the file using FileOutputStream class then data must be available into the form of byte because It is byte-oriented class.

Note :- String class has provided a method called getBytes() through which we can read the String data in byte format and the return type of this method is byte[].(byte array)

Eg:-
		String x = "India is Great";
		byte b [] = x.getBytes();

Note :- try with resources are used to automatically close our resources.
-----------------------------------------------------------------------
//Creating and writing the data to the file

import java.io.*;
public class File1
{
     public static void main(String args[]) throws IOException
     {
		var fout = new FileOutputStream("C:\\new\\Hyderabad.txt");
        try(fout)
         {
         String s = "Hyderabad is a nice city";
		 byte b[] = s.getBytes();

		 fout.write(b);

		 System.out.println("Success....");
		 }
		 catch(Exception e)
		 {
			 e.printStackTrace();
		 }
     }
}
----------------------------------------------------------------------
In binary Stream, whenever we want to write the data, the data must be available in byte format, If we want to print the data
on the console(Monitor) the data must be converted into char.
---------------------------------------------------------------
12-12-2023
-----------
FileInputStream :-
-----------------
It is a predefined class available in java.io package. It is used to read the file data/content. If we want to print the file data in console then data must be available in char format.

//Reading tha data from the file
import java.io.*;
public class File2
{
     public static void main(String s[]) throws IOException
     {         
		var fin = new FileInputStream("C:\\new\\Hyderabad.txt");

		 try(fin)
		 {
			 int i = 0;
             while(true)
			 {
				 i = fin.read();
				 if(i==-1)
					 break;
				 System.out.print((char)i);
			 }

		 }
		 catch(Exception e)
		 {
			 System.out.println(e);
		 }
		 System.out.println();
     }
}
----------------------------------------------------------------------
//wap in java to read the data from one file and to write the data to another file.
import java.io.*;
class File3
{
     public static void main(String s[]) throws IOException
     {  
	    //Outside of try (Java 9 enhancement in try with resource)

	   var fin = new FileInputStream("File2.java");
	   
	   var fout = new FileOutputStream("C:\\new\\Batch25.txt");

	   try(fin; fout)
		 {
         while(true)
		 {
		     int i = fin.read();
			 if(i==-1) break;
			 System.out.print((char)i);
			 fout.write((byte)i);
		 }      
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     }
}
----------------------------------------------------------------------
Limitation of FileInputStream class :
-------------------------------------
As we know FileInputStream class is used to read the content from the file but it can read the data from a single file only that means if we want to read the data from two files at the same time then we should use a separate Stream called SequenceInputStream.

SequenceInputStream :
-------------------------
It is a predefined class available in java.io package. This class is used to read the data from two files at the same time.

//Proram to read the data from two files at the same time
import java.io.*;
public class File4
{
     public static void main(String args[]) throws IOException
     {
         var f1 = new FileInputStream("File1.java");
         var f2 = new FileInputStream("File2.java");

         var s = new SequenceInputStream(f1,f2);

		 try(f1; f2; s)
		 {
         int i;
         while(true)
		 {
			  i = s.read();
			   if(i==-1)
				  break;
			  System.out.print((char)i);		 
		 }     
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     } 
}
-----------------------------------------------------------------------
//Reading the data from two files and writing the data to a single file
import java.io.*;
public class File5
{
	public static void main(String x[]) throws IOException
	{
		   var f1 = new FileInputStream("File3.java");
           var f2 = new FileInputStream("File4.java");

           var fout = new FileOutputStream("C:\\new\\FileData.txt");

           var s = new SequenceInputStream(f1,f2);

           int i;
		   try(f1; f2; fout; s)
		   {
           while(true)
           {
			   i = s.read();
			   if(i==-1)
				    break;
               System.out.print((char)i);
               fout.write((byte)i);
           }
		   }
		   catch(IOException e)
		   {
			   e.printStackTrace();
		   }
		   System.out.println("File Created Successfully");
     }
}
---------------------------------------------------------------------

Limitation of FileOutputStream :-
-----------------------------------
It is used to write the data to a single file only. It is not suitable if we want to write the data more then one file at a time. In order to write the data more than one file we should use a seperate Stream called ByteArrayOutputStream.

ByteArrayOutputStream :-
---------------------------
It is a predefined class available in java.io package. By using this class we can write the data to multiple files. ByteArrayOutputStream class provides a method called writeTo(), through which we can write the data to multiple files.

//Program to write the data on multiple files.
import java.io.*;
public class File6
{
     public static void main(String args[]) throws IOException
     {
			var fin = new FileInputStream("File1.java");

			var f1 = new FileOutputStream("C:\\new\\a.txt");  
			var f2 = new FileOutputStream("C:\\new\\b.txt");
			var f3 = new FileOutputStream("C:\\new\\c.txt"); 
			
			var bout = new ByteArrayOutputStream(); 

			try(fin; f1; f2; f3; bout)
		    {
             int i;
			while((i = fin.read()) != -1)
            {
               bout.write((byte)i); //writing tha data to ByteArrayOutputStream
            }

           bout.writeTo(f1);
           bout.writeTo(f2);
		   bout.writeTo(f3);
		   
           bout.flush();  //clear the buffer for reusing of ByteArrayOutputStream
           System.out.println("Success");
			}
			catch(IOException e)
		    {
				e.printStackTrace();
		    }
     }
}
----------------------------------------------------------------------
//Working with images
import java.io.*;
public class File7 
{
	public static void main(String[] args) throws IOException
	{
		 var fin = new FileInputStream("C:\\new\\image\\abc.png");

         var f1 = new FileOutputStream("C:\\new\\image\\a.png");
         var f2 = new FileOutputStream("C:\\new\\image\\b.png");
		 var f3 = new FileOutputStream("C:\\new\\image\\c.png");

         var bout = new ByteArrayOutputStream();

         try(fin; f1; f2; f3; bout)
		 {
         int i;
         while((i = fin.read()) != -1)
         {
               bout.write((byte)i);
         }
         bout.writeTo(f1);
         bout.writeTo(f2);
		 bout.writeTo(f3);
         System.out.println("success...");
		 bout.flush();
         }
		 catch(IOException e)
		{
			 e.printStackTrace();
		}
	}
}
----------------------------------------------------------------------
BufferedOutputStream :-
--------------------------
It is a predefined class available in java.io package.

Whenever we use the class FileOutputStream the data will be available on the Stream but not in the buffer so there may be chance of miss memory management, It is always preferable that the data should be available in the buffer.

By using this BufferedOutputStrean now the data is in the buffer so the execution will become more faster.

//Program to put the data in the buffer for fast execution
import java.io.*;
class File8
{
      public static void main(String args[]) throws IOException
      {
        var fout = new FileOutputStream("C:\\new\\Hyderabad.txt");

           var bout = new BufferedOutputStream(fout);
          
		   try(fout ; bout)
		   {
           String s = "Hyderabad is a nice city";
           byte b[] = s.getBytes();
           bout.write(b);
		   System.out.print("success..."); 
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }
      }
}
-----------------------------------------------------------------------
BufferedInputStream :-
-------------------------
It is a predefined class available in java.io package. Whenever we use FileInputStream to read the data/content from the file the data will be available on the Stream but not in the buffer so there may be a chance of miss memory management so we should take the data into the buffer by using BufferedInputStream class so overall the execution will become faster.

//BufferedInputStream
import java.io.*;
public class File9
{
      public static void main(String args[]) throws IOException
      {
           var fin = new FileInputStream("File1.java");
           var bin = new BufferedInputStream(fin);

		   try(fin ; bin)
		   {
           int i;
           while((i = bin.read()) != -1)
           {
                System.out.print((char)i); 
           }
           }
		   catch(IOException e)
		  {
			   e.printStackTrace();
		  }
		  System.out.println();
      }
}
-----------------------------------------------------------------------
Writing and Reading the primitive data to the files :-  
----------------------------------------------------------
It is possible to write the primitive data(byte,short,int, long, float, double, char and boolean) to the file. 

In order to write primitive data to the file we should use a predefined class available in java.io package called DataOutputStream. 

It provides various methods like writeByte(), writeShort(), writeInt() and so on to write the data to the file.

If we want to read the primitive data from the file we can use a predefined class available in java.io package called DataInputStream, this class provides various methods like readByte(), readShort(), readInt() and so on.

Note :- For writing String into a file we have writeBytes() and to read the String data from the file we have readLine() method.

[DataInputStream class readLine() method is deprecated now, so compilation warning]
-----------------------------------------------------------------------

//DataOutputStream and DataInputStream
import java.io.*;
public class File10
{
      public static void main(String args[]) throws IOException
      {
		   var fout = new FileOutputStream("C:\\new\\Primitive.txt");
          var dout = new DataOutputStream(fout);

		  try(fout ; dout)
		  {
          dout.writeBoolean(true);
          dout.writeChar('A');
          dout.writeByte(Byte.MAX_VALUE);
          dout.writeShort(Short.MAX_VALUE);
          dout.writeInt(Integer.MAX_VALUE); 
          dout.writeLong(Long.MAX_VALUE);
          dout.writeFloat(Float.MAX_VALUE); 
          dout.writeDouble(Math.PI);//PI is a final static variable
		  dout.writeBytes("Hello India...");
          dout.flush();//For reuse purpose
          }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }

		  System.out.println("Reading the Primitive data from the file!!!");
          
		  var fin = new FileInputStream("C:\\new\\Primitive.txt");
          var din = new DataInputStream(fin);
		  try(fin ; din)
		  {
          boolean f = din.readBoolean();
          char c = din.readChar();
          byte b = din.readByte();
          short s = din.readShort();
          int i = din.readInt();
          long l = din.readLong();
          float ft = din.readFloat();
          double d = din.readDouble();
		   String x=  din.readLine();//for reading String (deprecated)

          System.out.println(f +"\n"+c+"\n"+b+"\n"+s+"\n"+i+"\n"+l+"\n"+ft+"\n"+d+"\n"+x);
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }

      }
}
-------------------------------------------------------------------------
IQ :
----

* Serialization and De-serialization :
---------------------------------------
It is a technique through which we can store the object data in a file. Storing the object data into a file is called Serialization on the other hand Reading the object data from a file is called De-serialization.

In order to perform serialization, a class must implements Serializable interfcae, predefined marker interface in java.io package.

Java.io package has also provided a predfined class called ObjectOutputStream to perform serialization i.e writing Object data to a file using writeObject() method.

where as ObjectInputStream is also a predefined class available in java.io package through which we can read the Object data from a file using readObject(). The return type of readObject() is Object.

While reading the object data from the file, if the object is not available then it will throw an execption java.io.EOFException.
----------------------------------------------------------------------
3 files :
---------
package com.ravi.ser_der;

import java.io.Serializable;
import java.util.Scanner;

public class Customer implements Serializable 
{
  private int customerId;
  private String customerName;
  private double customerBill;
  
	public Customer(int customerId, String customerName, double customerBill) {
		super();
		this.customerId = customerId;
		this.customerName = customerName;
		this.customerBill = customerBill;
	}

	@Override
	public String toString() {
		return "Customer [customerId=" + customerId + ", customerName=" + customerName + ", customerBill="
				+ customerBill + "]";
	}
  
    public static Customer getCustomerObject()
    {
    	Scanner sc = new Scanner(System.in);
    	System.out.print("Enter Customer Id :");
    	int cid = sc.nextInt();
    	
    	System.out.print("Enter Customer Name :");
    	String cname = sc.nextLine();
    	cname = sc.nextLine();
    	
    	System.out.print("Enter Customer Bill :");
    	double bill = sc.nextDouble();
    	
    	Customer c1 = new Customer(cid, cname, bill);
    	
    	return c1;
    }
  
}

StoringCustomerObject.java
--------------------------

package com.ravi.ser_der;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Scanner;

public class StoringCustomerObject {

	public static void main(String[] args) throws IOException
	{
	   FileOutputStream fout = new FileOutputStream("C:\\new\\Cust.txt");
	   ObjectOutputStream oos = new ObjectOutputStream(fout);
       Scanner sc = new Scanner(System.in);
       System.out.print("How many Objects :");
       int no = sc.nextInt();
       
       try(sc; oos; fout)
       {
    	   
    	   for(int i=1; i<=no; i++)
    	   {
    		  Customer object = Customer.getCustomerObject();
    		  oos.writeObject(object);
    	   }
       }
       catch(Exception e)
       {
    	  System.err.println("JVM does not have information :"+e); 
       }
       System.out.println("Data Stored Successfully");
	}

}

RetrievingCustomerObject.java
----------------------------
package com.ravi.ser_der;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class RetrievingCustomerObject 
{
	public static void main(String[] args) throws IOException
	{
		FileInputStream fin = new FileInputStream("C:\\new\\Cust.txt");
		ObjectInputStream ois = new ObjectInputStream(fin);
		
		try(fin; ois)
		{
			 Customer c1;
			 while((c1 = (Customer)ois.readObject())!=null)
			 {
				 System.out.println(c1);
			 }			 
		}
		catch(EOFException e)
		{
			System.err.println("File Ended :"+e);
		}
		catch(Exception e)
		{
			System.err.println("General Exception");
		}

	}

}

transient keyword :
-------------------
If we want that some of our field (variable) will not serialized then we should declare that variables with transient keyword so, we will get the defualt value for the variables.

public class Player
{
   private transient int playerId;
   private transient String playerName;
}

Now if we perform serialization operation on Player object then for playerId we will get 0 and for playerName we will get null.
----------------------------------------------------------------------
H/W Perform Serialization and De-serialization on Product class
----------------------------------------------------------------------
Working With Character Oriented Stream :
-------------------------------------------------
FileWriter class :
------------------
It is a predefined class available in java.io package, Using this class we can directly write String (collection of characters) to the file.

Actually It is a character oriented Stream where as if we work with FileOutputStream class, It is byte oriented Stream.
--------------------------------------------------------------

//FileWriter
import java.io.*;
public class File11
{
    public static void main(String args[]) throws IOException
    {
         var fw = new FileWriter("C:\\new\\HelloIndia.txt");
		 var bw = new  BufferedWriter(fw);

		 try(fw; bw)
		 {
         bw.write("It is in Asia");
         System.out.println("Success....");
		 }
		 catch(IOException e)
		  {
			  e.printStackTrace();
		  }
    }
}
-----------------------------------------------------------------------
//FileWriter
import java.io.*;
class File12
{
    public static void main(String args[]) throws IOException
    {
		var fw = new FileWriter("C:\\new\\Data.txt");
		var bw = new  BufferedWriter(fw);

        try(fw;bw)
		{        
		 char c[ ] =  {'H','E','L','L','O', ' ',' ','W','O','R','L','D'};
		 
         bw.write(c);
         System.out.println("Success....");
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
    }
}
------------------------------------------------------------------------
FileReader class :
--------------------
It is a predefined class available in java.io package, It is a character oriented Stream. The main purpose of this class to read the data in the character format directly from the file.

//FileReader
import java.io.*;
public class File13
{
    public static void main(String args[]) throws IOException
    {
         var fr = new FileReader(args[0]); //Command Line Arg
		 var br = new BufferedReader(fr);
		 try(fr ; br)
		 {
         while(true)
         {
              int i = br.read();
              if(i == -1)
                   break;
              System.out.print((char)i);
         }
		 }
		 catch(IOException e)
		 {
			  e.printStackTrace();
		 }         
    }
}
-----------------------------------------------------------------------
import java.io.*;
public class File14
{
  public static void main(String[] args) throws IOException
	{
       var fr = new FileReader("C:\\new\\abc.png");
	   var  fw = new FileWriter("C:\\new\\MyPic.png");
	   
		try(fr;fw)
		{
		     int i;
		    while((i=fr.read())!= -1)
			{
				fw.write(i);
			}
		}
		catch(Exception e)
		{
		}
    }
}

Note :- Here we are trying to write the image file using FileWriter class which is not possible because image internally contains binary data and FileWriter is used to write character Stream.
---------------------------------------------------------------------
PrintWriter :
--------------
It is a predefined class available in java.io package. The main purpose of this class to write the primitive data into text format.

Methods :
-----------
printf() :- It is a predefined method of PrintWriter class which takes two parameter 
a) Specification of the data so we can print the data according to specification(Formatted String)
b) Parameter to print the actual data.

//PrintWriter 
import java.io.*;
public class File15
{
  public static void main(String[] args) throws IOException
	{
	  PrintWriter writeData = new PrintWriter("C:\\new\\Roll.txt");

     try(writeData)
	 {      
      int roll = 15;
      //Writing primitive data into text format
      writeData.printf("My roll number is : %d ", roll);    
    }
    catch(Exception e) 
	{
      e.printStackTrace();
    }
  }
}
-------------------------------------------------------------------
How to append the data in the exiusting file :
-----------------------------------------------
By default by using FileWriter or FileOutputStream, both will create a new file so my existing data will not be available so, if we want to append the new data in the existing file then we nned to write the following code 

FileWriter fw = new FileWriter("path of the file", true);

The 2nd parameter true will provide the facility to write new data in the existing file.

import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;

public class File16
{
    public static void main(String[] args) throws IOException
	{
        var filename = "C:\\new\\append.txt"; 
		//wants to write the data in the existing file
		var fileWriter = new FileWriter(filename, true);
        var bufferedWriter = new BufferedWriter(fileWriter);

        try(fileWriter;bufferedWriter)
		{            
           
            // Append text to the file
            String textToAppend = "My Name is Raj";
            bufferedWriter.write(textToAppend);
            
			//Moving the cursor to the next line
            bufferedWriter.newLine();

            textToAppend = "I lives in hyderabad";
            bufferedWriter.write(textToAppend);
         
            
            System.out.println("Text appended successfully to the file.");
        } 
		catch (IOException e) 
		{
            System.out.println("An error occurred while appending the text to the file: " + e.getMessage());
        }
    }
}
-------------------------------------------------------------------
String Handling :
------------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is a collection of alpha-numeric  character.

How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};

-------------------------------------------------------------------
Immutability in String (Diagram 14-DEC-23)
-------------------------------------------
In java Strings Objects are immutable means unchanged so, whenever we create a String object in java it can't be modifiable.

Strings literals are created in a very special memory of HEAP called String Constant Pool(SCP) and it is not eligible for garbage collection.

String once created can't be modifiable.
------------------------------------------------------------------
Facts about String and memory :-
--------------------------------------
In java Whenever we create a new String object by using String literal, first of all JVM will verify whether the String we want to create is pre-existing (already available ) in the String constant pool or not.

If the String is pre-existing (already available) in the String Constant pool then JVM will not create any new String object, the same old existing String object would be refer by new reference variable as shown in the diagram(14-DEC)

Note :- In SCP area we can't have duplicate String Object.
-------------------------------------------------------------------
*Why Strings are immutable :
----------------------------
As we know a String object in the String constant pool can be refer by multiple reference variables, if any of the reference variable will modify the String Object value then it would be very difficult for the another reference variables pointing to same String object to get the original value, what they have defined earlier as shown in the diagram.(09-SEP)
That is the reason Strings are immutable in java 
-------------------------------------------------------------------
15-12-2023
----------
WAP in Java that describes String objects created by using String literals are not eligible for Garbage Collector.


public class StringGCEligibility 
{
	public static void main(String[] args) throws InterruptedException 
	{
		String str1 = "india";
		System.out.println(str1.hashCode());
		
		str1 = null;
		//calling the GC Explicitly
		System.gc();
		System.out.println("Main is waiting for 5 Sec..");
		Thread.sleep(5000);
        System.out.println("Main thread wake up..");
        
        String str2 = "india";
		System.out.println(str2.hashCode());

	}
}
-----------------------------------------------------------------------
What is the difference bwteen the following two statements
--------------------------------------------------------------------

String x = "Naresh";   [Creating String by Literal]

String y = new String("Hyderabad"); [Creating String Object by new keyword]

-----------------------------------------------------------------------------------------
String x = "Naresh"; 

It will create one String object and one reference variable and String object will be created in the String constant pool.
-------------------------------------------------------------------
String y = new String("Hyderabad");

It will create two String objects one is inside the heap memory(non SCP area) which will be reffered by y reference variable and the same String object will be placed in the String constant pool if it is not available there.
Hence two String Objects and one reference variable will be created.
(15 DEC)

Note :- IF WE ARE CREATING THE STRING BY USING LITERAL OR BY USING NEW KEYWORD, STRING OBJECTS ARE NOT ELIGIBLE 4 GC AS WELL NOT ELIGIBLE FOR MODIFICATION.
-----------------------------------------------------------------------
Note :- JVM internally uses intern process to place the String object created by using new keyword inside SCP area[interning process]

package com.ravi.cases;

public class InternProcess 
{
	public static void main(String[] args) 
	{
	  String str1 = "india";
	  String str2 = new String("india");
	  
	  System.out.println(str1==str2);//false
	  String str3 =  str2.intern();  
	  
	  System.out.println(str1==str2);//false
	  System.out.println(str1==str3);//true
	}

}
-----------------------------------------------------------------------
String and its method related programs :
-----------------------------------------

//Three Ways to create the String Object
public class Test 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Hi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);		
	}
}
-------------------------------------------------------------------
//Immutability

public class Test1 
{
	public static void main(String[] args) 
	{
        String x = new String("india"); //immutable
		x.toUpperCase();
		System.out.println(x); //will print india in small letter 
		
	}
}
--------------------------------------------------------------------
//Solution of immutability [assigning to reference variable]
class Test2 
{
	public static void main(String[] args) 
	{
		String x = new String("india");
		String y  = x.toUpperCase();
		System.out.println(x);
		System.out.println(y);
	}
}
--------------------------------------------------------------------
//String is collection of alpha-numeric character
public class Test3 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123@$5";
		System.out.println(y);

		String z = "67.90";
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
--------------------------------------------------------------------
Working with methods of String :-
--------------------------------------
String class has provided number of predefined methods to work with String which are as follows :-

1) public char charAt(int indexPosition) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract or fetch or retrieve a single character from the given String. 

We need to pass the index position as a parameter to the method and based on the index position it will extract the character. The return type of this method is char.

//Program on charAt(int indexPosition)
class Test4 
{
	public static void main(String[] args) 
	{
	    String x = "Hello Hyderabad";

        char ch1 =  x.charAt(6); //H
		System.out.println(ch1); 

		ch1 = x.charAt(4); //o
		System.out.println(ch1); 

		ch1 = x.charAt(9); //e
		System.out.println(ch1);
	}
}
--------------------------------------------------------------------
public String concat(String str) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to concat or append two Strings. This can be also done by using concatenation operator '+'. 

This method takes String as a parameter and the return type of this method is String.

 //Program on concat(String str)
public class Test5 
{
	public static void main(String[] args) 
	{
		String s1 = "Data";
		String s2 = "base";
		String s3 = s1.concat(s2);  
		System.out.println("String after concatenation :"+s3);

        String s4 = "Tata";
		String s5 = "Nagar";
		String s6 = s4+s5;
		System.out.println("String after concatenation :"+s6);

        String s7 = "Naresh";
		System.out.println(s7.concat(" Technology"));		
	}
}
--------------------------------------------------------------------
public boolean equals(Object obj) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to verify whether two Strings are equal or not based on the content.

If both the Strings are equal it will return true otherwise it will return false.It is case sensitive method.

It takes Object as a parameter because it is an overridden method.It is overridden from Object class.

//static Authentication using boolean equals(Object str)

public class Test6 
{
	public static void main(String[] args)
	{
		String username = args[0]; 

		if(username.equals("Ravi"))
		{
			System.out.println("Welcome Ravi");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}
	}
}
--------------------------------------------------------------------
//Predicate to check the input name is Ravi or not
package com.ravi.cases;

import java.util.Scanner;
import java.util.function.Predicate;

public class EqualsUsingPredicate 
{
	public static void main(String[] args) 
	{
	  Predicate<String> p1 = x -> x.equals("Ravi");
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Name :");
	  String name = sc.next();
	  boolean isName = p1.test(name);
	  System.out.println("Are you Ravi :"+isName);
	  
	}

}
--------------------------------------------------------------------
public boolean equalsIgnoreCase(String str) :-
--------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to Compare two Strings based on the content by ignoring the case.
This method takes String as a parameter and return type of this method is boolean. It comapres two Strings by ignoring the case so it is not a case sensitive method.

Hence for this method 'A' and 'a' both are same.
//Program on boolean equalsIgnoreCase(String s)
public class Test7 
{
	public static void main(String[] args) 
	{		
		String username = args[0];

		if(username.equalsIgnoreCase("Raviinfotech"))
		{
			System.out.println("Welcome to Raviinfotech channel");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}
	}
}
----------------------------------------------------------------------
16-12-2023
----------
IQ
--
What is the difference between == operator and equals(Object obj) method of String class while comparing the String?

equals(object obj) method of String class compares two strings based on the content because it is an overriden method where as == operator compares two Strings based on the reference i.e memory address.

//IQ
public class Test8 
{
	public static void main(String[] args) 
	{
		String s1="India";
		String s2="India";
		String s3=new String("India");

		 System.out.println(s1==s2); 
		 System.out.println(s1==s3); 

		  System.out.println(s1.equals(s2)); 
		 System.out.println(s1.equals(s3));  
	}
}

Note :- String class has overridden equals(Object obj) method from Object class because Object class equals(Object obj) method meant for memory address comparison but this overridden String class equals(Object obj) meant for content comparison.

Note :- String is a final class in java
-----------------------------------------------------------------
public int length() :-
----------------------
It is a predefined method available in the String class. The main purpose of this method to find out the length of the given String. The return type of this method is int. 

Note :-
-------
Length and Size always start from 1 where as index of the character String always starts from 0.

//Program on public int length()  
class Test9 
{
	public static void main(String[] args) 
	{		
		String x = "Naresh Tech";
        int len = x.length();      
		System.out.println("The length of "+x+" is :"+len);
	}
}
----------------------------------------------------------------------
public String replace(char old, char new) :-
----------------------------------------------------
It is a predefined overloaded method available in the String class. The main purpose of this method to replace a character or a String with another character or String. The return type of this method is String. 

By using this method we can replace a single character or a complete String from the given String.

//replace() :-Replaces occurrences of a character with a new character
//public String replace(char old, char new)
public class Test10
{
public static void main(String [] args) 
	{
        String x = "oxoxoxox";  
		System.out.println("String before replacement :"+x);

		System.out.println("String after replacement :"+x.replace('x','X'));

		String y="Manager";		
		System.out.println(y.replace("Man","Dam"));	
    }
}
----------------------------------------------------------------------
public int compareTo(String s) :-
-------------------------------------
It is a predefined method available in the String class. The main purpose of this method two compare two Strings based on character by character, comparison of two Strings chracter by chracter based on the UNICODE values are called Lexicographical comparison or dictionary comparison or alphabetical comparison(String case). 

The return type of this method is int. It takes String as a parameter.

If s1 and s2 are two valid Strings 

if s1==s2  -> 0

if s1>s2  -> +ve

if s1<s2   -> -ve
-----------------------------------------------------------------------
//public int compareTo(String s) 
public class Test11    
{
     public static void main(String [] args) 
     {
        String s1="Sachin";      //PQRS        S > R         
        String s2="Sachin";
        String s3="Ratan";  

	   System.out.println(s1.compareTo(s2)); //0
	   System.out.println(s1.compareTo(s3)); //1
	   System.out.println(s3.compareTo(s1)); //-1   

       String s4 = "Apple"; 
	   String s5 = "apple"; 
	   System.out.println(s4.compareTo(s5));  // -32  [65 to 97]
	   System.out.println(s5.compareTo(s4));  // 32 [97 to 65]

	   String s6 = "Ravi";
	   String s7 = "Raj";
	   System.out.println(s7.compareTo(s6));

    }
}
----------------------------------------------------------------------
public String substring(int startIndex) :-

public String substring(int startIndex, int endIndex) :-
-------------------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract the part of the specified string based on the index position.

In this method the startIndex starts from 0 whereas endIndex starts from 1.

Both index will be inclusive for printing the value

If end index will be less than start index then we will get an exception i.e StringIndexOutOfBoundsException  
substring(5,2);

If start index and end index both are equal, nothing will print

Nither start index nor end index will accept (-ve) value otherwise StringIndexOutOfBoundsException.
-----------------------------------------------------------------------
public class Test12
{
	public static void main(String []  args) 
	{
        String x="HYDERABAD";		
		System.out.println(x.substring(2,7)); //DERAB

		System.out.println(x.substring(3)); //ERABAD

		System.out.println(x.substring(3,3)); 

         //java.lang.StringIndexOutOfBoundsException 
		 System.out.println(x.substring(6,3));

		//java.lang.StringIndexOutOfBoundsException 
		System.out.println(x.substring(6, -3));
	}
}
-----------------------------------------------------------------------
public boolean isEmpty() :-
------------------------------
It is a predefined method available in the String class. The main purpose of this method to check whether a String is empty or not. This method returns true if the String is empty that means length is 0, otherwise it will return false.

The return type of this method is boolean.
----------------------------------------------------------------
//public boolean isEmpty()
public class Test13
{
	public static void main(String args[])
	{		
		String str1 = "Java by James Gosling";
		String str2 = "";

		System.out.println(str1.isEmpty()); 
		System.out.println(str2.isEmpty()); 	  
	}
}
----------------------------------------------------------------------
public String intern()  :
---------------------------
It is a predefined method available in the String class. The main purpose of this method to return canonical representation for the string object that means String interning ensures that all strings having the same contents use the same memory location.

The return type of this method is String


//public String intern() 
//Returns the Canonical representation for the String object.
public class Test14
{
	public static void main(String args[])
	{
		    String s1 = new String("india");
			 String s2 = new String("india");
			 System.out.println(s1 == s2); //false

			 s1 = s1.intern();
			 s2 = s2.intern();
			 System.out.println(s1 == s2);//true


			 String s3 = "Hyd";   
			 String s4 = new String("Hyd");
			 System.out.println(s3 == s4);//false
			 s4 = s4.intern();
			 System.out.println(s3 == s4); //true


	}
}

Note :- Java automatically interns the string literals but we can manually use the intern() method on String object created by new keyword so all the Strings which are having same content will get the same String and return the same memory address(Canonical representation for the String ).

Program contains diagram (16 DEC)

intern process ensures that all strings having the same contents use the same memory location so, the following program will provide same hashCode value of all the Strings having same content.

public class StringHashCode 
{
	public static void main(String[] num) 
	{	  
		String str1 = "Java";
		String str2 = "Java";
		String str3 = new String("Java");
		
		System.out.println(str1.hashCode() +" : "+str2.hashCode()+" : "+str3.hashCode());
		
	}
}
---------------------------------------------------------------------------
18-12-2023
----------
//IQ
public class Test15
{
	public static void main(String args[])
	{
		String x = "india";
		System.out.println("it's length is :"+x.length); //error 

		String [] y = new String[10];    
		System.out.println("it's length is :"+y.length()); //error	
	}
}

Note :- String class does not contain length property it contains length() , lly array contains length property but length()
---------------------------------------------------------------
//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)

Both the methods are available in String class. 

startsWith() is used to verify that the given String is Starting with prefix String or not, if yes it will return true otherwise it will return false.

endsWith() is used to verify that the given String is ending with suffix String or not, if yes it will return true otherwise it will return false.

Both the methods are case-sensitive.

Both methods take String as a  parameter and return type is boolean.
--------------------------------------------------------------
//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)

public class Test16
{
	 public static void main(String args[])
	{ 
		String s="Sachin Tendulkar";
		System.out.println(s.startsWith("Sa"));
		System.out.println(s.endsWith("r"));
	}
}
----------------------------------------------------------------------
public int indexOf(String str) :-
---------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the index position of the specified String in the existing String.

It will serach the index position of the first occurrance of the specified String as a parameter.

It takes String as a parameter and return type of this method is int.

if the specified string is not available in the existing string then it will return -1.
----------------------------------------------------------------------
//public int indexOf(String x)
public class Test17
{
	 public static void main(String args[])
	{
		String  str = "India is my country and It is in Asia";
        int index = str.indexOf("is");
		System.out.println("First Occurrance of is :"+index); 
	}
}

----------------------------------------------------------------------
public int lastIndexOf(String x) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the last index position of the Specified String in the existing String.

It will serach the index position of the last occurrance of the String.

It takes String as a parameter and return type of this method is int.

//public int lastIndexOf(String x)
public class Test18
{
	public static void main(String args[])
	 { 
         String s1 = "it is a nice city";    
		 int lastIndex = s1.lastIndexOf("it");
		System.out.println("Last occurrance of it, is :"+lastIndex+ "th position");
     }
}
----------------------------------------------------------------------
//public String toUpperCase() :- converts to upper case letter
public class Test19
{
	public static void main(String args[])
	{
        String str = "india";
		System.out.println(str.toUpperCase());
    }
}
-----------------------------------------------------------------------
//public String toLowerCase()  converts to lower case.
public class Test20
{
	public static void main(String args[])
	{
		String str = "INDIA";
		System.out.println(str.toLowerCase());  //india
	}
}
-----------------------------------------------------------------------
public String trim() :- 
-------------------------
It is a predefined method available in the String class. The main purpose of this method to remove the white spaces from the begning (heading) and end (trailing) from the String.

It will not remove any white space in the between the String. The return type of this method is String.
--------------------------------------------------------------

//program on trim()  
public class Test21
{
public static void main(String args[])
	{
		String s1="   Tata    ";  
		System.out.println(s1+"Nagar"); //       Tata      Nagar     

        s1 = "          Hello       Data        ";
		System.out.println(s1.trim() +"Base"); //Hello    DataBase	

	}
}
----------------------------------------------------------------------
public String []  split (String delimiter)  :
-----------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to split or break the given String based on specified delimiter(Criteria).

The return type of this method is String array because It returns the collection of String tokens or multiple Strings.
    
//public String []   split(String delimiter)

public class Test22
{
public static void main(String args[])
	{
		String s1="Hyderabad is a nice city";  
		String [] words = s1.split(" "); //Space is Delimiter
		for(String word : words)
		{
			System.out.println(word);
		}       
	    System.out.println("..............");

        String s2="Hyderabad is a nice city";  
		words = s2.split("a"); 

		for(String word : words)
		{
			System.out.println(word);
		} 
	}
}  
-----------------------------------------------------------------------
Program on StringTokenizer class
---------------------------------
import java.util.*;
public class STDemo
{
public static void main(String [] args)
	{
		String str ="Hyderabad is a lovely place";
		StringTokenizer st = new StringTokenizer(str,"a");

		System.out.println("Number of tokens :"+st.countTokens());
		System.out.println("The tokens are :");

		while(st.hasMoreTokens())
		{
			String token = st.nextToken();
			System.out.println(token); 
		}		
	}
}

public int countTokens()
public boolean hasMoreTokens()
public String nextToken()
----------------------------------------------------------------------
public char[]  toCharArray() :-
--------------------------------
It is a predefined method available in the String class. The main purpose of this method to convert the given string into a sequence of characters. The returned array length is equal to the length of the string.

This method does not take any parameter and return type is character array.
---------------------------------------------------------------------
//public char[] toCharArray()
public class Test23
{
public static void main(String args[])
	{
		String str = "Java technology";
		char ch [] = str.toCharArray();

		for(char c : ch)
		{
			System.out.print(c+"  ");
		}
		System.out.println();
	}
}         
----------------------------------------------------------------------
public byte [] getBytes() :-
-------------------------------
It is a predefined method available in the String class. The main purpose of this method encode the string into bytes. It converts the string into a sequence of bytes and returns an array of bytes. 

//public byte [] getBytes()
//encode the String into sequence of bytes

public class Test24
{
public static void main(String args[])
	{
		String str = "ABCDEF";	
		
		byte [] b = str.getBytes();

		for(byte a : b)
		{
			System.out.println(a);  
		}
	}
}         
---------------------------------------------------------------------
package com.ravi.comp;

public class StringToCharacter 
{
	public static void main(String[] args) 
	{
		String str = "ab";
		char ch1 = str.charAt(0);
		char ch2 = str.charAt(1);
		
		System.out.println(ch1 + ch2); //195	
	}
}
----------------------------------------------------------------------
StringBuffer :-
----------------
While working with String class the drawback is memory consumption is very high because it is immutable so whenever we want to perform some operation on the existing String Object, a new String object will be created.

In order to solve the problem of immutability as well as high memory consumption, java software people has introdued a separate class called StringBuffer available in java.lang packge from 1.0 onwards.

StringBuffer is a mutable class so we can modify the existing String hence automatically the memory consumption will be low but we have some performance issue because almost all the methods of StringBuffer class are synchronized so at a time only one thread can access the method of StringBuffer hence it is Thread-safe. 

In order to solve this performance issue problem java software people has introduced StringBuilder class from 1.5v onwards.

StringBuilder :-
-----------------
It is a predefined class available in java.lang packge. It is also mutable class. The only difference between StringBuffer and StringBuilder is, almost all the methods of StringBuffer are synchronized where as all the methods of StringBuilder are non-synchronized hence performance wise StringBuilder is more better than StringBuffer.

Both the classes are sharing same API so, method name, return type, parameter list all are same.

* What is the difference String, StringBuffer and StringBuilder?
-----------------------------------------------------------------
Diagram is available in paint window
----------------------------------------------------------------------
//String, StringBuffer and StringBuilder Objects comparison
public class Test25
{
public static void main(String args[])
	{
		StringBuilder sb1=new StringBuilder("Data"); //mutable
		sb1.append("Base");
		System.out.println(sb1);	

		StringBuffer sb2=new StringBuffer("Data"); //mutable
		sb2.append("Base");
		System.out.println(sb2);	

		String sb3 = new String("Data");  //immutable
	    sb3.concat("Base");
        System.out.println(sb3);	
	}
}
----------------------------------------------------------------------
19-12-2023
----------
public int capacity() :
-------------------------
StringBuffer class contains capacity method() through which we can find out the initial capacity of StringBuffer class in the form of Characters.

StringBuffer sb = new StringBuffer(); //default capacity is 16

new capacity = (current capacity * 2) + 2

new Capacity = (16 * 2) + 2 = 34
-----------------------------------------------------------------
//public int  capacity()   
//new capacity = ( current capacity*2)+2.
public class Test26
{
public static void main(String args[])
	{        
		StringBuffer sb1 = new StringBuffer();
		System.out.println(sb1.capacity()); //16
		
	   StringBuffer sb2 = new StringBuffer("India");  //21 (16+5)
	   System.out.println(sb2.capacity()); 

        sb2.append("is great. It is in Asia"); //44
		System.out.println(sb2.capacity()); 	
		
	}
}
--------------------------------------------------------------------
//public StringBuffer insert(int position, String str)
//Based on the index position we can insert the String
public class Test27
{
public static void main(String args[])
	{	
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.insert(1,"Java");
		System.out.println(sb1);  //HJavaello

		StringBuilder sb2=new StringBuilder("Hello");
		sb2.insert(1,"Java");
		System.out.println(sb2);  
	}
}
---------------------------------------------------------------------
//public AbstractStringBuilder reverse()
//Used to reverse the given String
class Test28
{
	public static void main(String[] args) 
	{
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.reverse();
		System.out.println(sb1);  

		StringBuilder sb2=new StringBuilder("Java");
		sb2.reverse();
		System.out.println(sb2);  		
		}
}
---------------------------------------------------------------------
//Program to demonstrate the performance of StringBuffer and StringBuilder classes.  
public class Test29
{
	public static void main(String []args) 
	{
         long startTime = System.currentTimeMillis();

		//StringBuffer class to perform some looping operation
		StringBuffer sb1 = new StringBuffer("Java");
		for(int i =1; i<=1000000; i++)
		{
			sb1.append(" Technology");
		}

        long endTime = System.currentTimeMillis();

		 System.out.println("Time taken by StringBuffer class is :"+(endTime - startTime+" ms"));

		 System.out.println("..........................");

		 startTime = System.currentTimeMillis();
		 //StringBuilder class to perform some looping operation
		StringBuilder sb2 = new StringBuilder("Java");
		for(int i =1; i<=1000000; i++)
		{
			sb2.append(" Technology");
		}
		
		endTime = System.currentTimeMillis();
		System.out.println("Time taken by StringBuilder class is :"+(endTime - startTime+" ms"));		
	}
}

Note :- System is a predefined class available in java.lang package and it contains a predefined static method currentTimeMillis() , the return type of this method is long, actually it returns the current time of the system in ms.
----------------------------------------------------------------------
Constructor of String class :
-----------------------------
1) String str1 = new String();

2) String str2 = new String("India");

3) String str3 = new String(new StringBuffer());

4) String str4 = new String(new StringBuilder());

5) String str5 = new String(byte x[]);

6) String str6 = new String(char v[]);
----------------------------------------------------------------------
Some operation on String methods :
----------------------------------
//String class Constructor
//WAP in java to reverse a String
import java.util.Scanner;
public class Test1
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a String to reverse :");
		String str = sc.nextLine();  //Ravi  (i=0  to 0  ---)
		
        for(int i=str.length()-1; i>=0; i--)
		{
			 System.out.print(str.charAt(i)); //i
		}	
        System.out.println();
	}
}
----------------------------------------------------------------------
//WAP in java to reverse a String
import java.util.Scanner;
public class Test2 
{
    public static void main(String[] args) 
	{
        Scanner sc = new Scanner(System.in);
		System.out.println("Enter a String to reverse :");
		String input = sc.nextLine();

        StringBuilder sb = new StringBuilder();
        sb.append(input);
        System.out.println(sb.reverse());
    }
}
---------------------------------------------------------------------
//Program to find out the duplicate characters in String as well as count it in a String
import java.util.*;
public class Test3 
{
public static void main(String ...x)
{
  Scanner sc = new Scanner(System.in);
  System.out.println("Enter a String :");
  String str = sc.nextLine(); //ravishankar

  int count = 0;
  char[] arr = str.toCharArray();    

  System.out.println("Duplicate Characters are:");

  for (int i = 0; i < str.length(); i++)      
  {
    for (int j = i + 1; j < str.length(); j++) 
	{
      if (arr[i] == arr[j]) 
		  {
             System.out.println(arr[j]);
             count++;
             break;
          }
     }
  }
   System.out.println("Total duplicate characters are :"+count);
 }
}
----------------------------------------------------------------------
//Remove a specified character from the given String
import java.util.*;
public class Test4
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();  //ravi

	System.out.println("Enter a character you want to remove :");
    char removeChar = sc.next().charAt(0); //v

    StringBuilder result = new StringBuilder(); //rai

    for (char c : str.toCharArray()) //{  'i'}  
		{
          if (c != removeChar)    // i != v
		  {
             result.append(c);   
          }
       }
    System.out.println(result);
  }
}
--------------------------------------------------------------------
//Program to check whether a String contains vowels or not?
import java.util.*;
public class Test5
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    boolean containsVowel = false;

    for (char c : str.toLowerCase().toCharArray())    
	{
      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') 
	  {
        containsVowel = true;
        break;
      }
    }

    if (containsVowel) 
	{
      System.out.println("The string contains a vowel.");
    } 
	else 
	{
      System.out.println("The string does not contain a vowel.");
    }
  }
}
--------------------------------------------------------------------
20-12-2023
-----------
//How to sort a String data
import java.util.Scanner;
public class Test6
{
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();  //mango

    char[] chars = str.toCharArray();    

    for (int i = 0; i < chars.length; i++)   
	{
      for (int j = i + 1; j < chars.length; j++)  
	  {
        if (chars[i] > chars[j])   
		{
          char temp = chars[i];
          chars[i] = chars[j];
          chars[j] = temp;
        }
      }
    }
    System.out.println(new String(chars));
  }
}
----------------------------------------------------------------------
//count the occurrence of a given character in the existing String
import java.util.*;

public class Test7
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine(); //apple    p

	System.out.println("Enter a character :");
    char target = sc.next().charAt(0);

    int count = 0;

    for (int i = 0; i < str.length(); i++) // i = 5       length = 5 
	{
            if (str.charAt(i) == target)   //e == p    (apple)
			{
                count++;  //2
            }
     }
        System.out.println("The character '" + target + "' appears " + count + " times in the string '" + str + "'");
    }
}
----------------------------------------------------------------------
Character class in java :
------------------------
It is a predefined Wrapper class available in java.lang package. It contains the following static methods to check whether a chracter is digit or not , in uppercase or not as well as in lowercase or not?

public static boolean isDigit(char ch);  //ravi1ui

public static boolean isUpperCase(char ch);

public static boolean isLowerCase(char ch);
---------------------------------------------------------------------
//Program to find out a String contains digit or not
//public static boolean isDigit(char ch) 

import java.util.*;
public class Test8
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    boolean containsDigits = false;

    for (int i = 0; i < str.length(); i++)   ///Ravi123
	{
      if (Character.isDigit(str.charAt(i))) 
	  {
        containsDigits = true;
        break;
      }
    }

    if (containsDigits) 
	{
      System.out.println("The string contains digits.");
    } 
	else 
    {
      System.out.println("The string does not contain digits.");
    }
  }
}
----------------------------------------------------------------------
//program to count capital and small letter from the given String
//public static boolean isUpperCase(char ch)
//public static boolean isLowerCase(char ch)

import java.util.Scanner;
public class Test9
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();  //RaVi

  int upperCase = 0, lowerCase = 0;    

    for (int i = 0; i < str.length(); i++) 
	{
      char ch = str.charAt(i);    
      
	  if (Character.isUpperCase(ch)) 
	  {
        upperCase++;
      } 
	  else if (Character.isLowerCase(ch)) 
	  {
        lowerCase++;  
       }
    }    
    System.out.println("Uppercase letters: " + upperCase);
    System.out.println("Lowercase letters: " + lowerCase);
  }
}
----------------------------------------------------------------------
//Program to count the consonants and vowels in the given String
import java.util.Scanner;
public class Test10
{
public static void main(String[] args) 
{
     Scanner sc = new Scanner(System.in);
     System.out.print("Enter a string: ");
     String str = sc.nextLine();

    int vowels = 0, consonants = 0;

    for (int i = 0; i < str.length(); i++) 
	{
      char c = str.charAt(i);  

      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
          c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') 
	  {
        vowels++;
      } 
	  else  
	  {
        consonants++;
      }
    }
    System.out.println("Vowels: " + vowels);
    System.out.println("Consonants: " + consonants);
  }
}
----------------------------------------------------------------------
//check a String  is palindrome or not  
import java.util.Scanner;
public class Test11
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();            // madam

    boolean isPalindrome = true;                    

    for(int i = 0; i < str.length() / 2;   i++)    //i=2  i<2
	{
        if (str.charAt(i) != str.charAt(str.length() - i - 1)) //a != a
		{
           isPalindrome = false;  
           break;
        }
    }

    if (isPalindrome) 
	{
      System.out.println(str + " is a palindrome.");
    } 
	else 
	{
      System.out.println(str + " is not a palindrome.");
    }
  }
}
----------------------------------------------------------------------
Multithreading :
----------------
Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the
major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple task can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking
b) Thread based Multitasking


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to 
another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.
----------------------------------------------------------------------
Thread :-
----------
A thread is light weight process and it is the basic unit of CPU which can run concurrently with another thread within the same context (process).

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread at the same time so our task will be completed as soon as possible.

In java whenever we define a main method then JVM internally creates a thread called main thread.
------------------------------------------------------------------------
21-12-2023
-----------
Program that describes that main is a Thread :
-----------------------------------------------
Whenever we define main method then JVM will create main thread internally, the purpose of this main thread to execute the entire main method.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static method currentThread() which will provide currently executing Thread.

Thread t = Thread.currentThread();

Thread class has provided predefined method getName() to get the name of the Thread.

//Program that describes that main is a Thread

public class MainThread {

	public static void main(String[] args)
	{
		 String name = Thread.currentThread().getName();
		 System.out.println("Current Thread Name is :"+name);
	}

}
-------------------------------------------------------------------------
How to create a userdefined Thread in java ?
---------------------------------------------
As we know whenever we define the main method then JVM internally creates a thread called main thread.

The purpose of main thread to execute the entire main method so at the time of execution of main method a user can create our own userdefined thread.

In order to create the userdefined Thread we can use one of the following two ways :-

1) By extending java.lang.Thread class
2) By implementing java.lang.Runnable interface

Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
----------------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined method of Thread class and this method internally performs two tasks

1) It makes a request to opearting system to assign a new thread to perform concurrent execution.

2) It internally invokes the run() method as a part a separate Stack.

Note :- For every individual thread, JVM creates a separate runtime stack
----------------------------------------------------------------
The following program explains how to create a userdefined Thread by extending Thread approach.

-------------------------------------------------------------------------
package com.ravi.thread;

class Test extends Thread
{
	@Override
	public void run()
	{
	  System.out.println("Child Thread is Running");	
	}
}

public class UserThread 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started..");		
		Test t1 = new Test();		
		//Calling the run method with separate Stack Memory
		t1.start();				
		System.out.println("Main Thread Ended...");
	}
}

From the above program it is clear that main thread is responsible to execute the entire main method, on the pther hand child thread is responsible to execute run() method.
-----------------------------------------------------------------------
public boolean isAlive() :-
-----------------------------
It is a predefined method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException
-------------------------------------------------------------------
package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args)
	{
		System.out.println("Main Thread is started..");			
		Foo f = new Foo(); 		
        System.out.println("Thread has not started yet so :"+f.isAlive());	
		
		f.start(); //new Thread has created	
		
		System.out.println("Thread has started  so :"+f.isAlive());
		
	    f.start();	
    }
}
-------------------------------------------------------------------------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is Running!!!!");
	}	
}
public class ExceptionDemo {

	public static void main(String[] args) 
	{
		System.out.println("Main Thread Started");		
		
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 
		
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}
}

Note :- Here main thread is interrupted due to AE but still child thread will be executed.
------------------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName(); 
	    
	    for(int i = 1; i<=10; i++)
	    {
	   System.out.println("i value is :"+i+" by "+name+" thread" );
	    }	   
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args) 
	{
	    System.out.println("Main thread started.....");
	    
	    Sample s = new Sample();
	    s.start();//child thread is created 
	    	    
	    String name = Thread.currentThread().getName();
	    
	    for(int i = 1; i<=10; i++)
	    {
	    System.out.println("i value is :"+i+" by "+name+ " thread");	   
	    }	
	    
	   
	   
	    int x =1;
	     do
	     {
	    	System.out.println("Hello");
	    	x++;
	     }
	     while(x<=10);    
	}
}

-----------------------------------------------------------------------
22-12-2023
----------
How to set and get the name of the Thread : 
--------------------------------------------------
Whenever we create a Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public void setName(String name)

public String getName()
-----------------------------------------------------------------------
package com.ravi.basic;
class Test extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(); 
		Test t2 = new Test(); 
		t1.start();			
		t2.start();	
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}

Note :- In the above program we have not assigned the name of the Thread so, by default it will take/print Thread-0, Thread-1 and so on
----------------------------------------------------------------------
package com.ravi.basic;
class Demo extends Thread
{
	@Override
	public void run()
	{
		System.out.println(Thread.currentThread().getName()+" thread is running.....");	
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
		 Thread t = Thread.currentThread();
	     t.setName("Parent");//changing the main thread name
			     
	     Demo d1 = new Demo();
	     Demo d2 = new Demo();
	     
	     d1.setName("Child1");
		 d2.setName("Child2");	
	     
	     d1.start();
	     d2.start();  	     
	          
	     System.out.println(Thread.currentThread().getName()+" thread is running!!!!");
	}
}

In the above program we are setting the name of the Thread.
-----------------------------------------------------------------------
Thread.sleep(long milisecond) :
------------------------------------
The main purpose of sleep() method to put a Thread into temporarly waiting state, the waiting period of the Thread will depend upon the parameter we passed inside the sleep() method, It takes long milisecond as a parameter.

It is a static method so we can directly call sleep() method with the help of class name i.e Thread class.

It throws a checked exception i.e InterruptedException so we should write sleep() inside try-catch or declare the method as throws.
--------------------------------------------------------------
package com.ravi.basic;

class Sleep extends Thread
{
  @Override
  public void run() 
  {
	  for(int i=0; i<=10; i++)
	  {
		  System.out.println("i value is :"+i);
		  try 
		  {
			Thread.sleep(1000);
		  } 
		  catch (InterruptedException e) 
		  {
			System.err.println("Catch block :"+e);
		  }
	  }
  }
  
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started...");
         Sleep s = new Sleep();
         s.start();  
                 
		System.out.println("Main Thread ended...");
	}
}

Note :- In the above program catch block will not be executed because thread is not interrupted by another thread.
-----------------------------------------------------------------------
package com.ravi.basic;

class MyTest extends Thread 
{	
	@Override
	public void run() 
	{
		for (int i = 1; i <= 5; i++) 
		{	
			
			  try 
			  { 
				  Thread.sleep(1000); 
			  }
			  catch(InterruptedException e) 
			  {
			   System.err.println("thread has interrupted"); 
			  }
			 	
			System.out.println(i + " by " + Thread.currentThread().getName());
		}
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{
		System.out.println(Thread.currentThread().getName() + " thread");

		MyTest t1 = new MyTest();
		MyTest t2 = new MyTest();

		t1.setName("Child1");
		t2.setName("Child2");
		
		t1.start();
		t2.start();	
	}
}


Note :- While writing the Thread.sleep() inside the run() method, we cannot write throws InterruptedException statement because  IF A SUPER CLASS METHOD DOES NOT THROW ANY KIND OF CHECKED EXCEPTION THEN AT THE TIME OF OVERRIDING THE SUB CLASS METHOD SHOULD NOT THROW ANY KIND OF CHECKED EXCEPTION.
-----------------------------------------------------------------------
Thread life cycle in java :
-----------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) New State (Born state)

2) Runnable state (Ready to Run state) [Thread Pool]

3) Running state

4) Waiting / Blocked state

5) Exit/Dead state


New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running mode that means the thread is executing its own run() method. 

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.

IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting mode and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
-----------------------------------------------------------------------
23-12-2023
----------
join() method of Thread class :
------------------------------------
The main purpose of join() method to put the one thread into waiting mode until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is an instance method so we can call this method with the help of Thread object reference.
-----------------------------------------------------------------------
package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			System.out.println(i);
			try
			{
				Thread.sleep(500);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}

public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread Started!!!!!");
       
       Join j1 = new Join();
       Join j2 = new Join();
       Join j3 = new Join();
       
       j1.start();
       j1.join();
       
       j2.start();
       j3.start();
     
       System.out.println("Main thread completed!!!!");
       
	}
}
-----------------------------------------------------------------------
package com.ravi.basic;

class MyThreadd extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			System.out.println(i + " By "+ Thread.currentThread().getName());
			try
			{
			//HERE WE ARE HALTING CURRENT THREAD SO
			DEADLOCK, MAIN THREAD IS NOT HERE

			Thread thread = Thread.currentThread();
				  thread.join();		     
			}
			catch(InterruptedException e)
			{
		      e.printStackTrace();		
			}
		}
	}
}
public class JoinMethod
{
	public static void main(String[] args) throws InterruptedException
	{
		System.out.println("Main Thread started....");
		
		MyThreadd t1=new MyThreadd();
		MyThreadd t2=new MyThreadd();
		
		t1.setName("Child 1");
		t2.setName("Child 2");	
		
		System.out.println("Thread 1");		
		t1.start();
		
		
		System.out.println("Thread 2");
		t2.start();	
					
		System.out.println("program executed");
	}
}
In the above program both the threads (Thread 1 and Thread 2) are calling join() method on same object so both the threads are not completing(Going to Dealloack state)
-----------------------------------------------------------------------
package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main thread started");
		Thread thread = Thread.currentThread();
		String name = thread.getName();
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i + " by "+name+ " thread ");
			
		}
		thread.join();  //Main thread is waiting to complete the main thread (It blocked itself)
		
		System.out.println("Main thread ended");

	}

}
----------------------------------------------------------------------
Program where two threads are communication using join() :
----------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();			
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  //Alpha thread is in Halt mode
        try 
        {
			b1.join();
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 {

	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	
		for(int i=1; i<=20; i++)
		{
			System.out.println(i+" by "+name);
		}
	}
}
-----------------------------------------------------------------------
Creating Thread by implements Runnable approach :
--------------------------------------------------
package com.ravi.basic;

class Foo2 implements Runnable
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println("Child Thread is running :"+name);		
	}	
}
public class RunnableDemo 
{
	public static void main(String[] args) 
	{
		Foo2 f1 = new Foo2();
		Thread t1 = new Thread(f1);
		t1.start();
		
	}
}

In implements Runnable approach we need to pass the sub class object as a reference to Thread class constructor.
-----------------------------------------------------------------------
26-12-2023
-----------
Creating a thread with Anonymous inner class approach with reference:
---------------------------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousThreadWithReference 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()+" thread is running@@@@");
		
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				System.out.println(Thread.currentThread().getName()+" thread is running!!!");
			}
		};
		t1.start();

	}

}
----------------------------------------------------------------------
Creating a thread with Anonymous inner class approach without reference:
-----------------------------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousThreadWithoutReference {

	public static void main(String[] args) 
	{
		System.out.println(Thread.currentThread().getName()+" thread is running@@@@");
		
		new Thread()
		{
			@Override
			public void run()
			{
				System.out.println(Thread.currentThread().getName()+" thread is running!!!");
			}
		}.start();
		

	}

}
------------------------------------------------------------------------
Creating Thread by Anonymous inner class using Runnable interface :
-------------------------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousByRunnable 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()+" thread is running@@@@");	
		
		
	  Runnable r1 = new Runnable()
	  {
		@Override
		public void run() 
		{
			System.out.println(Thread.currentThread().getName()+" thread is running!!!");		
			
		}
		   
      };
          new Thread(r1).start();
	}

}

----------------------------------------------------------------------
Runnable is a predefined functional interface so we can apply Lambda Expression on Runnable interface 

package com.ravi.anonymous_thread;

public class AnonymousByRunnable 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()+" thread is running@@@@");	
		
		
	  Runnable r1 = ()-> System.out.println(Thread.currentThread().getName()+" thread is running!!!!"); 
			  
          new Thread(r1).start();
	}

}
-------------------------------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousByRunnable 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()+" thread is running@@@@");		 
		
		//Implementing Lambda in the Thread Constructor
          new Thread(()-> System.out.println(Thread.currentThread().getName())).start();
	}
}
----------------------------------------------------------------------
*In between extends Thread and implements Runnable, which one is better and why?

In between extends Thread and implements Runnable approach, implements Runnable is more better due to the following reasons

1) When we use extends Thread, all the methods and properties of Thread class is available to sub class so it is heavy weight but this is not the case while implementing Runnable interface.

2) As we know Java does not support multiple inheritance using classes so in the extends Thread approach we can't extend another class but if we use implments Runnable interface still we have chance to extend another class(Only one class) and we can also implement one or more interfaces.

3) implements Runnable is a better approach to create multiple threads on a single sub class object.

4) We can implement Lambda for Runnable interface (Functional interface)
---------------------------------------------------------------
Thread class Constructor :  
--------------------------
The following are the commonly used constructor available in Thread class :

1) Thread()
2) Thread(String name)
3) Thread(Runnable target)
4) Thread(Runnable target, String name)
5) Thread(ThreadGroup threadGroup, Runnable target, String name)
---------------------------------------------------------------------
27-12-2023
----------
Problem with multithreading :-
----------------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result will be corrupted.

In multithreading if we want to perform read operation and data is not updatable then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data as shown in the diagram.(27-DEC-23)
---------------------------------------------------------------------
package com.ravi.data_race;

class Customer implements Runnable
{	
	private int availableSeat = 1;
	private int wanted;
	
	public Customer(int wanted)
	{
		this.wanted = wanted;
	}	
	
	@Override
	public synchronized void run() 
	{
	   String name = null;
	   if(availableSeat >= wanted)
	   {
		   name = Thread.currentThread().getName();
		   System.out.println(wanted +" seat is reserved for :"+name);
		   System.out.println("Congratulations "+name+" Your ticket is Booked");
		   availableSeat = availableSeat - wanted;
	   }
	   else
	   {
		   name = Thread.currentThread().getName();
		   System.err.println("Sorry "+name+" berth is not available");
	   }
	}
	
}

public class RailwayReservation 
{
	public static void main(String[] args) 
	{
	   Customer obj = new Customer(1);	
	   
	   Thread t1 = new Thread(obj,"Virat");
	   Thread t2 = new Thread(obj,"Rohit");
	   
	   t1.start();  t2.start();
	}
}

H.W : Convert the same program into Lambda
----------------------------------------------------------------------
//Movie Ticket (Buy the Ticket + Seat allocation)

package com.ravi.advanced;

class MyThread implements Runnable
{
	private String str;
	
	public MyThread(String str)
	{
		this.str=str;
	}	
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(str+ " : "+i);
			try
			{
				Thread.sleep(100);
			}
			catch (Exception e)
			{
			System.err.println(e);
			}
		}
	}
}
public class Theatre
{
	public static void main(String [] args)
	{
		MyThread obj1 = new MyThread("Buy the Ticket");  
		MyThread obj2 = new MyThread("Allocate the Seat"); 

		Thread t1 = new Thread(obj1);
		Thread t2 = new Thread(obj2);

		t1.start();
		t2.start();
	}
}
----------------------------------------------------------------------
Banking Application using Lambda Approach :
-------------------------------------------
package com.ravi.banking_application;

public class Banking 
{
   private double balance = 5000;
   private double withdrawAmount;
   
   public Banking(double withdrawAmount)
   {
	   this.withdrawAmount = withdrawAmount;
   }
   
   public static void main(String[] args)
   {
	   Banking b = new Banking(5000);
	   
	   Runnable r1 = ()->
	   {
		   String name = null;
		   if(b.balance >= b.withdrawAmount)
		   {
			   name = Thread.currentThread().getName();
			   System.out.println(b.withdrawAmount+" Amount withdrawn by :"+name);
			   b.balance = b.balance - b.withdrawAmount;			   
		   }
		   else
		   {
			   name = Thread.currentThread().getName();
			   System.out.println("Sorry "+ name +" Balance is insufficiant");
		   }	
		   System.out.println("Your Account balance is :"+b.balance);
	   };	   
	   
	  Thread t1 = new Thread(r1,"Virat");
	  Thread t2 = new Thread(r1,"Rohit");
	   
	   t1.start(); t2.start();   
   }
   
}
----------------------------------------------------------------------
* Synchronization :
------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive synchronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(27-DEC-23)

Block level synchronization :-
---------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (27-DEC-23) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.
----------------------------------------------------------------------
28-12-2023
----------
How synchronization controls multiple threads :
------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

The thread who acquires the lock from the Object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the Object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.
---------------------------------------------------------------------
Program on Method level Synchronization :
-----------------------------------------
2 Files :
---------
Table.java
----------
package com.ravi.syn;

public class Table 
{
	public synchronized void printTable(int num)  
	{
	   for(int i=1; i<=10; i++)
	   {
	      System.out.println(num+" X "+i+" = "+(num*i));
	      
	      try
	      {
	    	  Thread.sleep(1000);
	      }
	      catch(InterruptedException e)
	      {
	    	  e.printStackTrace();
	      }
	   }
	   System.out.println(".....................");
	}
}


MethodLevelSynchronization.java
-------------------------------
package com.ravi.syn;

public class MethodLevelSynchronization 
{
	public static void main(String[] args) 
	{
		Table obj = new Table();  //obj is having lock
		
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				obj.printTable(5);
			}
			
		};
		
		Thread t2 = new Thread()
		{
			@Override
			public void run()
			{
				obj.printTable(10);
			}
			
		};
		
		t1.start();   t2.start();
		

	}

}
----------------------------------------------------------------------
Program on Synchronization Block :
----------------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()
	{		
	  //This area is accessible by all the threads  		
	  String name = Thread.currentThread().getName();
	  System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); 	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1,"Child1"); 
		Thread t2 = new Thread(r1,"Child2"); 
		t1.start(); t2.start();				
	}
}
----------------------------------------------------------------------
Problem with Object Level Synchronization :
-------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread, t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is synchronization mechanism does not work with multiple Objects.(Diagram 28-DEC-23)
---------------------------------------------------------------------
package com.ravi.advanced;
class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		PrintTable pt1 = new PrintTable(); //lock1		
		PrintTable pt2 = new PrintTable(); //lock2
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(6);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}
--------------------------------------------------------------------------
29-12-2023
----------
In order to solve object level synchronization, Java software people 
introduced static synchronization.

Static Synchronization :
---------------------------
If We declare a synchronized method as a static method then it is called static synchronization.

Now with static synchronization lock will be available at class level but not Object level.

To call the static synchronized method, object is not required so we can call the static method with the help of class name.

Unlike objects we can't create multiple classes for the same application.
--------------------------------------------------------------------------
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(100);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = new Runnable() 
					{						
						@Override
						public void run() 
						{
							MyTable.printTable(15);							
						}
					};
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	t3.start();
					
		}
}
-------------------------------------------------------------------------
Thread Priority :
------------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in number from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The userdefined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.

------------------------------------------------------------------------
package com.ravi.advanced;

public class MainPriority 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();		
		
		System.out.println("Main thread priority is :"+t.getPriority()); 
		
		Thread t1 = new Thread();
		System.out.println("User thread priority is :"+t1.getPriority()); 
	}

}
-------------------------------------------------------------------------

package com.ravi.advanced;

class ThreadP extends Thread
{
	@Override
	public void run()
	{
	  int priority = Thread.currentThread().getPriority(); 
	  
	  System.out.println("Child Thread priority is :"+priority);  	  
	}
}
public class MainPriority1 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		t.setPriority(8);
		
		// t.setPriority(11); Invalid java.lang.IllegalArgumentException 
		
		System.out.println("Main thread priority is :"+t.getPriority()); 		
		
		ThreadP t1 = new ThreadP();
		t1.start();		
	}
}
-------------------------------------------------------------------------
package com.ravi.advanced;

class ThreadPrior1 extends Thread
{
	@Override
	public void run()
	{
		int count = 0;
		
		for(int i=1; i<=1000000; i++)
		{
		  count++;	
		}
		
	System.out.println("Thread name is:"+Thread.currentThread().getName());
	System.out.println("Thread priority is:"+Thread.currentThread().getPriority());
	}	
	
	public static void main(String args[])
	{
		ThreadPrior1 m1 = new ThreadPrior1();
		ThreadPrior1 m2 = new ThreadPrior1();
		
		m1.setPriority(Thread.MIN_PRIORITY);//1
		m2.setPriority(Thread.MAX_PRIORITY);//10	
		
		m1.setName("Last");
		m2.setName("First");	
		
		m1.start();
		m2.start();
	}
}   

Note :- Higher thread priority means it will get more execution time and it will be first thread in the Runnable queue, There is no guarantee that the thread having heigher priority will always complete its task task.
-----------------------------------------------------------------------
Thread.yield() :
----------------
It is a static method of Thread class .

It will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or highest priority. Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular can ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.

If the thread which is in runnable state is having low priority then the same running thread will continue its execution.
-------------------------------------------------------------------------
package com.ravi.advanced;

public class ThreadYieldMethod 
{
	public static void main(String[] args) 
	{
		Runnable r1 = ()->
		{
			for(int i=1; i<=10; i++)
			{
				String name = Thread.currentThread().getName();

				System.out.println("i value is :"+i+" by thread :"+name);    
				
				
				 if(name.equals("Child1")) 
				  { 
					  Thread.yield(); //Give a chance to Child2 Thread
				  }
				 
			}
		};

		Thread t1 = new Thread(r1,"Child1");
		Thread t2 = new Thread(r1,"Child2");
		
		  
		t1.start();  t2.start();
	}
}
-----------------------------------------------------------------------
*Inter Thread Communication (ITC) :
----------------------------------
It is a mechanism to communicate two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It will put a thread into temporarly waiting state and it will release the lock.
It will wait till the another thread invokes notify() or notifyAll() for this object.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.

*Note :- wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because these methods are related to lock(because we can use these methods from the synchronized area ONLY) and Object has a lock so, all these methods are defined inside Object class.


*What is the difference between sleep() and wait() 
----------------------------------------------------------
(Given in the diagram 30-DEC-23) 
-----------------------------------------------------------------------
//Program that describes if we don't use ITC then the problem is ...

class Test implements Runnable
{
	int var = 0;	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)   
		{
			var = var + i;     //var = 1 3 6 10 15 21
			try
			{
				Thread.sleep(200);
			}
			catch (Exception e)
			{
			}		          
		}
		
	}
}
public class ITCProblem 
{
	public static void main(String[] args) 
	{		
		Test t = new Test();
		Thread t1 = new Thread(t);		
		t1.start();
		try
		{
			Thread.sleep(200);
		}
		catch (Exception e)
		{
		}		
	    
		System.out.println(t.var);
	}
}

Note :- From the above program it is clear that there is no communication between main thread and child thread so the value of var variable depends upon loop iteration.
--------------------------------------------------------------------
The above program we can write with ITC concept so every time we will get correct output.

//Communication between main thread and child thread using ITC

class SecondThread extends Thread 
{
	    int x = 0;

	    @Override
		public void run() 
		{
			//Child Thread is waiting here for the lock
			synchronized(this) 
			{
				for(int i=1; i<=100; i++)
				{
					x =  x + i;
				}
				System.out.println("Sending notification");
				notify();  //will give notification to waiting thread
			}
	 }
} 
public class InterThreadComm
{
public static void main(String [] args) 
{
		SecondThread b = new SecondThread();  
		b.start();

		synchronized(b)  //lock is taken by main thread
			{
				//suspended
				try 
				{
					System.out.println("Waiting for b to complete...");
					b.wait();  // after releasing the lock, waiting here 
					System.out.println("Main thread wake up");
				} 
				catch (InterruptedException e)
				{
				}
				System.out.println("Value is: " + b.x);
			}		
	}
}
--------------------------------------------------------------------
//Program that describes how to communicate between deposit and withdraw thread using ITC.

class Customer
{  
     int balance=10000;    

	synchronized void withdraw(int amount)   //amount = 15000
	{  
		System.out.println("going to withdraw...");    
		if(balance < amount)
			{  
				System.out.println("Less balance; waiting for deposit...");  
					try
					{
						wait();  //waiting and releasing the lock
					}
					catch(Exception e){}  
			}  
		balance  = balance - amount;
		System.out.println("withdraw completed..."+balance+" is remaining balance"); 
	}    

	synchronized void deposit(int amount)  //amount =10000
		{  
			System.out.println("going to deposit...");  
			balance = balance + amount;  
			System.out.println("Balance after deposit is :"+balance);
			System.out.println("deposit completed... ");  
			notify();  
		}  
}   
public class InterThreadBalance
{  
public static void main(String args[])
	{  
      Customer c = new Customer();    //lock is created here

		Thread son = new Thread()  //anonymous class concept
		{  
			@Override
			public void run()
			{
				c.withdraw(15000);
			}  
		};
		son.start(); 		

		Thread father = new Thread()
		{  
			public void run()
			{
				c.deposit(10000);
			}  
		};
		
		father.start();  
    }
} 
--------------------------------------------------------------------
01-01-2024
----------
interrupt() method of Thread class :
------------------------------------
It is a predefined method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the
thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.
-----------------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println(t.isInterrupted()); 
       
	   for(int i=1; i<=10; i++)
		{
		   System.out.println(i);
		   try
		   {
			Thread.sleep(1000);
		   }
		   catch (Exception e)
		   {
			   System.err.println("Thread is Interrupted ");
			   e.printStackTrace();
		   }
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
		Interrupt it = new Interrupt();
		System.out.println(it.getState());  //NEW STATE
		it.start();
		it.interrupt();  //main thread is interrupting the child thread
	}
}
----------------------------------------------------------------------
class Interrupt extends Thread
{
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt();

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{
		System.out.println("Main thread is started");
		Interrupt it = new Interrupt();
		it.start();
		System.out.println("Main thread is ended");
	}
}

-----------------------------------------------------------------------
public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
            Thread.sleep(5000);  //main thread is waiting for 2 sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }

        
        thread.interrupt();
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running...");
                Thread.sleep(500);
            }
        } 
		catch (InterruptedException e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}

Note :- Here main thread is in sleeping mode for 5 sec, after wake up main thread is interrupting child thread so child thread will come out from infinite loop and if any resource is attached with child thread that will be released because child thread execution completed.
----------------------------------------------------------------------
Thread Group :-
--------------
There is a predefined class called ThreadGroup available in java.lang package.

In Java it is possible to group multiple threads in a single object so, we can perform a particular operation on a group of threads by a single method call.

The Thread class has the following constructor for ThreadGroup 

new Thread(ThreadGroup groupName, Runnable target, String name);
----------------------------------------------------------------------
public class ThreadGroupDemo1
{
   public static void main(String[] args) 
	{       
        ThreadGroup myThreadGroup = new ThreadGroup("NIT_Thread");

        // Create and start threads within the ThreadGroup

        Thread thread1 = new Thread(myThreadGroup, new MyRunnable(), "Thread 1");

        Thread thread2 = new Thread(myThreadGroup, new MyRunnable(), "Thread 2");

        Thread thread3 = new Thread(myThreadGroup, new MyRunnable(), "Thread 3");

        Thread thread4 = new Thread(myThreadGroup, new MyRunnable(), "Thread 4");
        
        
        thread1.start();
        thread2.start();
		thread3.start();
		thread4.start();

		

        // Display information about the ThreadGroup and its threads
        System.out.println("ThreadGroup Name: " + myThreadGroup.getName());

        System.out.println("Active Count: " + myThreadGroup.activeCount());       
    }


    static class MyRunnable implements Runnable //static nested inner 
	{
        @Override
        public void run() 
		{
            for (int i = 0; i < 3; i++) 
			{
                System.out.println(Thread.currentThread().getName() + ": " + i);
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        }
    }
}


Note :- java.lang.ThreadGroup class contains getName() and activeCount() method.

getName() method will return the name of the group where as activeCount() method will return the total number of threads running under that group.
----------------------------------------------------------------------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state.

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = "Ameerpet";  
     String resource2 = "Hyderabad";  

    // t1 tries to lock resource1 then resource2

    Thread t1 = new Thread() 
		{
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			   try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}
				  
			   synchronized (resource2) //Inner synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
		{
      @Override
      public void run() 
		  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
          try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			{}

          synchronized (resource1) //Inner synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}
---------------------------------------------------------------------

class Demo 
{
	public static void main(String[] args)  throws InterruptedException
	{
		Thread t = Thread.currentThread();
      for(int i =1; i<=10; i++)
		{
		  System.out.println(i);
		  t.join();
		}
	}
}
In the above program main thread is blocking it self
----------------------------------------------------------------------
Daemon Thread :
----------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed than JVM will terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a  Daemon thread , we should use setDaemon(true)
----------------------------------------------------------------------
public class DaemonThreadDemo1 
{
  public static void main(String[] args) 
	{
	    System.out.println("Main Thread Started...");
        Thread daemonThread = new Thread(() -> 
		{
            while (true) 
			{
                System.out.println("Daemon Thread is running...");
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); 
        daemonThread.start();

        
        Thread userThread = new Thread(() -> 
		{
            for (int i = 1; i <= 9; i++) 
			{
                System.out.println("User Thread: " + i);
                try 
				{
                    Thread.sleep(2000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        userThread.start();

        System.out.println("Main Thread Ended...");
    }
}
---------------------------------------------------------------------
02-01-2024
-----------
Remaining method of Object class :
---------------------------------
Object cloning in java :
----------------------------
Object cloning is the process of creating an exact copy of an existing object in the memory.

Object cloning can be done by the following process :

1) Creating Shallow copy 

2) Creating Deep copy

3) Using clone() method of java.lang.Object class

4) Passing Object reference to the Constructor


Shallow Copy :
-----------------
In shallow copy, we create a new reference variable which will point to same old existing object so if we make any changes through any of the reference variable then original object content will be modified.

Here we have one object and multiple reference variables.

ShallowCopy.java
------------------
package com.ravi.clone_method;

class Student
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Id is :" + id + "\nName is :" + name ;
	}
	
}
public class ShallowCopy 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.id = 111;
		s1.name = "Ravi";
        
		System.out.println(s1);
		
		System.out.println("After Shallow Copy");
		
		Student s2 = s1; //shallow copy
		s2.id = 222;
		s2.name = "Shankar";
		
		System.out.println(s1);
		System.out.println(s2);
		
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}

}
----------------------------------------------------------------------
Deep Copy :
--------------
In deep copy, We create a copy of object in a different memory location. This is called a Deep copy. Here objects are created in two different memory locations so if we modify the content of one object it will not reflect another object.

DeepCopy.java
--------------

package com.ravi.clone_method;

class Employee
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Employee [id=" + id + ", name=" + name + "]";
	}	
}

public class DeepCopy 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee();
		e1.id = 111;
		e1.name = "Ravi";
		
		Employee e2 = new Employee();
		e2.id = e1.id;
		e2.name = e1.name;
		
		System.out.println(e1 +" : "+e2);
		
		e2.id = 222;
		e2.name = "shankar";
		System.out.println(e1 +" : "+e2);
		
		System.out.println(e1.hashCode() +" : "+e2.hashCode());
	}

}
----------------------------------------------------------------------
protected native Object clone() throws CloneNotSupportedException
----------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object.

In order to use clone() method , a class must implements Clonable interface because we can perform cloning operation on Cloneable objects only [JVM must have additional information].

We can say an objeect is a Cloneable object if the corresponding class implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

Note :- clone() method is not the part of Clonable interface[marker interface], actually it is the method of Object class.

clone() method of Object class follow deep copy concept so hashcode 
will be different.
----------------------------------------------------------------------
package com.ravi.clone_method;

class Customer implements Cloneable
{
	int id;
	String name;	
	
	@Override
	protected Object clone() throws CloneNotSupportedException 
	{
		return super.clone();
	}

	@Override
	public String toString()
	{
		return "Customer [id=" + id + ", name=" + name + "]";
	}	
}

public class CloneMethod 
{
	public static void main(String[] args) throws CloneNotSupportedException 
    {
		Customer c1 = new Customer();	
		c1.id = 111;
		c1.name = "Ravi";
		
		Customer c2 = (Customer) c1.clone();
		System.out.println(c1 +" : "+c2);
		
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		
		
	}

}

Note :- The need of marker interface to provide addition information to JVM regarding the object. [Serializable and Cloneable]
---------------------------------------------------------------------
protected void finalize() throws Throwable  :
---------------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

package com.ravi.finalize_method;

public class Student 
{
    int id;
    String name;
    
    public Student(int id, String name)
    {
    	this.id= id;
    	this.name = name;
    }    
    
	@Override
	public String toString() 
	{
		return "Id is :"+id+"\nName is :"+name;
	}

	@Override
	protected void finalize() 
	{
      System.out.println("JVM call this finalize method...");		
	}


	public static void main(String[] args) throws InterruptedException 
	{
      Student s1 = new Student(111,"Ravi");
      System.out.println(s1.hashCode());
      System.out.println(s1);
      
      s1 = null;
      System.gc(); //Explicitly calling Garbage Collector
      Thread.sleep(3000);
      System.out.println(s1);
	}

}
----------------------------------------------------------------------
*What is the difference between final, finally and finalize

final :- It is a keyword which is used to provide some kind of           restriction like class is final, Method is
         final,variable is final.

finally :- if we open any resource as a part of try block then 
           that particular resource must be closed inside 
	   finally block otherwise program will be terminated normally and the corresponding resource will not be closed.

finalize() :- It is a method which JVM is calling automatically               just before object  destruction so if any resource
              (database, file and network) is associated with
	      that particular object then it will be closes
	      or de-allocated by JVM by calling finalize().
-----------------------------------------------------------------------
Collection Framework in java (40 - 45% IQ):
-------------------------------------------
Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface).

We know only object can move from one network to another network.

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.

It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)

Collection is an interface in java.util package where as Collections is predefined class which contains various static method available in java.util package.
----------------------------------------------------------------------
Methods of Collection interface :
---------------------------------
a) public boolean add(Object element) :- It is used to add an item/element in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean remove(Object element) :- It is used to delete an element from the collection.

d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element. (Common Element)

f) public int size() :- It is used to find out the size of the Collection.

g) public void clear() :- It is used to clear all the elements at once from the Collection.
---------------------------------------------------------------------
04-01-2024
----------
List interface :
----------------
It is the sub interface of Collection interface.
It works on the basis of index.
We can perform sorting operation manually.
It accepts duplicate elements.

Behavior of List interface specific classes :
---------------------------------------------
1) It accepts hetrogeneous types of element.
2) It stores the data index wise.
3) It can accept duplicate elements.
4) It stores everything in the form of obejct.
5) IT IS DYNAMICALLY GROWABLE
6) null values are allowed.
7) By default we can add any type of object using Collection
   so compiler will generate warning message. By using Generic(<>) 
   concept now we can eliminate compilation warning and it will accept 
   homogeneous and hetrogeneous both.

   Vector<Object> v1 = new Vector<>();  //generic
		v1.add(12);
		v1.add(13);
        v1.add(14);
		v1.add(15);
		v1.add(true);
				
        for (Object i : v1)
        {
			System.out.println(i);
        }


Hierarchy of List interface :
------------------------------
Diagram (04-JAN-24)
-----------------------------------------------------------------------
Methods of List interface :
---------------------------
Methods of List interface :
------------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public void clear() :- Will clear all the elements

3) public int size() :- To get the size of the Collections

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position

7) public Object set(int index, Object o) :- To override or replace the existing element based on the index position

8) public Object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element, It is the Collection interface method extended by List interface 

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction
------------------------------------------------------------------------
How many ways we can fetch Collection Object from Collections Framework
-----------------------------------------------------------------------
There are 7 ways to fetch the collection object from collection framework:

1) By using Enumeration interface 
2) By using Ordinary for loop
3) By using for each loop
4) By using Iterator interface
*5) By using ListIterator interface
*6) By using forEach() method
*7) By using method reference (::)

Among all these 7 ways Enumeration, Iterator and ListIterator are the cursor.
-----------------------------------------------------------------------
How forEach() method works internally :
----------------------------------------
package com.ravi.data_hiding;

import java.util.Vector;

public class ForEachMethodInternal 
{
	public static void main(String[] args) 
	{
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		
		fruits.forEach(fruit-> System.out.println(fruit));

	}

}
-----------------------------------------------------------------------
package com.ravi.data_hiding;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachMethodInternal 
{
	public static void main(String[] args) 
	{
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		
		Consumer<String> cons = new Consumer<String>() 
		{
			@Override
			public void accept(String t) 
			{
				System.out.println(t.toUpperCase());			
			}
		};

		fruits.forEach(cons);
	}

}
-----------------------------------------------------------------------
How Method reference works internnally :
-----------------------------------------
3 Files :
--------
Worker.java
-----------
package com.ravi.method_ref;

public interface Worker 
{
  void work();
}

Employee.java
-------------
package com.ravi.method_ref;

public class Employee 
{
  public static void work()
  {
	  System.out.println("Employee is working");
  }
}


Main.java
----------
package com.ravi.method_ref;

public class Main 
{
	public static void main(String[] args) 
	{
	  //By using Lambda
	  Worker w1 = ()-> System.out.println("Scott is Working");
	  w1.work();
	  
	  //By using Method reference (::)
	  Worker w2 = Employee::work;
	  w2.work();
	  
	}
}
-----------------------------------------------------------------------
05-01-2024
----------
Program to fetch collection object using different ways :
---------------------------------------------------------
 Enumeration :
----------------
It is a predefined interface available in java.util package from JDK 1.0 onwards.

We can use Enumeration interface to fetch or retrieve the Objects one by one from the Collection because it is a cursor.

We can create Enumeration object by using elements() method of the respective Collection class.

public Enumeration elements();   

Enumeration interface contains two method :
---------------------------------------------------
1) public boolean hasMoreElements() :- It will return true if the Collection is having more elements.

2) public Object nextElement() :- It will return collection object so return type is Object.

-----------------------------------------------------------------------
Iterator interface :
----------------------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only because it is also a cursor.

public Iterator iterator();

Example :
-----------
 Iterator itr = v.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify, the element is available in the next position or not, if available it will return true otherwise it will return false.

public Object next() :- It will return the collection object.
-------------------------------------------------------------------

ListIterator interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   v.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method in ListIterartor interface
By using forEach() method :
--------------------------------
From java 1.8 onwards every collection class provides a method forEach() method, this method takes Consumer functional interface as a  parameter.
-----------------------------------------------------------------------
//Program to fetch the Collection Object data using different ways

package com.ravi.collection;

import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Vector;

public class RetrievingCollectionObject 
{
	public static void main(String[] args)
	{
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
        Collections.sort(fruits);
                
        System.out.println("DATA THROUGH ENUMERATION ");
        
        Enumeration<String> ele = fruits.elements();
        
        while(ele.hasMoreElements())
        {
        	System.out.println(ele.nextElement());
        }
        
        System.out.println("DATA THROUGH ORDINARY FOR LOOP ");
        
        for(int i=0; i<fruits.size(); i++)
        {
        	System.out.println(fruits.get(i));
        }
        
        System.out.println("DATA THROUGH FOR EACH LOOP ");
        
        for(String fruit : fruits)
        {
        	System.out.println(fruit);
        }
        
        System.out.println("DATA THROUGH ITERATOR INTERFACE ");
        
        Iterator<String> itr = fruits.iterator();
        while(itr.hasNext())
        {
        	System.out.println(itr.next());
        }
        
        System.out.println("DATA THROUGH LISTITERATOR INTERFACE ");
        
        ListIterator<String> listItr = fruits.listIterator();
        
        System.out.println("READING IN FORWARD DIRECTION");
        
        while(listItr.hasNext())
        {
        	System.out.println(listItr.next());
        }
        
        System.out.println("READING IN BACKWARD DIRECTION");
        
        while(listItr.hasPrevious())
        {
        	System.out.println(listItr.previous());
        }
        
        System.out.println("DATA THROUGH FOREACH METHOD");
        
        fruits.forEach(fruit -> System.out.println(fruit));
        
        System.out.println("DATA THROUGH METHOD REFERENCE");
        fruits.forEach(System.out::println);
        
	}
}
----------------------------------------------------------------------
ArrayList :
-----------
public class ArrayList<E>  extends AbstractList<E> implements List<E>, Serializable, Clonable, RandomAccess

It is a predefined class available in java.util package under List interface.

It accepts duplicate elements and null values.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to dynamic array.

Initial capacity of ArrayList is 10. The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3/2) + 1

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList. 

*It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

It implements List,Serializable, Clonable, RandomAccess interfcaes

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :
----------------------------
We have 3 types of Constructor in ArrayList

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with user specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object   reference (Coping one Collection data to another) ---------------------------------------------------------------
Note :- Collections  is a predefined class in java.util where as Collection is an interface in java.util.
-----------------------------------------------------------------------
//Program where Collection holds custom Objects

2 Files :
---------
Employee.java
-------------
package com.ravi.arraylist_demo;

public class Employee 
{
  private Integer employeeId;
  private String employeeName;
  private Double employeeSalary;
  
	public Employee(Integer employeeId, String employeeName, Double employeeSalary) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}
  
}

package com.ravi.arraylist_demo;

ArrayListApp.java
------------------
import java.util.ArrayList;

public class ArrayListApp {

	public static void main(String[] args) 
	{
		ArrayList<Employee> listOfEmployees = new ArrayList<>();
		listOfEmployees.add(new Employee(1, "A", 12000.89));
		listOfEmployees.add(new Employee(2, "B", 12000.89));
		listOfEmployees.add(new Employee(3, "C", 12000.89));

	}
}
-----------------------------------------------------------------------
06-01-2024
-----------
import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		System.out.println("Contents :"+arl); //toString()  [Apple,....]

		arl.remove(2); //based on the index position
		arl.remove("Guava"); //based on the Object

		System.out.println("Contents After Removing :"+arl);
		System.out.println("Size of the ArrayList:"+arl.size());

		Collections.sort(arl); 
		
	    arl.forEach(System.out::println);	
	}
}
-----------------------------------------------------------------------
//Program to merge and retain of two collection 
import java.util.*;
public class ArrayListDemo2
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

          al1.forEach(x -> System.out.println(x.toUpperCase()));

          System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

          al3.forEach(x -> System.out.println(x));		  
     }
}
----------------------------------------------------------------------
//Program to fetch the elements in forward and backward 
//direction using ListIterator interface

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo3   
{                             
public static void main(String args[])
	{
	  List<String> nameList = Arrays.asList("Ravi","Rahul","Raj","Scott");
	  
	  Collections.sort(nameList);
	  
	  ListIterator<String> lst = nameList.listIterator();
	  System.out.println("In Forward Direction");
	  
	  while(lst.hasNext())
	  {
		  System.out.println(lst.next());
	  }
	  
     System.out.println("In Backward Direction");
	  
	  while(lst.hasPrevious())
	  {
		  System.out.println(lst.previous());
	  }
	  
	}
}
-----------------------------------------------------------------------
//Serialization and De-serialization on ArrayList Object
import java.io.*;  
import java.util.*;  
 public class ArrayListDemo4
	 {  
        public static void main(String [] args)  throws IOException
         {  
           ArrayList<String> al=new ArrayList<String>();  
           al.add("Nagpur");    
           al.add("Vijaywada");    
           al.add("Hyderabad");
		   al.add("Jamshedpur");       
          
				//Serialization  
				FileOutputStream fos=new FileOutputStream("E:\\new\\City.txt");  

				ObjectOutputStream oos=new ObjectOutputStream(fos); 
				 //Deserialization  
				FileInputStream fis=new FileInputStream("E:\\new\\City.txt");
				
				ObjectInputStream ois=new ObjectInputStream(fis); 

				try (fos; oos; fis; ois) 
                {  
				 oos.writeObject(al);  	//Serialization

	ArrayList list = (ArrayList) ois.readObject(); //De-Serialization
				System.out.println(list);    
                }
			  catch(Exception e)  
			  {  
				  System.err.println(e);  
			  }  
       }  
    }         

-----------------------------------------------------------------------
Program on Serialization and De-Serialization 

2 Files :
---------
Product.java
-------------
package com.ravi.serialization;

import java.io.Serializable;

public class Product implements Serializable
{
  private Integer productId;
  private String productName;
  private Double productPrice;
  
	public Product(Integer productId, String productName, Double productPrice) {
		super();
		this.productId = productId;
		this.productName = productName;
		this.productPrice = productPrice;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + ", productPrice=" + productPrice
				+ "]";
	}
  
	
  
  
  
}

ArrayListSerialization.java
----------------------------
package com.ravi.serialization;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

public class ArrayListSerialization {

	public static void main(String[] args) throws IOException 
	{		
		ArrayList<Product> listOfProduct = new ArrayList<>();
		listOfProduct.add(new Product(1, "Camera", 12890.89));
		listOfProduct.add(new Product(2, "Laptop", 12890.89));
		listOfProduct.add(new Product(3, "Mobile", 12890.89));
		
		var fos = new FileOutputStream("C:\\new\\ProductList.txt");
		var oos = new ObjectOutputStream(fos);
		
		var fin = new FileInputStream("C:\\new\\ProductList.txt");
		var ois = new ObjectInputStream(fin);
		
		try(fos; oos; fin; ois)
		{
			//Serialization
			oos.writeObject(listOfProduct);
			
		ArrayList<Product> prod = (ArrayList<Product>)ois.readObject();
		System.out.println(prod);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}

}

Note :Here Product class also must implements Serializable interface
-----------------------------------------------------------------------
public void ensureCapacity(int minimumCapacity) :-
-----------------------------------------------
It is a predefined method of ArrayList class, by using this method we can resize the capacity of ArrayList Object.

Here by specifying the parameter it ensures that it can hold at least the number of elements specified by the minimum capacity argument.

ArrayList class does not provide capacity() method support.
-------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo5
{
	public static void main(String[] args) 
	{
		ArrayList<String> city= new ArrayList<>();//default capacity is 10
		city.ensureCapacity(3);//resized the arraylist to store 3 elements.

	
		city.add("Hyderabad");
		city.add("Mumbai");
		city.add("Delhi"); 

		city.add("Kolkata");
		System.out.println("ArrayList: " + city);		
	 }
}
----------------------------------------------------------------------
//Program on ArrayList that contains null values as well as we can pass the element based on the index position
import java.util.*;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<Object>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); //add(int index, Object o)method of List interface
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);
	}
}
----------------------------------------------------------------------
Limitation of ArrayList :
-------------------------
Limitation of ArrayList :
-------------------------
The time complexcity of ArrayList to insert and delete an element from the middle would be O(n) because 'n' number of elements will be re-located so it is not a good choice to perform insertion and deletion operation in the middle of the List.

To avoid this we introduced LinkedList.
--------------------------------------------------------------------
07-01-2024
-----------
LinkedList :
------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.5 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

ArrayList is using Array data structure but LinkedList class is using LinkedList data structure.

Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection

Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

Note :- It stores the elements in non-contiguous memory location.           
	   
	   The time complexcity for insertion and deletion is  O(1)

	   The time complexcity for seraching O(n)
------------------------------------------------------------------
import java.util.*;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      List list=new LinkedList();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);
	  
	 list.forEach(x -> System.out.println(x));
  }
}

------------------------------------------------------------------
//Frequent insertion and deletion operation
import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2
           list.add("Item 3");//3
           list.add("Item 4");//4
           list.add("Item 5");//5
           list.add("Item 6");//6
           list.add("Item 7");//7
           list.add("Item 9"); //10

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1


           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
            list.remove("Item 5"); 
            System.out.println(list);
          
            list.removeLast();
            System.out.println(list);
         
			list.removeFirst();
            System.out.println(list);
         
           list.set(0,"Ajay"); //set() will replace the existing value
           list.set(1,"Vijay");
           list.set(2,"Anand");
           list.set(3,"Aman");
           list.set(4,"Suresh"); 
           list.set(5,"Ganesh");
           list.set(6,"Ramesh");
           list.forEach(x -> System.out.println(x)); 
			
      } 
}
------------------------------------------------------------------
//ListIterator methods [add(), set() and remove()]
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<>();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city); 

		ListIterator<String> lt = city.listIterator();

         while(lt.hasNext())
		  {
			String x =  lt.next();

			if(x.equals("Kolkata"))
			{
                   lt.remove();
			}
			else if(x.equals("Hyderabad"))
			{
                   lt.add("Ameerpet");
			}
			else if(x.equals("Pune"))
			{
                   lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println); //Method Reference
	}
}

------------------------------------------------------------------
//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.Scanner;

public class LinkedListDemo4
{
   public static void main(String[] args)
	{
        LinkedList<Integer> linkedList = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Linked List: " + linkedList);
            System.out.println("1. Insert Element");
            System.out.println("2. Delete Element");
			System.out.println("3. Display Element");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");

            int choice = scanner.nextInt();
            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to insert: ");
                    int elementToAdd = scanner.nextInt();
                    linkedList.add(elementToAdd);
                    break;
                case 2:
                    if (linkedList.isEmpty()) 
					{
                        System.out.println("Linked list is empty. Nothing to delete.");
                    } 
					else 
					{
                        System.out.print("Enter the element to delete: ");
                        int elementToDelete = scanner.nextInt();
                        boolean removed =        linkedList.remove(Integer.valueOf(elementToDelete));
                        
                        if (removed) 
						{
                            System.out.println("Element " + elementToDelete + " deleted from the linked list.");
                        } 
						else
						{
                            System.out.println("Element not found in the linked list.");
                        }
                    }
                    break;
				case 3:
					System.out.println("Elements in the linked list.");
                     linkedList.forEach(System.out::println);
				     break;
                case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}
-------------------------------------------------------------------
import java.util.LinkedList;
import java.util.Iterator;
import java.util.List;

class Dog 
{
      public String name;
      Dog(String n) 
      {
           name = n;
      }

    public String toString()
	{
		return this.name;
	}
}
public class LinkedListDemo5
{
       public static void main(String[] args)
       {
             List<Dog> d = new LinkedList<>();
             Dog dog = new Dog("Tiger");
             d.add(dog);
             d.add(new Dog("Tommy"));
             d.add(new Dog("Rocky"));

             Iterator<Dog> i3 = d.iterator();
		    i3.forEachRemaining(x -> System.out.println(x.name)); //java 8      


             System.out.println("size " + d.size());
             System.out.println("Get 1st Position Object " + d.get(1).name);
             
            
        }
}
-------------------------------------------------------------------
import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDemo6
{
    public static void main(String[] args) 
		{
        // Create a LinkedList and treat it as a Deque
        Deque<String> deque = new LinkedList<>();

        // Adding elements to the front of the deque
        deque.addFirst("Ravi");
        deque.addFirst("Raj");   

        // Adding elements to the back of the deque
        deque.addLast("Pallavi");
        deque.addLast("Sweta");

        
        System.out.println("Deque: " + deque);

       
        String first = deque.removeFirst();
        String last = deque.removeLast();

       
        System.out.println("Removed first element: " + first);
        System.out.println("Removed last element: " + last);
        System.out.println("Updated Deque: " + deque);
    }
}
-------------------------------------------------------------------
08-01-2024
-----------
Vector :
--------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

It also stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

Just like ArrayList it also implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with user specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int incrementalCapacity);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
      Interconversion between the Collection.

//Vector Program on capacity

package com.ravi.vector;

import java.util.*;
public class VectorDemo1
{
	public static void main(String[] args) 
	{
		Vector<Integer> v = new Vector<>(100, 10);  //initial capacity is 100
		System.out.println("Initial capacity is :"+v.capacity());

      for(int i = 0; i<100; i++)
		{
           v.add(i);
		}

System.out.println("After adding 100 elements  capacity is :"+v.capacity());
v.add(101);		
System.out.println("After adding 101th elements  capacity is :"+v.capacity());

		for(Integer i : v)
		{
			System.out.print(i+"\t");
			if(i%5==0)
				System.out.println();
		}
	}
}
----------------------------------------------------------------------
package com.ravi.vector;

import java.util.Vector;
import java.util.stream.Stream;

class Employee
{
	private Integer employeeId;
	private String employeeName;
	private Double employeeSalry;
	
	public Employee(Integer employeeId, String employeeName, Double employeeSalry) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalry = employeeSalry;
	}

	public Integer getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(Integer employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	public Double getEmployeeSalry() {
		return employeeSalry;
	}

	public void setEmployeeSalry(Double employeeSalry) {
		this.employeeSalry = employeeSalry;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalry="
				+ employeeSalry + "]";
	}	
}


public class VectorDemo2
{ 
	public static void main(String[] args)
	{
		Vector<Employee> emp = new Vector<>();
		emp.add(new Employee(111, "Ravi", 49000.78));
		emp.add(new Employee(222, "Rahul", 37000.78));
		emp.add(new Employee(333, "Anjali", 26000.78));
		emp.add(new Employee(444, "Elina", 30000.78));
		
		//Stream API
		emp.stream().filter(e-> e.getEmployeeSalry()<27000).forEach(e1->System.out.println(e1));

	
	
		
	}
}
----------------------------------------------------------------------
package com.ravi.vector;
//Array To Collection
import java.util.*;
public class VectorDemo3
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();
		
		int x[]={22,20,10,40,15,58};
   
        //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		v.forEach(y -> System.out.println(y));
	}
}
---------------------------------------------------------------------
//Program to describe that ArrayList is better then Vector in performance

package com.ravi.vector;

import java.util.ArrayList;
import java.util.Vector;

public class VectorDemo4 
{
	public static void main(String[] args) 
	{
		long startTime = System.currentTimeMillis();
		ArrayList<Integer> al = new ArrayList<>();
		for(int i=0; i<=1000000; i++)
		{
			al.add(i);
		}
		long endTime = System.currentTimeMillis();
		System.out.println("The total time taken by ArrayList to complete the task :"+(endTime - startTime)+" ms");
		
		startTime = System.currentTimeMillis();
		Vector<Integer> v = new Vector<>();
		for(int i=0; i<=1000000; i++)
		{
			v.add(i);
		}
		endTime = System.currentTimeMillis();
		System.out.println("The total time taken by Vector to complete the task :"+(endTime - startTime)+" ms");
	}
}
----------------------------------------------------------------------
package com.ravi.vector;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.Vector;
import java.util.stream.Collectors;

public class Vector5 {

	public static void main(String[] args) 
	{
		List<Integer> v = Arrays.asList(89,56,34,12,9,15,3,89,34);		
		
		
		//Java 8 Stream API
          Set<Integer> collect = v.stream().filter(n-> n%2==0).sorted().collect(Collectors.toSet());
          
          collect.forEach(System.out::println);
	
	}
}
----------------------------------------------------------------------
Stack :
-------
Stack :
------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the top of the stack is known as pop operation.

It throws an exception called EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack();

------------------------------------------------------------------------------------
Methods :
----------
push(Object o) :- To insert an element

pop() :- To remove and return the element from the top of the Stack

peek() :- Will fetch the element from top of the Stack without removing

empty() :- Verifies whether the stack is empty or not (return type is boolean)

search(Object o) :- It will search a particular element in the Stack and it returns OffSet position. If the element is not present in the Stack it will return -1
----------------------------------------------------------------------
//Program to insert and fetch the elements from stack
package com.ravi.stack;
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
           try
            {     s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 

                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
                  
                  
				  	
	 				 				  
				  System.out.println("After deletion elements are :"+s); //[]
				  System.out.println("Is the Stack empty ? :"+s.empty());
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
      }
}

----------------------------------------------------------------------
//add(Object obj) is the method of Collection
package com.ravi.stack;
import java.util.*;
public class Stack2
{
      public stati
c void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}
----------------------------------------------------------------------
package com.ravi.stack;
import java.util.Stack;  

public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  

----------------------------------------------------------------------
//Searching an element in the Stack
package com.ravi.stack;
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 						
			System.out.println("Offset Position is : " + stk.search("Mango")); //1			
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2
		}  
}  
----------------------------------------------------------------------
09-01-2024
----------
Set interface :
----------------
It is the sub interface of Collection.

Set interface will never accept duplicate elements, Here our best friend is equals(Object obj) method of Object class. If two objects are identical then it will accept only one object.

Set interface does not follow index and we cannot read the data in backward direction (ListIterator will not work)

We cannot perform manual sorting operation using Set interface.

Set interface uses almost all the method of Collection interface.
-----------------------------------------------------------------------
Set interface hierarchy :
-------------------------
Diagram [09-Jan-24]
-----------------------------------------------------------------------
HashSet (UNSORTED, UNORDERED , NO DUPLICATES)
---------------------------------------------
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface.

It is an unsorted and unordered set.  

It accepts hetrogeneous kind of data.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept null value.

HashSet is used for fast searching operation.

It contains 4 types of constructor 
1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with user specified capacity


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4) HashSet hs = new HashSet(Collection c);
    Interconversion of Collection
----------------------------------------------------------------
//Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	    HashSet<Integer> hs = new HashSet<>();
		hs.add(67); 
		hs.add(89);
		hs.add(33);
		hs.add(45);
		hs.add(12);
		hs.add(35);		
				
		hs.forEach(str-> System.out.println(str));
	}
}
----------------------------------------------------------------------
import java.util.*;
public class HashSetDemo1
{
      public static void main(String[] argv) 
      {
      HashSet<String> hs=new HashSet<>();	  
	  hs.add("Ravi");
	  hs.add("Vijay");
	  hs.add("Ravi");
	  hs.add("Ajay");
	  hs.add("Palavi");
	  hs.add("Sweta");
	  hs.add(null);
	  hs.add(null);
	  hs.forEach(str -> System.out.println(str));

      }
}
-----------------------------------------------------------------------
//add() method return type is boolean
package com.ravi.hash_set;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class HashSetDemo2 {

	public static void main(String[] args) 
	{
		boolean []arr = new boolean[5];
		
		Set<Object> set = new HashSet<>();
		arr[0] = set.add(12);
        arr[1]  = set.add(13);
        arr[2] = set.add("ravi");
        arr[3] = set.add(12);
        arr[4] = set.add(new String("NIT"));
        System.out.println(Arrays.toString(arr));
        
        if(set.contains("NIT"))
        {
        	System.out.println("NIT object is available");
        }
        else
        {
        	System.out.println("NIT object is not available");
        }
        System.out.println("..............");
        set.forEach(System.out::println);
	}

}
-----------------------------------------------------------------------
import java.util.HashSet;
import java.util.Scanner;

public class HashSetDemo3
{
    public static void main(String[] args) 
		{
        HashSet<String> hashSet = new HashSet<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Options:");
            System.out.println("1. Add element");
            System.out.println("2. Delete element");
            System.out.println("3. Display HashSet");
            System.out.println("4. Exit");

            System.out.print("Enter your choice (1/2/3/4): ");
            int choice = scanner.nextInt();

            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to add: ");
                    String elementToAdd = scanner.next();
                    if (hashSet.add(elementToAdd)) 
					{
                        System.out.println("Element added successfully.");
                    } 
					else
					{
                        System.out.println("Element already exists in the HashSet.");
                    }
                    break;
                    case 2:
                    System.out.print("Enter the element to delete: ");
                    String elementToDelete = scanner.next();
                    if (hashSet.remove(elementToDelete)) 
					{
                        System.out.println("Element deleted successfully.");
                    } 
					else 
					{
                        System.out.println("Element not found in the HashSet.");
                    }
                    break;
                    case 3:
                    System.out.println("Elements in the HashSet:");
                    for (String element : hashSet) {
                        System.out.println(element);
                    }
                    break;
                    case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                    default:
                    System.out.println("Invalid choice. Please try again.");
            }

            System.out.println(); 
        }
    }
}
-----------------------------------------------------------------------
LinkedHashSet :
---------------
LinkedHashSet :
------------------
public class LinkedHashSet extends HashSet implements Set, Clonable, Serializable

It is a predefined class in java.util package under Set interface. 

It is the sub class of HashSet class.

It is an orderd version of HashSet that maintains a doubly linked list across all the elements.

We should use LinkedHashSet class when we want to maintain an order.

When we iterate the elements through HashSet the order will be unpredictable, while when we iterate the elments through LinkedHashSet then the order will be same as they were inserted in the collection.

It accepts hetrogeneous and null value is allowed.

It has same constructor as HashSet class.
-----------------------------------------------------------------------
import java.util.*;
public class LinkedHashSetDemo
{
 public static void main(String args[])
	{ 
		  LinkedHashSet<String> lhs=new LinkedHashSet<>();
		  lhs.add("Ravi");
		  lhs.add("Vijay");
		  lhs.add("Ravi");
		  lhs.add("Ajay");
		  lhs.add("Pawan");
		  lhs.add("Shiva");
		  lhs.add(null);
		  lhs.add("Ganesh");          
		  lhs.forEach(str -> System.out.println(str));	   
	}
}
-----------------------------------------------------------------------
import java.util.LinkedHashSet;

public class LinkedHashSetDemo1 
{
    public static void main(String[] args) 
	{
       LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(15);
        linkedHashSet.add(20);
        linkedHashSet.add(5); 

        System.out.println("LinkedHashSet elements: " + linkedHashSet);

        System.out.println("LinkedHashSet size: " + linkedHashSet.size());

        int elementToCheck = 15;
        if (linkedHashSet.contains(elementToCheck)) 
		{
            System.out.println(elementToCheck + " is present in the LinkedHashSet.");
        } 
		else 
		{
            System.out.println(elementToCheck + " is not present in the LinkedHashSet.");
        }

        int elementToRemove = 10;
        linkedHashSet.remove(elementToRemove);
        System.out.println("After removing " + elementToRemove + ", LinkedHashSet elements: " + linkedHashSet);

              linkedHashSet.clear(); 
        System.out.println("After clearing, LinkedHashSet elements: " + linkedHashSet); 
    }
}
-----------------------------------------------------------------------
SortedSet interface :
------------------------
1) It is the sub interface of Set interface

2) If we don't want duplicate elements and want to store the elements based on some sorting order i.e default natural sorting order then we should go with SortedSet(I)

3) default natural sorting means, if it is number then ascending order and if it is String then dictionary order or Alphabetical order.

4) We have two interfaces Comparable(available in java.lang package) and Comparator (available in java.util package) to compare two objects.
---------------------------------------------------------------
*What is the difference between Comparable and Comparator interface 
---------------------------------------------------------------
Program on Comaparable :
-------------------------
Student.java
------------
package com.ravi.comparable;

public class Student implements Comparable<Student>
{
  private Integer studentId;
  private String studentName;
  private Integer studentAge;
  
	public Student(Integer studentId, String studentName, Integer studentAge) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAge = studentAge;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAge=" + studentAge + "]";
	}

	//Sorted based on the Name
	@Override
	public int compareTo(Student s2) 
	{
		return this.studentName.compareTo(s2.studentName);
	}
  
  
}

StudentComparable.java
-----------------------
package com.ravi.comparable;

import java.util.ArrayList;
import java.util.Collections;

public class StudentComparable {

	public static void main(String[] args) 
	{
		ArrayList<Student> al = new ArrayList<>();
		al.add(new Student(333, "Ankit", 24));
		al.add(new Student(111, "Zuber", 26));
		al.add(new Student(222, "Rahman", 25));
		
		System.out.println("Sorting based on the Name");	
		Collections.sort(al);
		al.forEach(System.out::println);

	}

}
-----------------------------------------------------------------------
Limitation of Comparable interface :
-----------------------------------------
1) We need to modify the original source code (BLC class), If the source code is not available then it is not possible to perform  sorting operation.

2) We can provide only one sorting logic if we want to provide mutiple sorting logic then it is not possible.

To avoid the above said problems we introduced Comparator interface available in java.util package.
-----------------------------------------------------------------------
//Program on Comparator :
-------------------------
Product.java
-------------
package com.ravi.comparator;

public class Product 
{
  private Integer productId;
  private String productName;
  
	public Product(Integer productId, String productName) {
		super();
		this.productId = productId;
		this.productName = productName;
	}

	public Integer getProductId() {
		return productId;
	}

	public void setProductId(Integer productId) {
		this.productId = productId;
	}

	public String getProductName() {
		return productName;
	}

	public void setProductName(String productName) {
		this.productName = productName;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + "]";
	}
  
	
  
}


ProductComparator.java
-----------------------
package com.ravi.comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ProductComparator 
{
	public static void main(String[] args) 
	{
	  ArrayList<Product> al = new ArrayList<>();
	  al.add(new Product(111,"Mobile"));
	  al.add(new Product(333, "Camera"));
	  al.add(new Product(222, "Laptop"));
	  System.out.println("Sorting based on the ID");
	  Comparator<Product> cmpId = (p1, p2)-> p1.getProductId() - p2.getProductId();
	  
	  Collections.sort(al, cmpId);
	  al.forEach(System.out::println);
	  
	  System.out.println("Sorting based on the Name");
	  Comparator<Product> cmpName = (p1,p2)-> p1.getProductName().compareTo(p2.getProductName());

	  Collections.sort(al, cmpName);
	  al.forEach(System.out::println);

	}

}
-----------------------------------------------------------------------
Program that describes how to sort Integer object in descending order by using Comparator interface.

package com.nit;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class IntegerDescending {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		al.add(78);
		al.add(98);
		al.add(88);
		al.add(18);
		
		Comparator<Integer> comp = (i1, i2) -> -(i1 - i2);
		
		Collections.sort(al, comp);
		
		al.forEach(System.out::println);
	}

}
----------------------------------------------------------------------
TreeSet :
----------
public class TreeSet<E> extends AbstractSet<E> implements NavigableSet, Clonable, Serializable

It is a predefined class available in java.util package under Set interface.

TreeSet, TreeMap  and PriorityQueue are the three sorted collection in the entire Collection Framework so these classes never accepting hetrogeneous kind of the data.

It will sort the elements in natural sorting order i.e ascending order in case of number, and alphabetical order or Dictionary order in the case of String. In order to sort the elements It uses Comparator  interface.

It does not accept duplicate and null value(java.lang.NullPointerException).

It does not accept hetrogeneous type of data if we try to insert it will throw a runtime exception i.e java.lang.ClassCastException

TreeSet implements NavigableSet.

NavigableSet extends SortedSet.

It contains 4 types of constructor :
----------------------------------------
1) TreeSet t1 = new TreeSet();
     create an empty TreeSet object, elements will be inserted in a natural sorting order.

2) TreeSet t2 = new TreeSet(Comparator c);
    Customized sorting order

3)  TreeSet t3 = new TreeSet(Collection c);

4) TreeSet t4 = new TreeSet(SortedSet s);
-----------------------------------------------------------------------
//program that describes TreeSet provides default natural sorting order
import java.util.*;
public class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		SortedSet<Integer> t1 = new TreeSet<>();
		t1.add(4);
		t1.add(7);
		t1.add(2);
		t1.add(1);
		t1.add(9);	
	
		System.out.println(t1);

		NavigableSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Banana");
		t2.add("Grapes");
		t2.add("Apple");		
		System.out.println(t2);		
	}
}
-----------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo1
{
	public static void main(String[] args) 
	{
		TreeSet<String> t1 = new TreeSet<>();
		t1.add("Orange");
		t1.add("Mango");
		t1.add("Pear");
		t1.add("Banana");
		t1.add("Apple");	
		System.out.println("In Ascending order");
		t1.forEach(i -> System.out.println(i));

		TreeSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Pear");
		t2.add("Banana");
		t2.add("Apple");

        System.out.println("In Descending order");
		Iterator<String> itr2 = t2.descendingIterator();  //for descending order

         itr2.forEachRemaining(x -> System.out.println(x));		
	}
}

Note :- descendingIterator() is a predefined method of TreeSet class which will traverse in the descending order and return type of this method is Iterator interface.
----------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo2
{
	public static void main(String[] args) 
	{
		Set<String> t = new TreeSet<>();  
		t.add("6");   
		t.add("5");
		t.add("4");
		t.add("2");
		t.add("9");	
		Iterator<String> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x));

		//From 1.8 to replace hasNext() and next() method
	}
}

Note :- Elements are sorted based on the UNICODE 
-----------------------------------------------------------------------
import java.util.*;  

public class TreeSetDemo3 
	{
	public static void main(String[] args)
	{
		Set<Character> t = new TreeSet<>();  
		t.add('A'); 
		t.add('C');
		t.add('B');
		t.add('E');
		t.add('D');	
		Iterator<Character> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x)); 			
	}
}
-----------------------------------------------------------------------
Program on TreeSet for User-defined Sorting logic
--------------------------------------------------
2 files :
---------
Student.java
-------------
package com.ravi.user_defined_sorting_treeset;

public class Student
{
   private Integer studentId;
   private String studentName;
   private Integer studentAge;
   
	public Student(Integer studentId, String studentName, Integer studentAge) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAge = studentAge;
	}

	public Integer getStudentId() {
		return studentId;
	}

	public void setStudentId(Integer studentId) {
		this.studentId = studentId;
	}

	public String getStudentName() {
		return studentName;
	}

	public void setStudentName(String studentName) {
		this.studentName = studentName;
	}

	public Integer getStudentAge() {
		return studentAge;
	}

	public void setStudentAge(Integer studentAge) {
		this.studentAge = studentAge;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAge=" + studentAge + "]";
	}
   
   
}


TreeSetCustomSorting.java
--------------------------
package com.ravi.user_defined_sorting_treeset;

import java.util.TreeSet;

public class TreeSetCustomSorting 
{
	public static void main(String[] args)
	{
		TreeSet<Student> ts1 = new TreeSet<>((s1,s2)-> s1.getStudentId() - s2.getStudentId());
		ts1.add(new Student(1, "Zuber", 27));
		ts1.add(new Student(3, "Ankit", 25));
		ts1.add(new Student(2, "Rahman", 22));
		System.out.println("SORTED ID IN ASCENDING ORDER");
		ts1.forEach(System.out::println);
		
		TreeSet<Student> ts2 = new TreeSet<>((s1,s2)-> -(s1.getStudentId() - s2.getStudentId()));
		ts2.add(new Student(1, "Zuber", 27));
		ts2.add(new Student(3, "Ankit", 25));
		ts2.add(new Student(2, "Rahman", 22));
		System.out.println("SORTED ID IN DESCENDING ORDER");
		ts2.forEach(System.out::println);
		
		
		TreeSet<Student> ts3 = new TreeSet<>((s1,s2)-> s1.getStudentName().compareTo(s2.getStudentName()));
		ts3.add(new Student(1, "Zuber", 27));
		ts3.add(new Student(3, "Ankit", 25));
		ts3.add(new Student(2, "Rahman", 22));
		System.out.println("SORTED NAME IN ASCENDING ORDER");
		ts3.forEach(System.out::println);
		
		
		TreeSet<Student> ts4 = new TreeSet<>((s1,s2)-> -(s1.getStudentName().compareTo(s2.getStudentName())));
		ts4.add(new Student(1, "Zuber", 27));
		ts4.add(new Student(3, "Ankit", 25));
		ts4.add(new Student(2, "Rahman", 22));
		System.out.println("SORTED NAME IN DESCENDING ORDER");
		ts4.forEach(System.out::println);

	}

}
-----------------------------------------------------------------------
Methods of SortedSet interface :
--------------------------------------
public E first() :- Will fetch first element

public E last() :- Will fetch last element

public SortedSet headSet(int range) :- Will fetch the values which are less than specified range

public SortedSet tailSet(int range) :- Will fetch the values which are equal or greater than the specified range.

public SortedSet subSet(int startRange, int endRange) :- Will fetch the range of values where startRange is inclusive and endRange is exclusive
--------------------------------------------------------------
import java.util.*;
public class SortedSetMethodDemo
{
       public static void main(String[] args) 
       {
            TreeSet<Integer> times = new TreeSet<>();
            times.add(1205);
            times.add(1505);
            times.add(1545);
			times.add(1600);
            times.add(1830);
            times.add(2010);
            times.add(2100);
            
            SortedSet<Integer> sub = new TreeSet<>();
            
			sub =  times.subSet(1545,2100); 
            System.out.println("Using subSet() :-"+sub);//[1545, 1600,1830,2010]
            System.out.println(sub.first());
            System.out.println(sub.last());   
			
		    sub = times.headSet(1545); 
			System.out.println("Using headSet() :-"+sub); //[1205, 1505]

		     sub =  times.tailSet(1545); 
			 System.out.println("Using tailSet() :-"+sub); //[1545 to 2100] 
       }
}
-----------------------------------------------------------------------
NavigableSet(I) :
-----------------
With the help of SortedSet interface method we can find out the range of values but we can't navigate among those elements.

Now to frequently navigate among those range of elements, Java software people introduced new interface called NavigableSet from 1.6V
-------------------------------------------------------------
import java.util.*;

public class NavigableSetDemo 
{   
    public static void main(String[] args)
    {
        NavigableSet<Integer> ns = new TreeSet<>(); 
        ns.add(1);
        ns.add(2);
        ns.add(3);
        ns.add(4);
        ns.add(5);
        ns.add(6);

		System.out.println("lower(3): " + ns.lower(3));//Just below than the specified element or null

        System.out.println("floor(3): " + ns.floor(0)); //Equal  less or null
      
        System.out.println("higher(3): " + ns.higher(3));//Just greater than specified element or null

       System.out.println("ceiling(3): " + ns.ceiling(3));//Equal or greater or null
	   
        		
    }
}
----------------------------------------------------------------------
12-01-2024
----------
Map interface :
---------------
As we know Collection interface is used to hold single Or individual object but Map interface will hold group of objects in the form key and value pair. {key = value}

Map interface is not the part the Collection.

Before Map interface We had Dictionary(abstract class) class and it is extended by Hashtable class in JDK 1.0V

Map interface works with key and value pair introduced from 1.2V.

Here key and value both are objects.

Here key must be unique and value may be duplicate.

Each key and value pair is creating one Entry.(Entry is nothing but the combination of key and value pair)

interface Map
{
   
     interface Entry
      {
      }
}

How to represent this entry interface (Map.Entry in .java) [Map$Entry in .class]

In Map interface whenever we have a duplicate key then the old key value will be replaced by new key(duplicate key) value.
--------------------------------------------------------------
Map interface Hierarchy :
--------------------------
Available in the diagram [12-JAN-24]

Methods of Map interface :
--------------------------
1) Object put(Object key, Object value) :- To insert one entry in the Map collection. It will return the old object value if the key is already available(Duplicate key).

2) void putAll(Map m) :- Merging of two Map collection

3) int size() :- To count the number of Entries.

4) void clear() :- Used to clear the Map

5) boolean isEmpty() :- To verify Map is empty or not?

6) boolean containsKey(Object key) :- To Search a particular key

7) boolean containsValue(Object value) :- To Search a particular value

8) Object get(Object key) :- It will return  corresponding value of key, if the key is not present then it will return null.

9) Object getOrDefault(Object key, Object defaultValue) :- To avoid null value this method has been introduced, here we can pass some defaultValue to avoid the null value.

10) remove(Object key) :- One complete entry will be removed.

11) putIfAbsent(Object key, Object value) :- It will insert an entry if and only if key is not present , if the key is already available then it will not insert the Entry to the Map Collection

Collection views Methods :
------------------------------
public Set keySet() :- Will return only keys (Set of keys)

Collection values() :- Will return all values.

Set<Map.Entry> entrySet() :- It will return key and value pair in the form of Entry.

          a) getKey()    b) getValue()   c) setValue()
---------------------------------------------------------------------
19-01-2024
----------
*** How HashMap Works internally ?
----------------------------------
a) While working with HashSet or HashMap every object must be compared because duplicate objects are not allowed.

b) Whenever we add any new key to verify whether key is unique or duplicate, HashMap internally uses hashCode(), == operator and equals method.

c) While adding the key object in the HashMap, first of all it will invoke the hashCode() method to retrieve the corresponding key hashcode value.
    Example :- hm.put(key,value);
               then internally key.hashCode();

d) If the newly added key and existing key hashCode value both are same (Hash collision), then only == operator is used for comparing those keys by using reference or memory address, if both keys references are same then existing key value will be replaced with new key value.

        If the reference of both keys are different then equals(Object obj) method is invoked to compare those keys by using state(data). [content comparison]

	If the equals(Object obj) method returns true (content wise both keys are same), this new key is duplicate then existing key value will be replaced.

	If equals(Object obj) method returns false, this new key is unique, new entry (key-value) will be inserted.

	Note :- equals(Object obj) method is invoked only when two keys are having same hashcode as well as their references are different.

e) Actually by calling hashcode method we are not comparing the objects, we are just storing the objects in a group so the currently adding key object will be compared with its HASHCODE GROUP objects, but not with all the keys which are available in the Map.

f) The main purpose of storing objects into the corresponding group to decrease the number of comparison so the efficiency of the program will increase.

g) To insert an entry in the HashMap, HashMap internally uses Hashtable data structure

h) Now, for storing same hashcode object into a single group, hash table data structure internally uses one more data structure called Bucket.

i) The Hash table data structure internally uses Node class array object.

j) The bucket data structure internally uses LinkedList data structure, It is a single linked list again implemented by Node class only.

k) A bucket is group of entries of same hash code keys.

l) Performance wise LinkedList is not good to serach, so from java 8 onwards LinkedList is changed to Binary tree to decrease the number of comparison within the same bucket hashcode if the number of entries are greater than 8.

equals() and hashCode() method contract :
-----------------------------------------
Both the methods are working together to find out the duplicate objects in the Map.

*If equals() method invoked on two objects and it returns true then hashcode of both the objects must be same.
----------------------------------------------------------------------
                HashMap<String,String> hm = new HashMap<String,String>();
		hm.put("Nit", "Hyderabad");
		hm.put(new String("Nit"), "Bangalore");
		System.out.println(hm.size()); //1
		
		HashMap<Integer,Integer> hm1 = new HashMap<>();
		hm1.put(128, 90);
		hm1.put(new Integer(128), 92);
		System.out.println(hm.size()); //1

----------------------------------------------------------------------
package com.ravi.hashmap_working;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) 
	{
		HashMap<Object,Object> hm = new HashMap<>();
		hm.put("A", "Hyderabad");
		hm.put(new String("A"), "Bangalore");
		hm.put(65, "Chennai");
		System.out.println(hm.size()); //2
		System.out.println(hm);
		
		
	}

}
---------------------------------------------------------------------
import java.util.*;
class Employee
{
	int eid;
	String ename;

	Employee(int eid, String ename)
	{
		this.eid = eid;
		this.ename = ename;
	}

    @Override
	public boolean equals(Object obj)  //obj = e2
	{		
		if(obj instanceof Employee)
        {
			Employee e2 = (Employee) obj; //downcasting

			if(this.eid == e2.eid && this.ename.equals(e2.ename))
			{
				return true;
			}
			else
			{
				return false;
			}
	    }
		else
		{
			System.out.println("Comparison is not possible");
			return false;
		}		
	}

	public String toString()
		{
			 return " "+eid+" "+ename;
		}
}
public class HashMapDemo8
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(101,"Aryan");
		Employee e2 = new Employee(102,"Pooja");
		Employee e3 = new Employee(101,"Aryan");
		Employee e4 = e2;

		HashMap<Employee,String> hm = new HashMap<>();
		hm.put(e1,"Ameerpet");
		hm.put(e2,"S.R Nagar");
		hm.put(e3,"Begumpet");
		hm.put(e4,"Panjagutta");

		hm.forEach((k,v)-> System.out.println(k+" : "+v));
	}
}
------------------------------------------------------------------------
20-01-2024
-----------
HashMap :-  [Unsorted, Unordered, No Duplicate keys]
------------
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Clonable 

It is a predefined class available in java.util package under Map interface.

It gives us unsorted and Unordered map. when we need a map and we don't care about the order while iterating the elements through it then we should use HashMap.

It inserts the element based on the hashCode of the Object key using hashing technique [hasing alogorithhm]

It does not accept duplicate keys but value may be duplicate.

It accepts only one null key(because duplicate keys are not allowed) but multiple null values are allowed.

HashMap is not synchronized.  

Time complexcity of search, insert and delete will be O(1)

We should use HashMap to perform searching opeartion.

It contains 4 types of constructor 

1) HashMap hm1 = new HashMap();
    It will create the HashMap Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashMap is filled up then new HashMap Object will be created having double capacity)

2) HashMap hm2 = new HashMap(int initialCapacity);
    will create the HashMap object with specified capacity


3) HashMap hm3 = new HashMap(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4)HashMap hm4 = new HashMap(Map m);
    Interconversion of Map Collection
------------------------------------------------------------------------
//Program that shows HashMap is unordered
import java.util.*;
public class HashMapDemo 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new HashMap<>();
		   map.put("Ravi", "12345");  
		   map.put("Rahul", "12345");
		   map.put("Aswin", "5678");
		   map.put(null, "6390");
		   map.put("Ravi","1529");

		   System.out.println(map); 

           System.out.println(map.get(null));  
		   System.out.println(map.get("Virat"));  
		   
		   map.forEach((k,v)-> System.out.println("Key is :"+k+" value is "+v));
		                 
      }
}
-----------------------------------------------------------------------
//Program to search a particular key and value in the Map collection
import java.util.*;
public class HashMapDemo1
{
	public static void main(String args[]) 
	{
		HashMap<Integer,String> hm = new HashMap<>();			 
		hm.put(1, "JSE");  
		hm.put(2, "JEE");
		hm.put(3, "JME"); 
		hm.put(4,"JavaFX");
		hm.put(5,null);
		hm.put(6,null);
		
		System.out.println("Initial map elements: " + hm); 
		System.out.println("key 2 is present or not :"+hm.containsKey(2));   

		System.out.println("JME is present or not :"+hm.containsValue("JME")); 

		System.out.println("Size of Map : " + hm.size()); 
		hm.clear(); 	
		System.out.println("Map elements after clear: " + hm);	
	}
}
------------------------------------------------------------------------
//Collection view methods [keySet(),  values(),  entrySet()]
import java.util.*;
public class HashMapDemo2
{
public static void main(String args[]) 
	{
			Map<Integer,String> map = new HashMap<>(); 
			map.put(1, "C");
			map.put(2, "C++");
			map.put(3, "Java");
			map.put(4, ".net");
		
			map.forEach((k,v)->System.out.println("Key :"+k+" Value :"+v) );           
			           
			System.out.println("Return Old Object value :"+map.put(4,"Python"));  
		
			for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" : "+m.getValue());  
			}  
	}    
}
------------------------------------------------------------------------
import java.util.*;
public class HashMapDemo3
{
public static void main(String args[]) 
  {
		HashMap<Integer,String> map = new HashMap<>(10,8.5f);
		map.put(1, "Java");
		map.put(2, "is");
		map.put(3, "best");
		map.remove(3);  //will remove the complete Entry
		String val=(String)map.get(3);
		System.out.println("Value for key 3 is: " + val);
		map.forEach((k,v)->System.out.println(k +" : "+v));
   }    
}
-----------------------------------------------------------------------
//To merge two Map Collection (putAll)  
import java.util.*;
public class HashMapDemo4
{
public static void main(String args[]) 
	{
		HashMap<Integer,String> newmap1 = new HashMap<>();

		HashMap<Integer,String> newmap2 = new HashMap<>();	  

		newmap1.put(1, "SCJP");
		newmap1.put(2, "is");
		newmap1.put(3, "best");
			  
		System.out.println("Values in newmap1: "+ newmap1);

		newmap2.put(4, "Exam");

		newmap2.putAll(newmap1);

		newmap2.forEach((k,v)->System.out.println(k+" : "+v));		
   }    
}
------------------------------------------------------------------------
import java.util.*;
public class HashMapDemo5 
{
     public static void main(String[] argv) 
     {
          Map<String,String> map = new HashMap<>(9, 0.85f);
          map.put("key", "value");
          map.put("key2", "value2");
          map.put("key3", "value3");
		  map.put("key7","value7");


		   Set keys = map.keySet();//keySet return type is Set
		   System.out.println(keys ); //[]

          Collection val = map.values(); //values return type is collection
          System.out.println(val);
         
		  map.forEach((k,v)-> System.out.println(k+" : "+v));
		  
          	  
      }
}
-----------------------------------------------------------------------
//getOrDefault() method
import java.util.*;
public class  HashMapDemo6
{
	public static void main(String[] args) 
	{
		Map<String, String> map = new HashMap<>();
		map.put("A", "1");
		map.put("B", "2");
		map.put("C", "3");
        //if the key is not present, it will return default value .It is used to avoid null
		String value = map.getOrDefault("D","Key is not available");
		System.out.println(value);
		System.out.println(map); 
	}
}
------------------------------------------------------------------------
//interconversion of two HashMap
import java.util.*;
public class HashMapDemo7
	{
	public static void main(String args[])
	{		
		HashMap<Integer, String> hm1 = new HashMap<>();

		hm1.put(1, "Ravi");
		hm1.put(2, "Rahul");
		hm1.put(3, "Rajen");

		HashMap<Integer, String> hm2	= new HashMap<>(hm1);

		System.out.println("Mapping of HashMap hm1 are : "	+ hm1);
	
		System.out.println("Mapping of HashMap hm2 are : " + hm2);
	}
}
------------------------------------------------------------------------
LinkedHashMap :
------------------
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

It is a predefined class available in java.util package under Map interface.

It is the sub class of HashMap class.

It maintains insertion order. It contains a doubly linked with the elements or nodes so It will iterate more slowly in comparison to HashMap.

It uses Hashtable and LinkedList data structure.

If We want to fetch the elements in the same order as they were inserted then we should go with LinkedHashMap.

It accepts one null key and multiple null values.

It is not synchronized.

It has also 4 constructors same as HashMap

1) LinkedHashMap hm1 = new LinkedHashMap();
    will create a  LinkedHashMap with default capacity 16 and load factor 0.75

2) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity);

3) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity, float loadFactor);


4) LinkedHashMap hm1 = new LinkedHashMap(Map m);
------------------------------------------------------------------------
import java.util.*;
public class LinkedHashMapDemo 
{
	public static void main(String[] args) 
	{
		LinkedHashMap<Integer,String> l = new LinkedHashMap<>();
		l.put(1,"abc");
		l.put(3,"xyz");
		l.put(2,"pqr");
		l.put(4,"def");
		l.put(null,"ghi");
		System.out.println(l);
	}
}
-----------------------------------------------------------------------
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo1 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new LinkedHashMap<>();
           map.put("Ravi", "1234");
		   map.put("Rahul", "1234");
		   map.put("Aswin", "1456");
		   map.put("Samir", "1239");
           
		   map.forEach((k,v)->System.out.println(k+" : "+v));
      }
}
------------------------------------------------------------------------
Hashtable :
-----------
Hashtable :
------------
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Clonable, Serializable

It is predefined class available in java.util package under Map interface.

Like Vector, Hashtable is also form the birth of java so called legacy class.

It is the sub class of Dictionary class which is an abstract class.

The major difference between HashMap and Hashtable is, HashMap methods are un-synchronized where as Hastable methods are synchronized. 

HashMap can accept one null key and multiple null values where as Hashtable does not contain anything as a null(key and value both). if we try to add null value JVM will throw an exception i.e NullPointerException.

The initial default capacity of Hashtable class is 11 where as loadFactor is 0.75.


It has also same constructor as we have in HashMap.(4 constructors)

1) Hashtable hs1 = new Hashtable();
    It will create the Hashtable Object with default capacity as 11 as well as load factor is 0.75

2) Hashtable hs2 = new Hashtable(int initialCapacity);
    will create the Hashtable  object with specified capacity


3) Hashtable hs3 = new Hashtable(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor

4) Hashtable hs = new Hashtable(Map c);
    Interconversion of Map Collection
------------------------------------------------------------------------
import java.util.*;  
public class HashtableDemo
	{  
	 public static void main(String args[])
		{  
		  Hashtable<Integer,String> map=new Hashtable<>(); 
		  map.put(1, "Java");
		  map.put(2, "is");
		  map.put(3, "best");		
		  map.put(4,"language");
		  
		  //map.put(5,null);  

		  System.out.println(map);

		  System.out.println(".......................");

		    for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			} 
        }  
}  
-----------------------------------------------------------------------
import java.util.*;  
public class HashtableDemo1
{  
   public static void main(String args[])
	{  
    Hashtable<Integer,String> map=new Hashtable<>();          
     map.put(1,"Priyanka");    
     map.put(2,"Ruby");   
     map.put(3,"Vibha");    
     map.put(4,"Kanchan");
	
	 map.putIfAbsent(5,"Bina");  
	 map.putIfAbsent(24,"Pooja");
	 map.putIfAbsent(26,"Ankita");     
    
     map.putIfAbsent(1,"Sneha");  
     System.out.println("Updated Map: "+map); 
 }  
}  
-----------------------------------------------------------------------
IdentityHashMap :        
-----------------
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Clonable, Serializable.

It was introduced from JDK 1.4 onwards.

The IdentityHashMap uses == operator to compare keys.

As we know HashMap uses equals() and hashCode() method for comparing the keys based on the hashcode of the object it will serach the bucket location and insert the entry their only.

So We should use IdentityHashMap where we need to check the reference or memory address instead of logical equality.

HashMap uses hashCode of the "Object key" to find out the bucket loaction in Hashtable, on the other hand IdentityHashMap does not use hashCode() method actually It uses System.identityHashCode(Object o)

IdentityHashMap is more faster than HashMap in case of Comparison.

It has three constrcutors, It does not contain loadFactor specific constructor.
-----------------------------------------------------------------------
import java.util.*;
public class IdentityHashMapDemo 
{
	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm = new HashMap<>();

		IdentityHashMap<String,Integer> ihm = new IdentityHashMap<>();
		
		hm.put("Ravi",23);
		hm.put(new String("Ravi"), 24);
		
		ihm.put("Ravi",23);
		ihm.put(new String("Ravi"), 27); //compares based on == operator
		
		System.out.println("HashMap size :"+hm.size());  //1
		System.out.println(hm);
		System.out.println("........................");
		System.out.println("IdentityHashMap size :"+ihm.size()); //2		
		System.out.println(ihm);

	}

}
-----------------------------------------------------------------------22-01-2024
----------
WeakHashMap 
-----------
WeakHashMap :-
------------------
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

It is a predefined class in java.util package under Map interface.It was introduced from JDK 1.2v onwards.

While working with HashMap, keys of HashMap are of strong reference type. This means the entry of  map will not be deleted by the garbage collector even though the key is set to be null and  still it is not eligible for Garbage Collector.

On the other hand while working with WeakHashMap, keys of WeakHashMap are of weak reference type. This means the entry of a map is  deleted by the garbage collector if the key value is set to be null because it is of weak type.

So, HashMap dominates over Garbage Collector where as Garbage Collector dominates over WeakHashMap.

It contains 4 types of Constructor :
---------------------------------------
1) WeakHashMap wm1 = new WeakHashMap();
   
    Creates an empty WeakHashMap object with default capacity is 16 and load fator 0.75


2) WeakHashMap wm2 = new WeakHashMap(int initialCapacity);

3) WeakHashMap wm3 = new WeakHashMap(int initialCapacity, float loadFactor);

    Eg:- WeakHashMap wm = new WeakHashMap(10,0.9);

    capacity - The capacity of this map is 10. Meaning, it can store 10 entries.

    loadFactor - The load factor of this map is 0.9. This means whenever our hashtable is filled up by 90%, the entries are moved to a new hashtable of double the size of the original hashtable.

4) WeakHashMap wm4 = new WeakHashMap(Map m);

package com.ravi.weak_demo;

import java.util.WeakHashMap;

class Employee
{
	private int id;
	private String name;
	
	public Employee(int id, String name)
	{
		super();
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + "]";
	}
	
	@Override
	public void finalize()
	{
		System.out.println("Finalize method invoked by JVM");
	}
	
	
}

public class WeakHashMapDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Employee e1 = new Employee(111, "Scott");
		
		WeakHashMap<Employee,String> hm = new WeakHashMap<>();
		hm.put(e1, "S R nagar");
		
	    System.out.println(hm);
	    
	    e1 = null;
	    
	    System.out.println("Explicitly calling GC");
	    System.gc();
	    
	    Thread.sleep(5000);
	    
	    System.out.println(hm); //{}
		

	}

}
----------------------------------------------------------------------

SortedMap(I)
---------------
It is a predefined interface available in java.util package under Map interface.

We should use SortedMap interface when we want to insert the key element based on some sorting order i.e the default natural sorting order.

----------------------------------------------------------------------
TreeMap<K,V>
------------
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V> , Clonable, Serializable

It is a predefined class avaialble in java.util package under Map interface.

It is a sorted map that means it will sort the elements by natural sorting order based on the key using Comparator interface.

It will accept only homogeneous keys(non comparable objects are not allowed) 

It does not accept null key but null value allowed.

TreeMap implements NavigableMap and NavigableMap extends SortedMap. SortedMap extends Map interface.

TreeMap contains 4 types of Constructors :

1) TreeMap tm1 = new TreeMap(); //creates an empty TreeMap

2)  TreeMap tm2 = new TreeMap(Comparator cmp); //user defined soting logic

3)  TreeMap tm3 = new TreeMap(Map m);

4)  TreeMap tm4 = new TreeMap(SortedMap m);

-----------------------------------------------------------------------
import java.util.*;
public class TreeMapDemo 
{
	public static void main(String[] args) 
	{
		TreeMap t = new TreeMap(); 
		t.put(4,"Ravi");
		t.put(7,"Aswin");
		t.put(2,"Ananya");
		t.put(1,"Dinesh");
		t.put(9,"Ravi");	
		t.put(3,"Ankita");
		t.put(5,null);		
		
		System.out.println(t);
	}
}
-----------------------------------------------------------------------
import java.util.*;                        
public class TreeMapDemo1 
{
      public static void main(String args[]) 
      {
            TreeMap map = new TreeMap();
            map.put("one","1");
            map.put("two",null);
            map.put("three","3");
			map.put("four",4);

            displayMap(map);  

	map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v));
	 	       
      }
      static void displayMap(TreeMap map) 
      {
           Collection c = map.entrySet();   //Set<Map.Entry>

           Iterator i = c.iterator();
           i.forEachRemaining(x -> System.out.println(x));
      }
}
----------------------------------------------------------------------
//firstKey()  lastKey()  headMap()  tailMap()  subMap()

import java.util.*;
public class TreeMapDemo2
{
    public static void main(String[] argv) 
    {
        Map map = new TreeMap();  
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key1", "value1");

        System.out.println(map);

        SortedMap x = (SortedMap) map;
        System.out.println("First key is :"+x.firstKey());
        System.out.println("Last Key is :"+x.lastKey()); 
     }
}
----------------------------------------------------------------------
23-01-2024
-----------
package com.racvi.treemap_comparator;

import java.util.TreeMap;

class Employee
{
	private Integer employeeId;
	private String employeeName;
	private Integer employeeAge;
	public Employee(Integer employeeId, String employeeName, Integer employeeAge) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeAge = employeeAge;
	}
	public Integer getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(Integer employeeId) {
		this.employeeId = employeeId;
	}
	public String getEmployeeName() {
		return employeeName;
	}
	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}
	public Integer getEmployeeAge() {
		return employeeAge;
	}
	public void setEmployeeAge(Integer employeeAge) {
		this.employeeAge = employeeAge;
	}
	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeAge=" + employeeAge
				+ "]";
	}
}

public class TreeMapComparator 
{
	public static void main(String[] args) 
	{
		TreeMap<Employee,String> tm1 = new TreeMap<>((e1,e2)->e1.getEmployeeId()-e2.getEmployeeId());
		tm1.put(new Employee(1,"C",25), "Ameerpet");
		tm1.put(new Employee(2,"A",26), "S R nagar");
		tm1.put(new Employee(3,"B",24), "Koti");
		System.out.println("Sorting Based on the Employee ID :");
		tm1.forEach((k,v)-> System.out.println(k+" : "+v));
		
		TreeMap<Employee,String> tm2 = new TreeMap<>(  ( e1,e2)-> e1.getEmployeeName().compareTo(e2.getEmployeeName()));
		tm2.put(new Employee(1,"C",25), "Ameerpet");
		tm2.put(new Employee(2,"A",26), "S R nagar");
		tm2.put(new Employee(3,"B",24), "Koti");
		System.out.println("Sorting Based on the Employee Name :");
		tm2.forEach((k,v)-> System.out.println(k+" : "+v));
	}

}
--------------------------------------------------------------------
package com.racvi.treemap_comparator;

import java.util.TreeMap;

public class TreeMapDescending 
{
	public static void main(String[] args) 
	{
		TreeMap<Integer,String> map=new TreeMap<>((i1,i2)-> -(i1-i2));    
		  map.put(100,"Amit");    
		  map.put(101,"Ravi");    
		  map.put(102,"Vijay");    
		  map.put(103,"Rahul");   
		  
		  map.forEach((k,v)-> System.out.println(k+" : "+v));
	}

}

----------------------------------------------------------------------
Methods of SortedMap interface :
--------------------------------
1) firstKey()  //first key

2) lastKey()  //last key

3) headMap(int keyRange) //less than the specified range

4) tailMap(int keyRange)  //equal or greater than the specified range

5) subMap(int startKeyRange, int endKeyRange) //the range of key where startKey will be inclusive and endKey will be exclusive.

return type of headMap(), tailMap() and subMap() would be SortedMap(I)
----------------------------------------------------------------------
import java.util.*;  
public class SortedMapMethodDemo
	{  
 public static void main(String args[])
	 {  
		SortedMap<Integer,String> map=new TreeMap<>();    
		  map.put(100,"Amit");    
		  map.put(101,"Ravi");    
		  map.put(102,"Vijay");    
		  map.put(103,"Rahul");   

		  System.out.println("First Key: "+map.firstKey());  //100
		   System.out.println("Last Key "+map.lastKey());   //103
		   System.out.println("headMap: "+map.headMap(102));  //100 101
		   System.out.println("tailMap: "+map.tailMap(102));  //102 103
		   System.out.println("subMap: "+map.subMap(100, 102)); //100 101 

	 }
 }  
----------------------------------------------------------------------
NavigableMap (HW) :
-------------------
Just to navigate among the elements of map we are using NaviagbleMap
----------------------------------------------------------------------
Properties class:
-----------------
Properties class is used to maintain the data in the key-value form. It takes both key and value as a string. 

Properties class is a subclass of Hashtable. It provides the methods to store properties in a properties file and to get the properties from the properties file. System.getProperties() returns the all system properties.

Here we need to create a file with with extension .properties

db.properties
-------------
 driver = oracle.jdbc.driver.OracleDriver
 user = system
 password = tiger

 FileReader fr = new FileReader("db.properties");

 Properties p = new Properties();
 p.load(fr);
----------------------------------------------------------------------
 db.properties
 --------------
 driver = sun.jdbc.odbc.JdbcOdbcDriver    
 user = scott
 password = tiger

PropertiesExample1.java
------------------------
 import java.util.*;  
import java.io.*;  
public class PropertiesExample1 
{  
public static void main(String[] args)throws Exception
 {  
    FileReader reader=new FileReader("db.properties");  
      
    Properties p=new Properties();  
    p.load(reader);  
      
    System.out.println(p.getProperty("user"));  
    System.out.println(p.getProperty("password")); 
	System.out.println(p.getProperty("driver"));
 }  
}

By using Properties class we can dynamically change the property which we are taking from properties file without re-compilation of .java file
----------------------------------------------------------------------

import java.util.*;  
import java.io.*;  
public class PropertiesExample2 
{  
public static void main(String[] args)throws Exception
{  
	Properties p=System.getProperties();  
	Set set=p.entrySet();  
	
	Iterator itr=set.iterator();  
	while(itr.hasNext())
    {  
		Map.Entry entry=(Map.Entry)itr.next();  
		System.out.println(entry.getKey()+" = "+entry.getValue());  
	}  
  
}  }


System class has predefined static method getProperties() whose return type is Properties and it will provide all the System property.
---------------------------------------------------------------------
*Generics :
-----------
Why generic came into picture : 
------------------------------------
As we know our compiler is known for Strict type checking because java is a statically typed checked language.

The basic problem with collection is It can hold any kind of Object.

ArrayList al = new ArrayList();
al.add("Ravi");
al.add("Aswin");
al.add("Rahul");
al.add("Raj");
al.add("Samir");

for(int i =0; i<al.size(); i++)
{ 
   String s = (String) al.get(i);
   System.out.println(s);
}

By looking the above code it is clear that Collection stores everything in the form of Object so here even after adding String type only we need type casting as shown below.

import java.util.*;
class Test1 
{
	public static void main(String[] args) 
	{
        ArrayList al = new ArrayList();
		al.add(12);
		al.add(15);
		al.add(18);
		al.add(22);
		al.add(24);

		for (int i=0; i<al.size(); i++)
		{
             Integer x =(Integer) al.get(i);
			 System.out.println(x);
		}
	

    }

}

Even after type casting there is no guarantee that the things which are coming from ArrayList Object is Integer only because we can add anything in the Collection as a result java.lang.ClassCastException as shown in the program below.
----------------------------------------------------------------------
import java.util.*;
class Test2
{
	public static void main(String[] args) 
	{
		ArrayList t = new ArrayList(); //raw type
		t.add("alpha");
		t.add("beta");
		for (int i = 0; i < t.size(); i++) 
		{
		  String str =(String) t.get(i);
		  System.out.println(str);
		}

		 t.add(1234);
		 t.add(1256);
		  for (int i = 0; i < t.size(); ++i)
	          {	 
			 String obj= (String)t.get(i); //we can't perform type casting here
			 System.out.println(obj);
		  }
	}
}
----------------------------------------------------------------------
To avoid all the above said problem Generics came into picture from JDK 1.5 onwards
 
 -> It deals with type safe Object so there is a gurantee of both the end i.e putting inside and getting out.
 
 Example:-
 ArrayList<String > al = new ArrayList<>();

 Now here we have a gurantee that only String can be inserted as well as only String will come out from the Collection so we can perform String related operation.

 Advantages :-
 ---------------
 a) Type safe Object (No compilation warning)

 b) Strict compile time checking (Type erasure)

 c) No need of type casting

 24-01-2024
 ----------
 import java.util.*;
public class Test3
{
public static void main(String[] args) 
{
		ArrayList<String> al = new ArrayList<>();  //Generic type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
		
        for(int i=0; i<al.size(); i++)
		{
		String name = al.get(i); //no type casting is required
		System.out.println(name.toUpperCase());
		}
   }
}
------------------------------------------------------------------------
//Program that describes the return type of any method can be type safe 
//[We can apply generics on method return type]

import java.util.*;
public class Test4
{
	public static void main(String [] args)
	{
		Dog d1 = new Dog();
		Dog d2 = d1.getDogList().get(2);
		System.out.println(d2);
	}
}
class Dog
{
	public List<Dog> getDogList()
	{
		ArrayList<Dog> d = new ArrayList<>();
        d.add(new Dog());
		d.add(new Dog());
		d.add(new Dog());
		return d;
	}
}


Note :- In the above program the compiler will stop us from returning anything which is not compaitable List<Dog> and there is a gurantee that only "type safe list of Dog object" will be returned so we need not to provide type casting as shown below
Dog d2 = (Dog) d1.getDogList().get(0);  //before generic.
-----------------------------------------------------------------
//Mixing generic with non-generic
import java.util.*;

class Car
{
}
public class Test5
{
	public static void main(String [] args) 
	{
	ArrayList<Car> a = new ArrayList<>();
	a.add(new Car());
	a.add(new Car());
    a.add(new Car());

	ArrayList b = a;  //assigning Generic to raw type 	          
	
    System.out.println(b);   
	}
}
------------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test6 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 
		myList.add(4); 
		myList.add(6); 
		myList.add(5);
        
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println("The sum of Integer Object is :"+total); 
	} 
}  
class UnknownClass 
{ 
	public int addValues(List list)  //safe Object to unsafe object OR generic to raw type
	{ 
	Iterator it = list.iterator();    
	int total = 0; 
	while (it.hasNext()) 
	{
		int i = ((Integer)it.next());
		total += i;                           //total = 15
	} 
	return total; 
	} 
} 

Note :-
In the above program the compiler will not generate any warning message because even though we are assigning type safe Integer Object to unsafe or raw type List Object but this List Object is not inserting anything new in the collection so there is no risk to the caller.
------------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 

Here Compiler will generate warning message because the unsafe object is inserting the value 5 to safe object.
------------------------------------------------------------------------
*Type Erasure
------------
In the above program the compiler will  generate  warning message because the unsafe List Object is inserting the Integer object 5 so the type safe Integer object is getting value 5 from unsafe type so there is a problem to the caller method.

By writing ArrayList<Integer> actually JVM does not have any idea that our ArrayList was suppose to hold only Integers. 

All the type safe information does not exist at runtime. All our generic code is Strictly for compiler. There is a process done by java compiler called "Type erasure" in which the java compiler converts generic version to non-generic type.

List<Integer> myList = new ArrayList<Integer>();

At the compilation time it is fine but at runtime for JVM the code becomes

List myList = new ArrayList();

Note :- GENERIC IS STRICTLY A COMPILE TIME PROTECTION.
------------------------------------------------------------------------
Behavior of Polymorphism with Array and Generics :
--------------------------------------------------
//Polymorphism with array

import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}

public class  Test8
{
	public void checkAnimals(Animal animals[])  
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}

	public static void main(String[] args) 
	{
		Dog []dogs={new Dog(), new Dog()};

		Cat []cats={new Cat(), new Cat(), new Cat()};

		Bird []birds = {new Bird(), new Bird()};

		Test8 t = new Test8();

		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);
	}
}

Note :-From the above program it is clear that polymorphism(Upcasting) concept works with array.
-----------------------------------------------------------------
import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
    @Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}
class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}
public class Test9
{
	public void checkAnimals(List<Animal> animals)  
	{
		for(Animal animal : animals)
		{
             animal.checkup();
		}
	}
	public static void main(String[] args) 
	{
		List<Dog> dogs = new ArrayList<>();
		dogs.add(new Dog());
		dogs.add(new Dog());

		List<Cat> cats = new ArrayList<>();
		cats.add(new Cat());
		cats.add(new Cat());

		List<Bird> birds = new ArrayList<>();
		birds.add(new Bird());
		
		Test9 t = new Test9();
		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);

	}
}

Note :- The above program will generate the compilation error.

So from the above program it is clear that polymorphism does not work in the same way for generics as it does with arrays.

Eg:-

Parent [] arr = new Child[5]; //valid
Object [] arr = new String[5]; //valid

But in generics the same type is not valid

List<Object> list = new ArrayList<Integer>(); //Invalid
List<Parent> mylist = new ArrayList<Child>(); //Invalid
-----------------------------------------------------------------
import java.util.*;
public class Test10
{
public static void main(String [] args)
	{	
	   //ArrayList<Number> al = new ArrayList<Integer>(); [Compile time]
	   //ArrayList al = new ArrayList();  [Runtime]
	   //al.add("Ravi");
	     

		Object []obj = new String[3]; //valid with Array
		obj[0] = "Ravi";
		obj[1] = "hyd";
		obj[2] = 12; //java.lang.ArrayStoreException
	}
}

Note :- It will generate java.lang.ArrayStoreException because we are trying to insert 12 (integer value) into String array.

In Array we have an Exception called ArrayStoreException but the same Exception or such type of exception, is not available with Generics that is the reason in generics compiler does not allow upcasting concept.
(It is a strict compile time checking)
------------------------------------------------------------------------
import java.util.*;
class Parent
{
}
class Child extends Parent
{
}

public class Test11
{
public static void main(String [] args)
	{	
		ArrayList<Parent> lp = new ArrayList<Child>(); //error

		ArrayList<Parent> lp1 = new ArrayList<Parent>(); 

		ArrayList<Child> lp2 = new ArrayList<>(); 

		System.out.println("Success");
	}
}
-----------------------------------------------------------------------
Wild card character(?) :
------------------------
<?> -: Many possibilities

<Animal>-: Only <Animal> can assign, but not Dog or sub type of animal

<? super Dog> -: Dog, Animal, Object can assign (Compiler has                      surity)

<? extends Animal> -: Below of Animal(Child of Animal) means, sub classes of Animal (But the compiler does not have surity because you can have many sub classes of Animal in the future, so chances of wrong collections)
------------------------------------------------------------------------
//program on wild-card chracter
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}
public class Test12
{
public static void main(String [] args)
	{	
		List<?> lp = new ArrayList<Parent>(); 
		System.out.println("Wild card....");
	}
}
------------------------------------------------------------------------
import java.util.*;
public class Test13 
{
	public static void main(String[] args) 
	{
		List<? extends Number> list1 = new ArrayList<Double>();

		List<? super Integer> list2 = new ArrayList<Object>();

		List<? super Beta> list3 = new ArrayList<Alpha>();

		List list4 = new ArrayList();
		
		System.out.println("yes");
	}
}

class Alpha
{
}
class Beta extends Alpha
{
}
-----------------------------------------------------------------------
import java.util.*;
public class  Test14
{
	public static void main(String[] args) 
	{
		try
		{
	     List<Object> x = new ArrayList<>(); //Array of Object[java 9]
            x.add(10);
			x.add("Ravi");
			x.add(true);
			x.add(34.89);
			System.out.println(x);
		}
		catch (Exception e)
		{
			System.out.println(e);
		}
	}
}
-----------------------------------------------------------------------
class MyClass<T>     
{
	T obj;
	public MyClass(T obj)       //Student obj
	{
		this.obj=obj;
	}

	T getObj()
	{
		return obj;
	}
}
public class Test15
{
	public static void main(String[] args) 
	{
		Integer i=12;
		MyClass<Integer> mi = new MyClass<Integer>(i);
		System.out.println("Integer object stored :"+mi.getObj());

		Float f=12.34f;
		MyClass<Float> mf = new MyClass<Float>(f);
		System.out.println("Float object stored :"+mf.getObj());

		MyClass<String> ms = new MyClass<String>("Rahul");
		System.out.println("String object stored :"+ms.getObj());

		MyClass<Boolean> mb = new MyClass<Boolean>(false);
		System.out.println("Boolean object stored :"+mb.getObj());

		Double d=99.34;
		MyClass<Double> md = new MyClass<Double>(d);
		System.out.println("Double object stored :"+md.getObj());

		MyClass<Student> mStd = new MyClass<Student>(new Student());
		System.out.println("Student Object Stored :"+mStd.getObj());
	}
}

class Student
{
	@Override
	public String toString()
	{
		return "Student toString";
	}
}
-----------------------------------------------------------------------
25-01-2024
----------
//E stands for Element type
class Fruit    
{
}
class Apple extends Fruit   //Fruit is the super, Apple is sub class
{
}

class Basket<E>      //E is of type Fruit
{
	private E element;	
	public void setElement(E element) //Fruit element = new Apple();
	{
		this.element = element;
	}	

	public E getElement()    //public Fruit getElement(){}
	{
		return this.element;		
	}
}

public class Test16
{
	public static void main(String[] args) 
	{
		Basket<Fruit> b = new Basket<Fruit>();
		b.setElement(new Apple());
		Apple x = (Apple)b.getElement();	
		System.out.println(x);

       
        Basket<Fruit> b1 = new Basket<Fruit>();
		b1.setElement(new Mango());
		Mango y = (Mango)b1.getElement();	
		System.out.println(y);
		
	}
}
class Mango extends Fruit
{
}
----------------------------------------------------------------------
Queue interface :-
-------------------
1) It is sub interface of Collection(I)

2) It works in FIFO(First In first out) 

3) It is an ordered collection.

4) In a queue, insertion is possible from last is called REAR where as deletion is possible from the starting is called FRONT of the queue.

5) From jdk 1.5 onwards LinkedList class implments Queue interface to handle the basic queue operations. 

PriorityQueue :
----------------
public class PriorityQueue extends AbstractQueue implements Serializable 

It is a predefined class in java.util package, available from Jdk 1.5 onwards.

It inserts the elements based on the priority HEAP (Using Binary tree).

The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.

A priority queue does not permit null elements as well as It uses Binary tree to insert the elements.

It provides natural sorting order so we can't take non-comparable objects(hetrogeneous types of Object)

The initial capacity of PriorityQueue is 11.

Constructor :
--------------
1) PriorityQueue pq1 = new PriorityQueue();

2) PriorityQueue pq2 = new PriorityQueue(int initialCapacity);

3) PriorityQueue pq3 = new PriorityQueue(int initialCapacity, Comparator cmp);

4) PriorityQueue pq4 = new PriorityQueue(Collection c);

Methods :-
----------
add() / offer() :- Used to add an element in the Queue

poll() :- It is used to fetch the elements from top of the queue, after fetching it will delete the element.


peek() :- It is also used to fetch the elements from top of the queue, Unlike poll it will only fetch but not delete the element.

boolean remove(Object element) :- It is used to remove an element. The return  type is boolean. 

import java.util.PriorityQueue;
public class PriorityQueueDemo3
{
      public static void main(String[] argv)
      {
            PriorityQueue<Integer> pq = new PriorityQueue<>();
			pq.add(11);
            pq.add(2);
            pq.add(4);          
			pq.add(6);
           System.out.println(pq);
	  }
}
-----------------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo1 
{
      public static void main(String[] argv) 
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("9");
            pq.add("8");
			pq.add("7");
            System.out.print(pq.peek() + " ");  //7 3 5 6
            pq.offer("6");      //  6 7 8 9
			pq.offer("5");
            pq.add("3");

            pq.remove("1");    
            System.out.print(pq.poll() + " ");
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek());
			System.out.println(pq); 
      }
}
-----------------------------------------------------------------------import java.util.PriorityQueue;
public class PriorityQueueDemo2
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("2");
            pq.add("4");          
			pq.add("6");  //       6  9
            System.out.print(pq.peek() + " "); //2  2  3  4  4
            pq.offer("1");
			pq.offer("9");
            pq.add("3");   
			
            pq.remove("1");
            System.out.print(pq.poll() + " "); 
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek()+"  "+pq.poll());
	  }
}
-----------------------------------------------------------------------
import java.util.PriorityQueue;

public class PriorityQueueDemo 
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("Orange");
			pq.add("Apple");
			pq.add("Mango");
			pq.add("Guava");
			pq.add("Grapes");
			
			System.out.println(pq);            

      }
}

Note :- The insertion of the elemenmts is based on Binary tree.
----------------------------------------------------------------------
*Stream API :
------------
Streams in java :
------------------
It is introduced from Java 8 onwards, the Stream API is used to process the collection objects.

It contains classes for processing sequence of elements over Collection object and array.

Stream is a predefined interface available in java.util.stream sub package

Package Information :
---------------------
java.util -> Base package
java.util.function -> Functional interfaces
java.util.concurrent -> Multithreaded support
java.util.stream -> Processing of Collection Object

forEach() method in java :
-----------------------------
The Java forEach() method is a  technique to iterate over a collection such as (list, set or map) and stream. It is used to perform a given action on each of the element of the collection.

The forEach() method has been added in following places:

Iterable interface Ä¾ This makes Iterable.forEach() method available to all collection classes. Iterable interface is the super interface of Collection interface

Map interface Ä¾ This makes forEach() operation available to all map classes.

Stream interface Ä¾ This makes forEach() operations available to all types of stream.
----------------------------------------------------------------------
Creation of Streams to process the data :
-----------------------------------------------
We can create Stream from  collection or array with the help of stream() and of() methods:

A stream()  method is added to the Collection interface and allows creating a Stream<T> using any collection object as a source

public java.util.Stream<E> stream();

The return type of this method is Stream interafce available in java.util.stream sub package.

Eg:-
List<String> items = new ArrayList<String>();
		items.add("Apple");
		items.add("Orange");
		items.add("Mango");
		Stream<String> stream = items.stream();
-----------------------------------------------------------------------
import java.util.*;  //Base package
import java.util.stream.*; //Sub package
public class StreamDemo1 
{
	public static void main(String[] args) 
	{
		List<String> items = new ArrayList<String>();

		items.add("Apple");
		items.add("Orange");
		items.add("Mango");

               //Collections Object to Stream
		Stream<String> strm = items.stream();
		strm.forEach(p -> System.out.println(p));
	}
}
-----------------------------------------------------------------------
Stream.of()       
--------------
public static java.util.stream.Stream  of(<T>)
-----------------------------------------------------
It is a static method of Stream interface through which we can create Stream of arrays and Collection. The return type of this method is Stream interface
--------------------------------------------------------------
//Stream.of()
import java.util.stream.*;
public class StreamDemo2 
{
	public static void main(String[] args) 
	{
		Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);
		stream.forEach(p -> System.out.println(p));

		System.out.println("...............................");

         //Anonymous Array Object
		Stream<Integer> strm = Stream.of( new Integer[]{15,29,45,8,16} );
		strm.forEach(p -> System.out.println(p));
	}
}
-----------------------------------------------------------------------
26-01-2024
-----------
Operation in Stream API :
-------------------------
In Java, the Stream API provides a wide range of operations that can be performed on a stream of elements. 

These operations can be categorized into two main types: intermediate operations and terminal operations.

Intermediate Operations:
------------------------
filter(Predicate<T> predicate): Returns a new stream which contains filtered elements based on the boolean expression using Predicate.

map(Function<T, R> mapper): Transforms elements in the stream using the provided mapping function.  

flatMap(Function<T, Stream<R>> mapper): Flattens a stream of streams into a single stream. 

distinct(): Returns a stream with distinct elements (based on their equals method).

sorted(): Returns a stream with elements sorted in their natural order.

sorted(Comparator<T> comparator): Returns a stream with elements sorted using the specified comparator.

peek(Consumer<T> action): Allows us to perform an action on each element in the stream without modifying the stream.

limit(long maxSize): Limits the number of elements in the stream to a specified maximum size.

skip(long n): Skips the first n elements in the stream.

takeWhile(Predicate<T> predicate): Returns a stream of elements from the beginning until the first element that does not satisfy the predicate.

dropWhile(Predicate<T> predicate): Returns a stream of elements after skipping elements at the beginning that satisfy the predicate.


Working with Intermediate operations :
--------------------------------------
public abstract Stream<T> filter(Predicate p) : 
----------------------------------------------------
It is a predfined method of Stream interface. It is used to select/filter elements as per the Predicate passed as an argument. It is basically used to filter the elements based on boolean condition.

public abstract <T>  collect(java.util.stream.Collectors c)
----------------------------------------------------------------
It is a predfined method of Stream interface. It is used to return the result of the intermediate operations performed on the stream. It is used to collect the data after filteration and convert the data to the Collection.

Collectors is a predfined final class available in java.util.stream sub package which conatins a static method toList() and toSet() to convert the data as a List/Set i.e Collection object. The return type of this method is List/Set interface.
-------------------------------------------------------------------------
//Filter all the even numbers from Collection 
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo3 
{
	public static void main(String[] args) 
	{
		List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,3, 10);

          //Without Stream
          List<Integer> listEven = new ArrayList<Integer>();

		  for(Integer i : list)
			{
			       if(i%2==0)
				      listEven.add(i);
			}
            System.out.println(listEven);
           System.out.println(".........................................");

        //With Stream which prints only even numbers
		List<Integer> even = list.stream().filter(i -> i%2 == 0).collect(Collectors.toList());
		System.out.println(even);

        //With Stream which prints only odd numbers
		Set<Integer> odd = list.stream().filter(i -> i%2==1).collect(Collectors.toSet());
		System.out.println(odd);
	}
}
-------------------------------------------------------------------------
//Filtering the name
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo4 
{
	public static void main(String[] args) 
	{
		List<String> list = Arrays.asList("Ravi", "Rahul", "Akshar", "Roshan","Raj","Ankit");		

		//Filter all the name which starts from R
		             List<String> collect = list.stream().filter(str -> str.startsWith("A")).collect(Collectors.toList());
		             System.out.println(collect);
		 
		
    
	}
}
-------------------------------------------------------------------------
public Stream sorted(Comparator cmp) :
---------------------------------------------
It is a predfined method of Stream interface which is used to sort the data using comparator interface.
----------------------------------------------------------------
//Sorting the data
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo5 
{
	public static void main(String[] args) 
	{
	List<String> names = Arrays.asList("Zaheer","Rahul","Aryan","Sailesh");

		List<String> sortedName =
            names.stream().sorted().collect(Collectors.toList());
		
        sortedName.forEach(str -> System.out.println(str));
	}
}
-------------------------------------------------------------------------
package com.ravi.basic;
import java.util.*; 
class Customer
{  
    int id;  
    String name;  
    float bill;  

    public Customer(int id, String name, float bill) 
	{  
        this.id = id;  
        this.name = name;  
        this.bill = bill;  
    }  
}  
public class StreamDemo6 
{  
    public static void main(String[] args) 
	{  
        List<Customer> customersList = new ArrayList<>();  
       
        customersList.add(new Customer(1,"Aryan",25000f));  
        customersList.add(new Customer(2,"Ravi",30000f));  
        customersList.add(new Customer(3,"Sailesh",28000f));  
        customersList.add(new Customer(4,"Rohan",28000f));  
        customersList.add(new Customer(5,"Raj",90000f));  
       
		//  filtering data  
        customersList.stream()  
                             .filter(Customer -> Customer.bill < 27000)  
                             .forEach(Customer -> System.out.println(Customer.name));    
    }  
}  

Assignment : Create and Store the Product object and by using java 8 Stream API filter the Product data based on the price where price of the Product must be greater than 50K.
-------------------------------------------------------------------------
public Stream map(Function<T,R> mapper) :
-------------------------------------------------
It is a predefined method of Stream interface.

It takes Function (Predefined functional interafce ) as a parameter.

It performs intermediate operation and consumes single element from input Stream and produces single element to output Stream.

Here mapper function is functional interface which takes one input and provides one output.

//Find even numbers in stream and collect the cubes
package com.ravi.basic;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
 
public class StreamDemo7 
{
    public static void main(String[] args) 
    {
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);       
 
        List<Integer> cubeOfNumbers = list.stream()
                    .filter(n -> n % 2 == 0)
                    .map(n -> n * n * n)
                    .collect(Collectors.toList());
         
        System.out.println(cubeOfNumbers);
    }
}
-------------------------------------------------------------------------
//Program on map(Function<T,R> mapped)
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo8
{ 
	public static void main(String args[])
	{
		List<Player> listOfPlayers = createMyPlayerList();
		
		// Using map function to convert Stream<Player> to Stream<String>
		Set<String> listOfPlayerNames = listOfPlayers.stream()
										.map(p -> p.getName()) 
										.collect(Collectors.toSet());
		listOfPlayerNames.forEach(System.out::println);
	}		
	
	public static List<Player> createMyPlayerList()
	{
		List<Player> listOfPlayers=new ArrayList<>();
		Player p1= new Player("Rohit",29);
		Player p2= new Player("Virat",30);
		Player p3= new Player("K L Rahul",27);
		Player p4= new Player("Dhoni",34);
		Player p5= new Player("Sachin",37);
		Player p6= new Player("Rohit",37);
		Player p7= new Player("Virat",30);
		listOfPlayers.add(p1);
		listOfPlayers.add(p2);
		listOfPlayers.add(p3);
		listOfPlayers.add(p4);
		listOfPlayers.add(p5);
		listOfPlayers.add(p6);
        listOfPlayers.add(p7);
		return listOfPlayers;
	}
}
 
class Player 
{	
	private String name;
	private int age;
	
	public Player(String name, int age) 
	{
		super();
		this.name = name;
		this.age = age;
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
-------------------------------------------------------------------------
public Stream flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
---------------------------------------------------------
It is a predefined method of Stream interface.

The map() method produces one output value for each input value in the stream. So if there are n elements in the stream, map() operation will produce a stream of n output elements.

flatMap() is two step process i.e. map() + Flattening. It helps in converting Collection<Collection<T>> to Collection<T> [to make flat i.e converting Collections of collection into single collection or merging of all the collection]

//flatMap()
//map + Flattening [Converting Collections of collection into single collection]

[{1,2},{3,4},{5,6}] -> Flattening [1,2,3,4,5,6]



package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo9  
{
	public static void main(String[] args) 
	{
		List<String> list1 = Arrays.asList("A","B","C");
		List<String> list2 = Arrays.asList("D","E","F");
		List<String> list3 = Arrays.asList("G","H","I");
		 
		List<List<String>> listOfLists = Arrays.asList(list1, list2, list3);
		 
		List<String> listOfAllStrings = listOfLists.stream().flatMap(x -> x.stream()).collect(Collectors.toList());
		 
		System.out.println(listOfAllStrings);    
	}
}
-------------------------------------------------------------------------
27-01-2024
-----------

//Flattening of prime, even and odd number
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class FlatMapDemo1 
{
	public static void main(String[] args)
	{
      List<Integer> primeNumbers = Arrays.asList(5,7,11);
      List<Integer> evenNumbers = Arrays.asList(2,4,6);
      List<Integer> oddNumbers = Arrays.asList(1,3,5);
      
      List<List<Integer>> numbers = Arrays.asList(primeNumbers,evenNumbers,oddNumbers);
      
      List<Integer> collect = numbers.stream().flatMap(num -> num.stream()).collect(Collectors.toList());
      
      System.out.println(collect);  	

	}
}
-------------------------------------------------------------------------
//Fetching first character using flatMap()
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo2 
{
	public static void main(String[] args)
	{
		List<String> asList = Arrays.asList("Jyoti","Ankit","Vaibhab","Aman");
		        
		List<Character> collect = asList.stream().flatMap(str -> Stream.of(str.charAt(0))).collect(Collectors.toList());
		System.out.println(collect);
		
		
	}

}
-------------------------------------------------------------------------
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;

class Product
{
	private Integer productId;
	private List<String> listOfProducts;
	
	public Product(Integer productId, List<String> listOfProducts) {
		super();
		this.productId = productId;
		this.listOfProducts = listOfProducts;
	}

	public Integer getProductId() {
		return productId;
	}

	public List<String> getListOfProducts() {
		return listOfProducts;
	}
}

public class FlatMapDemo3 
{
	public static void main(String[] args) 
	{
		List<Product> listOfProduct = Arrays.asList(
	    new Product(1, Arrays.asList("Camera", "Mobile","Laptop")),
		new Product(2, Arrays.asList("Bat", "Ball","Wicket")),
		new Product(3, Arrays.asList("Chair", "Table","Lamp")),
		new Product(4, Arrays.asList("Cycle", "Bike","Car"))
				
				);
		
		listOfProduct.stream().flatMap(p -> p.getListOfProducts().stream()).forEach(System.out::println);

	}

}
-------------------------------------------------------------------------
Difference between map() and flatMap()
--------------------------------------
map()  method transforms each element into another single element.

flatMap() transforms each element into a stream of elements and then flattens those streams into a single stream.

We should use map() when you want a one-to-one transformation, and  we should use flatMap() when dealing with nested structures or when you need to produce multiple output elements for each input element.
------------------------------------------------------------------------
public Stream distinct() :
--------------------------
It is a predefined method of Stream interface.

If we want to return stream from another stream by removing all the duplicates then we should use distinct() method.
------------------------------------------------------------------------
package com.ravi.basic;
import java.util.stream.Stream;
public class StreamDemo10
{
	public static void main(String[] args)
		{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Virat", "Rohit","Aswin","Bumrah");
		s.distinct().sorted().forEach(System.out::println);	
		
	}

}
------------------------------------------------------------------------
public Stream<T> limit(long maxSize) :
----------------------------------------
It is a predefined method of Stream interface to work with sequence of elements.

The limit() method is used to limit the number of elements in a stream by providing maximum size.

It creates a new Stream by taking the data from original Stream.

Elements which are not in the range or beyond the range of specified limit will be ignored.

package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo11 
{
	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		Stream<Integer> limitedStream = numbers.limit(8);

		limitedStream.forEach(System.out::println);
	}
}
-------------------------------------------------------------------------
public Stream<T> skip(long n) :
-------------------------------
It is a predefined method of Stream interface which is used to skip the elements from begning of the Stream.

It returns a new stream that contains the remaining elements after skipping the specified number of elements which is passed as a parameter.

package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo12 
{
	public static void main(String[] args) 
	{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Zaheer", "Raina");
		s.skip(2).limit(3).forEach(System.out::println);
	}
}
-------------------------------------------------------------------------
public Stream<T> peek(Consumer<? super T> action) :
--------------------------------------------
It is a predefined method of Stream interface which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

It is an intermediate operation that allows us to perform operation on each element of Stream without modifying original.

The peek() method takes a Consumer as an argument, and this function is applied to each element in the stream. The method returns a new stream with the same elements as the original stream.

package com.ravi.basic;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamDemo13 
{
	public static void main(String[] args) 
	{
		Stream<String> numbers = Stream.of("Apple","Mango","Grapes","Kiwi","pomogranate");

		List<Integer> doubledNumbers = numbers
		    .peek(num -> System.out.println("Peeking from Original: " + num.toUpperCase()))
		    .map(num -> num.length())
		    .collect(Collectors.toList());
		System.out.println("-----------------");
		System.out.println(doubledNumbers);
		
	}

}
-------------------------------------------------------------------------
public Stream<T> takeWhile(Predicate<T> predicate) :
-----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

*It is used to create a new stream that includes elements from the original stream only as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo14 
{
 public static void main(String[] args) 
 {
	 Stream<Integer> numbers = Stream.of(10,11,9,13,2,1,100);

     numbers.takeWhile(n -> n > 9).forEach(System.out::println);     

     System.out.println(".......................");
     
     numbers = Stream.of(12,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n%2==0).forEach(System.out::println);
     
     System.out.println(".......................");
     
     numbers = Stream.of(1,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n < 9).forEach(System.out::println);
     
     System.out.println(".......................");
     
     numbers = Stream.of(11,2,3,4,5,6,7,8,9); 
     
     numbers.takeWhile(n -> n > 9).forEach(System.out::println);
     
     System.out.println(".............................");
     
     Stream<String> stream = Stream.of("Ravi", "Ankit", "Rohan", "Aman", "Ravish"); 

     stream.takeWhile(str -> str.charAt(0)=='R').forEach(System.out::println);  
	 
 }
}

-------------------------------------------------------------------------
public Stream<T> dropWhile(Predicate<T> predicate) :
----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to create a new stream by excluding elements from the original stream as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo15 {

	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num < 5).forEach(System.out::println);
		
		System.out.println("..................................");
		
		numbers = Stream.of(15, 8, 7, 9, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num > 5).forEach(System.out::println);		
	}
}
-------------------------------------------------------------------------
Optional<T> class in Java :
------------------------
It is a predefined final and immutable class available in java.util package from java 1.8v.

It is a container object which is used to represent an object (Optional object) that may or may not contain a non-null value.

If the value is available in the container, isPresent() method will return true and get() method will return the actual value.

It is very useful in industry to avoid NullPointerException.

Methods of Optional<T> class :
-------------------------------
1) public static Optional<T> ofNullable(T x) : 
-------------------------------------------
It will return the object of Optional class with specified value. If the specified value is null then this method will return an empty object of the optional class.

2) public boolean isPresent() :
--------------------------------
It will return true, if the value is available in the container otherwise it will return false.

3) public T get() :
--------------------
It will get/fetch the value from the container, if the value is not available then it will throw NoSuchElementException.

4) public T orElse(T defaultValue) : 
-------------------------------------
It will return the value, if available  otherwise it will return the specified default value.

5) public static Optional<T> of (T value) :
--------------------------------------------
It will return the optional object with the specified value that is non- null value.

6) public static Optional<T> empty() :
---------------------------------------
It will return an empty Optional Object.

OptionalDemo1.java
-------------------
//Program to verify whether the container has value or not 
package com.ravi.optional_class_demo;

import java.util.Optional;

public class OptionalDemo1 
{	
	public static void main(String[] args) 
	{
		String str = null;
		
		Optional<String> optional = Optional.ofNullable(str);		
		String orElse = optional.orElse("No value in container");
		System.out.println("Value by orElse :"+orElse);
		
		
		
		//Optional is containing value or not?
		if(optional.isPresent())
		{
			System.out.println("Value by get :"+optional.get());
		}
		else
		{
			System.out.println("No value is available");
		} 
		
	}

}
--------------------------------------------------------------------------
//Writing different style of getter with Optional<T> class as a return
type

package com.ravi.optional_class_demo;
import java.util.Optional;
class Employee
{
	private Integer empId;
	private String empName;
	
	public Employee() {}
	
	public Employee(Integer empId, String empName) 
	{
		super();
		this.empId = empId;
		this.empName = empName;
	}

	//Changing the style of writing getter method
	public Optional<Integer> getEmpId() 
	{
		return Optional.ofNullable(empId);
	}

	public Optional<String> getEmpName() 
	{
		return Optional.ofNullable(empName);
	}	
}

public class OptionalDemo2 
{
	public static void main(String[] args) 
	{
		Employee emp = new Employee(111,"Ravi");		
		//Employee emp = new Employee();
		
		Optional<Integer> empId = emp.getEmpId();
		if(empId.isPresent())
		{
			System.out.println(empId.get());
		}
		else
		{
			System.out.println("No id value ");
		}
		
		Optional<String> empName = emp.getEmpName();
		if(empName.isPresent())
		{
			System.out.println(empName.get());
		}
		else
		{
			System.out.println("No name value ");
		}
		         
	}
}
---------------------------------------------------------------------------
//Program to verify value is available or not
package com.ravi.optional_class_demo;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class OptionalDemo3
{
    public static void main(String[] args) 
    {
        List<Optional<String>> optionalList = new ArrayList<>();

        optionalList.add(Optional.of("Ameerpet"));
        optionalList.add(Optional.of("S.R Nager"));
        optionalList.add(Optional.of("Begumpet"));
        optionalList.add(Optional.of("Koti")); 
        optionalList.add(Optional.empty());

        
        for (Optional<String> optional : optionalList) 
        {
            if (optional.isPresent()) 
            {
                System.out.println(optional.get());
            } 
            else 
            {
                System.out.println("No data is available");
            }
        }
    }
}
--------------------------------------------------------------------------

//Immutability of Optional class

package com.ravi.optional_class_demo;
import java.util.Optional;
public class OptionalDemo4
{
    public static void main(String[] args) 
    {        
        Optional<String> initialOptional = Optional.of("India");
        System.out.println(initialOptional.hashCode()); 

        Optional<String> modifiedOptional = modifyOptional(initialOptional);
        System.out.println(modifiedOptional.hashCode());

        // Check if the original Optional is still the same
        System.out.println("Address is :" + (initialOptional == modifiedOptional));       
      
    }

    public static Optional<String> modifyOptional(Optional<String> optional) 
    {
       
        if (optional.isPresent())
        {
            return Optional.of("Modified: " + optional.get());
        } 
        else 
        {
            return Optional.empty();
        }
    }
}
---------------------------------------------------------------------------
Record class :
--------------
public abstract class Record extends Object.

It is a new feature introduced from java 17.(In java 14 preview version)

As we know only objects are moving in the network from one place to another place so we need to write BLC class with nessacery requirements to make BLC class as a Data carrier class.

Records are immutable data carrier so, now with the help of record we can send our immutable data from one application to another application.

It is also known as DTO (Data transfer object) OR POJO classes.

It is mainly used to concise our code as well as remove the boiler plate code.

In record, automatically constructor will be generated which is known as canonical constructor and the variables which are known as components are by default final.

In order to validate the outer world data, we can write our own constructor which is known as compact constructor.

Record will automatically generate the implemenation of toString(), equals(Object obj) and hashCode() method.

We can define static and non static method as well as static variable inside the record. We cannot define instance variable inside the record.

We cann't extend or inherit records because by default every record is implicilty final. It is extending from java.lang.Reocrd class

We can implement an interface by using record.

CustomerClass.java
-------------------
package com.ravi.record;

import java.util.Objects;

public class CustomerClass {
	private int id;
	private String name;
	private double bill;

	public CustomerClass(int id, String name, double bill) {
		super();
		this.id = id;
		this.name = name;
		this.bill = bill;
	}

	@Override
	public String toString() {
		return "CustomerClass [id=" + id + ", name=" + name + ", bill=" + bill + "]";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public double getBill() {
		return bill;
	}

	public void setBill(double bill) {
		this.bill = bill;
	}

	@Override
	public int hashCode() {
		return Objects.hash(bill, id, name);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		CustomerClass other = (CustomerClass) obj;
		return Double.doubleToLongBits(bill) == Double.doubleToLongBits(other.bill) && id == other.id
				&& Objects.equals(name, other.name);
	}

	
}
--------------------------------------------------------------------------
CustomerRecord.java
--------------------
package com.ravi.record;

public record CustomerRecord(int id, String name, double bill) 
{
	//Compact Constructor
	   public CustomerRecord
	   {
		   
		   if(id < 0)
		   {
			   throw new IllegalArgumentException("Id is invalid");
		   }
		   else
		   {
			  
		   }
	   }
}
---------------------------------------------------------------------------
package com.ravi.record;

public class Main {

	public static void main(String[] args) 
	{
		CustomerClass c1 = new CustomerClass(1, "A", 23);
		CustomerClass c2 = new CustomerClass(1, "A", 23);
		System.out.println(c1.equals(c2));
		System.out.println(c1);
		String name = c1.getName();
		System.out.println(name);
		
		
		System.out.println(".................");
		
		CustomerRecord r1 = new CustomerRecord(2, "B", 40);
		CustomerRecord r2 = new CustomerRecord(2, "B", 40);
		System.out.println(r1.equals(r2));
		System.out.println(r1);
		String name2 = r1.name();
		System.out.println(name2);
		
		

	}

}
---------------------------------------------------------------------------
Terminal Operation :
-
